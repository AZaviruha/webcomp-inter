(function(resolver) {
	if (typeof exports === 'object' && typeof module !== 'undefined') {
		module.exports = resolver();
	} else if (typeof define === 'function' && define.amd) {
		define(["module"], resolver);
	} else {
		var _global;
		if (typeof window !== 'undefined') {
			_global = window;
		} else if (typeof global !== 'undefined') {
			_global = global;
		} else if (typeof self !== 'undefined') {
			_global = self;
		} else {
			_global = this;
		}
		var config = _global['WebComponents'];
		typeof(config) !== 'object' && (config = void(0));
		_global['WebComponents'] = resolver({
			config: function() {
				return config;
			}
		});
	}
})(function(module) {
	// Fix for xpath library
	var Functions, Utilities;

	// Custom require factory
	var require = (function(dependencyList, modules) {
		return function(moduleName) {
			return modules[dependencyList.indexOf(moduleName)];
		};
	})(["module"], arguments), require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator/runtime");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/shim":90,"regenerator/runtime":91}],2:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var $ = require('./$');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = $.toObject($this)
      , length = $.toLength(O.length)
      , index  = $.toIndex(fromIndex, length)
      , value;
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index;
    } return !IS_INCLUDES && -1;
  };
};
},{"./$":23}],3:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var $   = require('./$')
  , ctx = require('./$.ctx');
module.exports = function(TYPE){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that){
    var O      = Object($.assertDefined($this))
      , self   = $.ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = $.toLength(self.length)
      , index  = 0
      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./$":23,"./$.ctx":11}],4:[function(require,module,exports){
var $ = require('./$');
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
assert.def = $.assertDefined;
assert.fn = function(it){
  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
  return it;
};
assert.obj = function(it){
  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
assert.inst = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
module.exports = assert;
},{"./$":23}],5:[function(require,module,exports){
var $        = require('./$')
  , enumKeys = require('./$.enum-keys');
// 19.1.2.1 Object.assign(target, source, ...)
/* eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/* eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = enumKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
},{"./$":23,"./$.enum-keys":14}],6:[function(require,module,exports){
var $        = require('./$')
  , TAG      = require('./$.wks')('toStringTag')
  , toString = {}.toString;
function cof(it){
  return toString.call(it).slice(8, -1);
}
cof.classof = function(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
};
cof.set = function(it, tag, stat){
  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
};
module.exports = cof;
},{"./$":23,"./$.wks":41}],7:[function(require,module,exports){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , safe     = require('./$.uid').safe
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , step     = require('./$.iter').step
  , $has     = $.has
  , set      = $.set
  , isObject = $.isObject
  , hide     = $.hide
  , isExtensible = Object.isExtensible || isObject
  , ID       = safe('id')
  , O1       = safe('O1')
  , LAST     = safe('last')
  , FIRST    = safe('first')
  , ITER     = safe('iter')
  , SIZE     = $.DESC ? safe('size') : 'size'
  , id       = 0;

function fastKey(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
}

function getEntry(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that[O1][index];
  // frozen object case
  for(entry = that[FIRST]; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      assert.inst(that, C, NAME);
      set(that, O1, $.create(null));
      set(that, SIZE, 0);
      set(that, LAST, undefined);
      set(that, FIRST, undefined);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that[FIRST] = that[LAST] = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that[O1][entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that[FIRST] == entry)that[FIRST] = next;
          if(that[LAST] == entry)that[LAST] = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments[1], 3)
          , entry;
        while(entry = entry ? entry.n : this[FIRST]){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if($.DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return assert.def(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that[O1][index] = entry;
    } return that;
  },
  getEntry: getEntry,
  // add .keys, .values, .entries, [@@iterator]
  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
  setIter: function(C, NAME, IS_MAP){
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
  }
};
},{"./$":23,"./$.assert":4,"./$.ctx":11,"./$.for-of":15,"./$.iter":22,"./$.iter-define":20,"./$.mix":25,"./$.uid":39}],8:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def')
  , forOf = require('./$.for-of');
module.exports = function(NAME){
  $def($def.P, NAME, {
    toJSON: function toJSON(){
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    }
  });
};
},{"./$.def":12,"./$.for-of":15}],9:[function(require,module,exports){
'use strict';
var $         = require('./$')
  , safe      = require('./$.uid').safe
  , assert    = require('./$.assert')
  , forOf     = require('./$.for-of')
  , $has      = $.has
  , isObject  = $.isObject
  , hide      = $.hide
  , isExtensible = Object.isExtensible || isObject
  , id        = 0
  , ID        = safe('id')
  , WEAK      = safe('weak')
  , LEAK      = safe('leak')
  , method    = require('./$.array-methods')
  , find      = method(5)
  , findIndex = method(6);
function findFrozen(store, key){
  return find(store.array, function(it){
    return it[0] === key;
  });
}
// fallback for frozen keys
function leakStore(that){
  return that[LEAK] || hide(that, LEAK, {
    array: [],
    get: function(key){
      var entry = findFrozen(this, key);
      if(entry)return entry[1];
    },
    has: function(key){
      return !!findFrozen(this, key);
    },
    set: function(key, value){
      var entry = findFrozen(this, key);
      if(entry)entry[1] = value;
      else this.array.push([key, value]);
    },
    'delete': function(key){
      var index = findIndex(this.array, function(it){
        return it[0] === key;
      });
      if(~index)this.array.splice(index, 1);
      return !!~index;
    }
  })[LEAK];
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      $.set(assert.inst(that, C, NAME), ID, id++);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this)['delete'](key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this).has(key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    if(!isExtensible(assert.obj(key))){
      leakStore(that).set(key, value);
    } else {
      $has(key, WEAK) || hide(key, WEAK, {});
      key[WEAK][that[ID]] = value;
    } return that;
  },
  leakStore: leakStore,
  WEAK: WEAK,
  ID: ID
};
},{"./$":23,"./$.array-methods":3,"./$.assert":4,"./$.for-of":15,"./$.mix":25,"./$.uid":39}],10:[function(require,module,exports){
'use strict';
var $     = require('./$')
  , $def  = require('./$.def')
  , BUGGY = require('./$.iter').BUGGY
  , forOf = require('./$.for-of')
  , species = require('./$.species')
  , assertInstance = require('./$.assert').inst;

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = $.g[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  function fixMethod(KEY){
    var fn = proto[KEY];
    require('./$.redef')(proto, KEY,
      KEY == 'delete' ? function(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'has' ? function has(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'get' ? function get(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
      : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  }
  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    var inst  = new C
      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
      , buggyZero;
    // wrap for init collections from iterable
    if(!require('./$.iter-detect')(function(iter){ new C(iter); })){ // eslint-disable-line no-new
      C = wrapper(function(target, iterable){
        assertInstance(target, C, NAME);
        var that = new Base;
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    IS_WEAK || inst.forEach(function(val, key){
      buggyZero = 1 / key === -Infinity;
    });
    // fix converting -0 key to +0
    if(buggyZero){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    // + fix .add & .set for chaining
    if(buggyZero || chain !== inst)fixMethod(ADDER);
  }

  require('./$.cof').set(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F * (C != Base), O);
  species(C);
  species($.core[NAME]); // for wrapper

  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);

  return C;
};
},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.for-of":15,"./$.iter":22,"./$.iter-detect":21,"./$.mix":25,"./$.redef":28,"./$.species":33}],11:[function(require,module,exports){
// Optional / simple context binding
var assertFunction = require('./$.assert').fn;
module.exports = function(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  } return function(/* ...args */){
      return fn.apply(that, arguments);
    };
};
},{"./$.assert":4}],12:[function(require,module,exports){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction
  , $redef     = require('./$.redef');
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
global.core = core;
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    if(type & $def.B && own)exp = ctx(out, global);
    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
    // extend global
    if(target && !own)$redef(target, key, out);
    // export
    if(exports[key] != out)$.hide(exports, key, exp);
    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;
  }
}
module.exports = $def;
},{"./$":23,"./$.redef":28}],13:[function(require,module,exports){
var $        = require('./$')
  , document = $.g.document
  , isObject = $.isObject
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$":23}],14:[function(require,module,exports){
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getDesc    = $.getDesc
    , getSymbols = $.getSymbols;
  if(getSymbols)$.each.call(getSymbols(it), function(key){
    if(getDesc(it, key).enumerable)keys.push(key);
  });
  return keys;
};
},{"./$":23}],15:[function(require,module,exports){
var ctx  = require('./$.ctx')
  , get  = require('./$.iter').get
  , call = require('./$.iter-call');
module.exports = function(iterable, entries, fn, that){
  var iterator = get(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done){
    if(call(iterator, f, step.value, entries) === false){
      return call.close(iterator);
    }
  }
};
},{"./$.ctx":11,"./$.iter":22,"./$.iter-call":19}],16:[function(require,module,exports){
module.exports = function($){
  $.FW   = true;
  $.path = $.g;
  return $;
};
},{}],17:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var $ = require('./$')
  , toString = {}.toString
  , getNames = $.getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

function getWindowNames(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
}

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames($.toObject(it));
};
},{"./$":23}],18:[function(require,module,exports){
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
};
},{}],19:[function(require,module,exports){
var assertObject = require('./$.assert').obj;
function close(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)assertObject(ret.call(iterator));
}
function call(iterator, fn, value, entries){
  try {
    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
  } catch(e){
    close(iterator);
    throw e;
  }
}
call.close = close;
module.exports = call;
},{"./$.assert":4}],20:[function(require,module,exports){
var $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , $               = require('./$')
  , cof             = require('./$.cof')
  , $iter           = require('./$.iter')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values'
  , Iterators       = $iter.Iterators;
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  $iter.create(Constructor, NAME, next);
  function createMethod(kind){
    function $$(that){
      return new Constructor(that, kind);
    }
    switch(kind){
      case KEYS: return function keys(){ return $$(this); };
      case VALUES: return function values(){ return $$(this); };
    } return function entries(){ return $$(this); };
  }
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = $.getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    cof.set(IteratorPrototype, TAG, true);
    // FF fix
    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
  }
  // Define iterator
  if($.FW || FORCE)$iter.set(proto, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = $.that;
  if(DEFAULT){
    methods = {
      keys:    IS_SET            ? _default : createMethod(KEYS),
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
  }
};
},{"./$":23,"./$.cof":6,"./$.def":12,"./$.iter":22,"./$.redef":28,"./$.wks":41}],21:[function(require,module,exports){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec){
  if(!SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":41}],22:[function(require,module,exports){
'use strict';
var $                 = require('./$')
  , cof               = require('./$.cof')
  , classof           = cof.classof
  , assert            = require('./$.assert')
  , assertObject      = assert.obj
  , SYMBOL_ITERATOR   = require('./$.wks')('iterator')
  , FF_ITERATOR       = '@@iterator'
  , Iterators         = require('./$.shared')('iterators')
  , IteratorPrototype = {};
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, $.that);
function setIterator(O, value){
  $.hide(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
}

module.exports = {
  // Safari has buggy iterators w/o `next`
  BUGGY: 'keys' in [] && !('next' in [].keys()),
  Iterators: Iterators,
  step: function(done, value){
    return {value: value, done: !!done};
  },
  is: function(it){
    var O      = Object(it)
      , Symbol = $.g.Symbol;
    return (Symbol && Symbol.iterator || FF_ITERATOR) in O
      || SYMBOL_ITERATOR in O
      || $.has(Iterators, classof(O));
  },
  get: function(it){
    var Symbol = $.g.Symbol
      , getIter;
    if(it != undefined){
      getIter = it[Symbol && Symbol.iterator || FF_ITERATOR]
        || it[SYMBOL_ITERATOR]
        || Iterators[classof(it)];
    }
    assert($.isFunction(getIter), it, ' is not iterable!');
    return assertObject(getIter.call(it));
  },
  set: setIterator,
  create: function(Constructor, NAME, next, proto){
    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
    cof.set(Constructor, NAME + ' Iterator');
  }
};
},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.shared":32,"./$.wks":41}],23:[function(require,module,exports){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value));
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  setDescs:   Object.defineProperties,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  assertDefined: assertDefined,
  // Dummy, fix for not array-like ES3 string in es5 module
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  each: [].forEach
});
/* eslint-disable no-undef */
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
},{"./$.fw":16}],24:[function(require,module,exports){
var $ = require('./$');
module.exports = function(object, el){
  var O      = $.toObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":23}],25:[function(require,module,exports){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
},{"./$.redef":28}],26:[function(require,module,exports){
var $            = require('./$')
  , assertObject = require('./$.assert').obj;
module.exports = function ownKeys(it){
  assertObject(it);
  var keys       = $.getNames(it)
    , getSymbols = $.getSymbols;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./$":23,"./$.assert":4}],27:[function(require,module,exports){
'use strict';
var $      = require('./$')
  , invoke = require('./$.invoke')
  , assertFunction = require('./$.assert').fn;
module.exports = function(/* ...pargs */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = $.path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !_length)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(_length > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./$":23,"./$.assert":4,"./$.invoke":18}],28:[function(require,module,exports){
var $   = require('./$')
  , tpl = String({}.hasOwnProperty)
  , SRC = require('./$.uid').safe('src')
  , _toString = Function.toString;

function $redef(O, key, val, safe){
  if($.isFunction(val)){
    var base = O[key];
    $.hide(val, SRC, base ? String(base) : tpl.replace(/hasOwnProperty/, String(key)));
    if(!('name' in val))val.name = key;
  }
  if(O === $.g){
    O[key] = val;
  } else {
    if(!safe)delete O[key];
    $.hide(O, key, val);
  }
}

// add fake Function#toString for correct work wrapped methods / constructors
// with methods similar to LoDash isNative
$redef(Function.prototype, 'toString', function toString(){
  return $.has(this, SRC) ? this[SRC] : _toString.call(this);
});

$.core.inspectSource = function(it){
  return _toString.call(it);
};

module.exports = $redef;
},{"./$":23,"./$.uid":39}],29:[function(require,module,exports){
'use strict';
module.exports = function(regExp, replace, isStatic){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  };
};
},{}],30:[function(require,module,exports){
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],31:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var $      = require('./$')
  , assert = require('./$.assert');
function check(O, proto){
  assert.obj(O);
  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
}
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
    ? function(buggy, set){
        try {
          set = require('./$.ctx')(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
          set({}, []);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }()
    : undefined),
  check: check
};
},{"./$":23,"./$.assert":4,"./$.ctx":11}],32:[function(require,module,exports){
var $      = require('./$')
  , SHARED = '__core-js_shared__'
  , store  = $.g[SHARED] || ($.g[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$":23}],33:[function(require,module,exports){
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: $.that
  });
};
},{"./$":23,"./$.wks":41}],34:[function(require,module,exports){
// true  -> String#at
// false -> String#codePointAt
var $ = require('./$');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String($.assertDefined(that))
      , i = $.toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$":23}],35:[function(require,module,exports){
// http://wiki.ecmascript.org/doku.php?id=strawman:string_padding
var $      = require('./$')
  , repeat = require('./$.string-repeat');

module.exports = function(that, minLength, fillChar, left){
  // 1. Let O be CheckObjectCoercible(this value).
  // 2. Let S be ToString(O).
  var S = String($.assertDefined(that));
  // 4. If intMinLength is undefined, return S.
  if(minLength === undefined)return S;
  // 4. Let intMinLength be ToInteger(minLength).
  var intMinLength = $.toInteger(minLength);
  // 5. Let fillLen be the number of characters in S minus intMinLength.
  var fillLen = intMinLength - S.length;
  // 6. If fillLen < 0, then throw a RangeError exception.
  // 7. If fillLen is +∞, then throw a RangeError exception.
  if(fillLen < 0 || fillLen === Infinity){
    throw new RangeError('Cannot satisfy string length ' + minLength + ' for string: ' + S);
  }
  // 8. Let sFillStr be the string represented by fillStr.
  // 9. If sFillStr is undefined, let sFillStr be a space character.
  var sFillStr = fillChar === undefined ? ' ' : String(fillChar);
  // 10. Let sFillVal be a String made of sFillStr, repeated until fillLen is met.
  var sFillVal = repeat.call(sFillStr, Math.ceil(fillLen / sFillStr.length));
  // truncate if we overflowed
  if(sFillVal.length > fillLen)sFillVal = left
    ? sFillVal.slice(sFillVal.length - fillLen)
    : sFillVal.slice(0, fillLen);
  // 11. Return a string made from sFillVal, followed by S.
  // 11. Return a String made from S, followed by sFillVal.
  return left ? sFillVal.concat(S) : S.concat(sFillVal);
};
},{"./$":23,"./$.string-repeat":36}],36:[function(require,module,exports){
'use strict';
var $ = require('./$');

module.exports = function repeat(count){
  var str = String($.assertDefined(this))
    , res = ''
    , n   = $.toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./$":23}],37:[function(require,module,exports){
'use strict';
var $      = require('./$')
  , ctx    = require('./$.ctx')
  , cof    = require('./$.cof')
  , invoke = require('./$.invoke')
  , cel    = require('./$.dom-create')
  , global             = $.g
  , isFunction         = $.isFunction
  , html               = $.html
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
function run(){
  var id = +this;
  if($.has(queue, id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
}
function listner(event){
  run.call(event.data);
}
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!isFunction(setTask) || !isFunction(clearTask)){
  setTask = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(cof(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(global.addEventListener && isFunction(global.postMessage) && !global.importScripts){
    defer = function(id){
      global.postMessage(id, '*');
    };
    global.addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$":23,"./$.cof":6,"./$.ctx":11,"./$.dom-create":13,"./$.invoke":18}],38:[function(require,module,exports){
module.exports = function(exec){
  try {
    exec();
    return false;
  } catch(e){
    return true;
  }
};
},{}],39:[function(require,module,exports){
var sid = 0;
function uid(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
}
uid.safe = require('./$').g.Symbol || uid;
module.exports = uid;
},{"./$":23}],40:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./$.wks')('unscopables');
if(!(UNSCOPABLES in []))require('./$').hide(Array.prototype, UNSCOPABLES, {});
module.exports = function(key){
  [][UNSCOPABLES][key] = true;
};
},{"./$":23,"./$.wks":41}],41:[function(require,module,exports){
var global = require('./$').g
  , store  = require('./$.shared')('wks');
module.exports = function(name){
  return store[name] || (store[name] =
    global.Symbol && global.Symbol[name] || require('./$.uid').safe('Symbol.' + name));
};
},{"./$":23,"./$.shared":32,"./$.uid":39}],42:[function(require,module,exports){
var $                = require('./$')
  , cel              = require('./$.dom-create')
  , cof              = require('./$.cof')
  , $def             = require('./$.def')
  , invoke           = require('./$.invoke')
  , arrayMethod      = require('./$.array-methods')
  , IE_PROTO         = require('./$.uid').safe('__proto__')
  , assert           = require('./$.assert')
  , assertObject     = assert.obj
  , ObjectProto      = Object.prototype
  , html             = $.html
  , A                = []
  , _slice           = A.slice
  , _join            = A.join
  , classof          = cof.classof
  , has              = $.has
  , defineProperty   = $.setDesc
  , getOwnDescriptor = $.getDesc
  , defineProperties = $.setDescs
  , isFunction       = $.isFunction
  , isObject         = $.isObject
  , toObject         = $.toObject
  , toLength         = $.toLength
  , toIndex          = $.toIndex
  , IE8_DOM_DEFINE   = false
  , $indexOf         = require('./$.array-includes')(false)
  , $forEach         = arrayMethod(0)
  , $map             = arrayMethod(1)
  , $filter          = arrayMethod(2)
  , $some            = arrayMethod(3)
  , $every           = arrayMethod(4);

if(!$.DESC){
  try {
    IE8_DOM_DEFINE = defineProperty(cel('div'), 'x',
      {get: function(){ return 8; }}
    ).x == 8;
  } catch(e){ /* empty */ }
  $.setDesc = function(O, P, Attributes){
    if(IE8_DOM_DEFINE)try {
      return defineProperty(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
    return O;
  };
  $.getDesc = function(O, P){
    if(IE8_DOM_DEFINE)try {
      return getOwnDescriptor(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
  };
  $.setDescs = defineProperties = function(O, Properties){
    assertObject(O);
    var keys   = $.getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
    return O;
  };
}
$def($def.S + $def.F * !$.DESC, 'Object', {
  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $.getDesc,
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  defineProperty: $.setDesc,
  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  defineProperties: defineProperties
});

  // IE 8- don't enum bug keys
var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
            'toLocaleString,toString,valueOf').split(',')
  // Additional keys for getOwnPropertyNames
  , keys2 = keys1.concat('length', 'prototype')
  , keysLen1 = keys1.length;

// Create object with `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = cel('iframe')
    , i      = keysLen1
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write('<script>document.F=Object</script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict.prototype[keys1[i]];
  return createDict();
};
function createGetKeys(names, length){
  return function(object){
    var O      = toObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(length > i)if(has(O, key = names[i++])){
      ~$indexOf(result, key) || result.push(key);
    }
    return result;
  };
}
function Empty(){}
$def($def.S, 'Object', {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  getPrototypeOf: $.getProto = $.getProto || function(O){
    O = Object(assert.def(O));
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(isFunction(O.constructor) && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  },
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  create: $.create = $.create || function(O, /*?*/Properties){
    var result;
    if(O !== null){
      Empty.prototype = assertObject(O);
      result = new Empty();
      Empty.prototype = null;
      // add "__proto__" for Object.getPrototypeOf shim
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : defineProperties(result, Properties);
  },
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
  seal: function seal(it){
    return it; // <- cap
  },
  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
  freeze: function freeze(it){
    return it; // <- cap
  },
  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
  preventExtensions: function preventExtensions(it){
    return it; // <- cap
  },
  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
  isSealed: function isSealed(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
  isFrozen: function isFrozen(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
  isExtensible: function isExtensible(it){
    return isObject(it); // <- cap
  }
});

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
$def($def.P, 'Function', {
  bind: function(that /*, args... */){
    var fn       = assert.fn(this)
      , partArgs = _slice.call(arguments, 1);
    function bound(/* args... */){
      var args   = partArgs.concat(_slice.call(arguments))
        , constr = this instanceof bound
        , ctx    = constr ? $.create(fn.prototype) : that
        , result = invoke(fn, args, ctx);
      return constr ? ctx : result;
    }
    if(fn.prototype)bound.prototype = fn.prototype;
    return bound;
  }
});

// Fix for not array-like ES3 string and DOM objects
if(!(0 in Object('z') && 'z'[0] == 'z')){
  $.ES5Object = function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
}

var buggySlice = true;
try {
  if(html)_slice.call(html);
  buggySlice = false;
} catch(e){ /* empty */ }

$def($def.P + $def.F * buggySlice, 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return _slice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
  join: function join(){
    return _join.apply($.ES5Object(this), arguments);
  }
});

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
$def($def.S, 'Array', {
  isArray: function(arg){
    return cof(arg) == 'Array';
  }
});
function createArrayReduce(isRight){
  return function(callbackfn, memo){
    assert.fn(callbackfn);
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = isRight ? length - 1 : 0
      , i      = isRight ? -1 : 1;
    if(arguments.length < 2)for(;;){
      if(index in O){
        memo = O[index];
        index += i;
        break;
      }
      index += i;
      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
    }
    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
      memo = callbackfn(memo, O[index], index, this);
    }
    return memo;
  };
}
$def($def.P, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: $.each = $.each || function forEach(callbackfn/*, that = undefined */){
    return $forEach(this, callbackfn, arguments[1]);
  },
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn/*, that = undefined */){
    return $map(this, callbackfn, arguments[1]);
  },
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn/*, that = undefined */){
    return $filter(this, callbackfn, arguments[1]);
  },
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn/*, that = undefined */){
    return $some(this, callbackfn, arguments[1]);
  },
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn/*, that = undefined */){
    return $every(this, callbackfn, arguments[1]);
  },
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: createArrayReduce(false),
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: createArrayReduce(true),
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(el /*, fromIndex = 0 */){
    return $indexOf(this, el, arguments[1]);
  },
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
    if(index < 0)index = toLength(length + index);
    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
    return -1;
  }
});

// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
$def($def.P, 'String', {trim: require('./$.replacer')(/^\s*([\s\S]*\S)?\s*$/, '$1')});

// 20.3.3.1 / 15.9.4.4 Date.now()
$def($def.S, 'Date', {now: function(){
  return +new Date;
}});

function lz(num){
  return num > 9 ? num : '0' + num;
}

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
// PhantomJS and old webkit had a broken Date implementation.
var date       = new Date(-5e13 - 1)
  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
      && require('./$.throws')(function(){ new Date(NaN).toISOString(); }));
$def($def.P + $def.F * brokenDate, 'Date', {toISOString: function(){
  if(!isFinite(this))throw RangeError('Invalid time value');
  var d = this
    , y = d.getUTCFullYear()
    , m = d.getUTCMilliseconds()
    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
}});

if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
  var tag = classof(it);
  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
};
},{"./$":23,"./$.array-includes":2,"./$.array-methods":3,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.dom-create":13,"./$.invoke":18,"./$.replacer":29,"./$.throws":38,"./$.uid":39}],43:[function(require,module,exports){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
    var O     = Object($.assertDefined(this))
      , len   = $.toLength(O.length)
      , to    = toIndex(target, len)
      , from  = toIndex(start, len)
      , end   = arguments[2]
      , fin   = end === undefined ? len : toIndex(end, len)
      , count = Math.min(fin - from, len - to)
      , inc   = 1;
    if(from < to && to < from + count){
      inc  = -1;
      from = from + count - 1;
      to   = to   + count - 1;
    }
    while(count-- > 0){
      if(from in O)O[to] = O[from];
      else delete O[to];
      to   += inc;
      from += inc;
    } return O;
  }
});
require('./$.unscope')('copyWithin');
},{"./$":23,"./$.def":12,"./$.unscope":40}],44:[function(require,module,exports){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  fill: function fill(value /*, start = 0, end = @length */){
    var O      = Object($.assertDefined(this))
      , length = $.toLength(O.length)
      , index  = toIndex(arguments[1], length)
      , end    = arguments[2]
      , endPos = end === undefined ? length : toIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
  }
});
require('./$.unscope')('fill');
},{"./$":23,"./$.def":12,"./$.unscope":40}],45:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var KEY    = 'findIndex'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(6);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
},{"./$.array-methods":3,"./$.def":12,"./$.unscope":40}],46:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var KEY    = 'find'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(5);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
},{"./$.array-methods":3,"./$.def":12,"./$.unscope":40}],47:[function(require,module,exports){
var $     = require('./$')
  , ctx   = require('./$.ctx')
  , $def  = require('./$.def')
  , $iter = require('./$.iter')
  , call  = require('./$.iter-call');
$def($def.S + $def.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = Object($.assertDefined(arrayLike))
      , mapfn   = arguments[1]
      , mapping = mapfn !== undefined
      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
      , index   = 0
      , length, result, step, iterator;
    if($iter.is(O)){
      iterator = $iter.get(O);
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result   = new (typeof this == 'function' ? this : Array);
      for(; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, f, [step.value, index], true) : step.value;
      }
    } else {
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
      for(; length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});
},{"./$":23,"./$.ctx":11,"./$.def":12,"./$.iter":22,"./$.iter-call":19,"./$.iter-detect":21}],48:[function(require,module,exports){
var $          = require('./$')
  , setUnscope = require('./$.unscope')
  , ITER       = require('./$.uid').safe('iter')
  , $iter      = require('./$.iter')
  , step       = $iter.step
  , Iterators  = $iter.Iterators;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , kind  = iter.k
    , index = iter.i++;
  if(!O || index >= O.length){
    iter.o = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
},{"./$":23,"./$.iter":22,"./$.iter-define":20,"./$.uid":39,"./$.unscope":40}],49:[function(require,module,exports){
var $def = require('./$.def');
$def($def.S, 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , length = arguments.length
      // strange IE quirks mode bug -> use typeof instead of isFunction
      , result = new (typeof this == 'function' ? this : Array)(length);
    while(length > index)result[index] = arguments[index++];
    result.length = length;
    return result;
  }
});
},{"./$.def":12}],50:[function(require,module,exports){
require('./$.species')(Array);
},{"./$.species":33}],51:[function(require,module,exports){
var $             = require('./$')
  , HAS_INSTANCE  = require('./$.wks')('hasInstance')
  , FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(!$.isFunction(this) || !$.isObject(O))return false;
  if(!$.isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = $.getProto(O))if(this.prototype === O)return true;
  return false;
}});
},{"./$":23,"./$.wks":41}],52:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , NAME = 'name'
  , setDesc = $.setDesc
  , FunctionProto = Function.prototype;
// 19.2.4.2 name
NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
  configurable: true,
  get: function(){
    var match = String(this).match(/^\s*function ([^ (]*)/)
      , name  = match ? match[1] : '';
    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
    return name;
  },
  set: function(value){
    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
  }
});
},{"./$":23}],53:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments[0]); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":10,"./$.collection-strong":7}],54:[function(require,module,exports){
var Infinity = 1 / 0
  , $def  = require('./$.def')
  , E     = Math.E
  , pow   = Math.pow
  , abs   = Math.abs
  , exp   = Math.exp
  , log   = Math.log
  , sqrt  = Math.sqrt
  , ceil  = Math.ceil
  , floor = Math.floor
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);
function roundTiesToEven(n){
  return n + 1 / EPSILON - 1 / EPSILON;
}

// 20.2.2.28 Math.sign(x)
function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
}
// 20.2.2.5 Math.asinh(x)
function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// 20.2.2.14 Math.expm1(x)
function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
}

$def($def.S, 'Math', {
  // 20.2.2.3 Math.acosh(x)
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
  },
  // 20.2.2.5 Math.asinh(x)
  asinh: asinh,
  // 20.2.2.7 Math.atanh(x)
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  },
  // 20.2.2.9 Math.cbrt(x)
  cbrt: function cbrt(x){
    return sign(x = +x) * pow(abs(x), 1 / 3);
  },
  // 20.2.2.11 Math.clz32(x)
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
  },
  // 20.2.2.12 Math.cosh(x)
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  },
  // 20.2.2.14 Math.expm1(x)
  expm1: expm1,
  // 20.2.2.16 Math.fround(x)
  fround: function fround(x){
    var $abs  = abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  },
  // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , len  = arguments.length
      , larg = 0
      , arg, div;
    while(i < len){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  },
  // 20.2.2.18 Math.imul(x, y)
  imul: function imul(x, y){
    var UInt16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UInt16 & xn
      , yl = UInt16 & yn;
    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
  },
  // 20.2.2.20 Math.log1p(x)
  log1p: function log1p(x){
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
  },
  // 20.2.2.21 Math.log10(x)
  log10: function log10(x){
    return log(x) / Math.LN10;
  },
  // 20.2.2.22 Math.log2(x)
  log2: function log2(x){
    return log(x) / Math.LN2;
  },
  // 20.2.2.28 Math.sign(x)
  sign: sign,
  // 20.2.2.30 Math.sinh(x)
  sinh: function sinh(x){
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  },
  // 20.2.2.33 Math.tanh(x)
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  },
  // 20.2.2.34 Math.trunc(x)
  trunc: function trunc(it){
    return (it > 0 ? floor : ceil)(it);
  }
});
},{"./$.def":12}],55:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , isObject   = $.isObject
  , isFunction = $.isFunction
  , NUMBER     = 'Number'
  , $Number    = $.g[NUMBER]
  , Base       = $Number
  , proto      = $Number.prototype;
function toPrimitive(it){
  var fn, val;
  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to number");
}
function toNumber(it){
  if(isObject(it))it = toPrimitive(it);
  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
    var binary = false;
    switch(it.charCodeAt(1)){
      case 66 : case 98  : binary = true;
      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
    }
  } return +it;
}
if($.FW && !($Number('0o1') && $Number('0b1'))){
  $Number = function Number(it){
    return this instanceof $Number ? new Base(toNumber(it)) : toNumber(it);
  };
  $.each.call($.DESC ? $.getNames(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), function(key){
      if($.has(Base, key) && !$.has($Number, key)){
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    }
  );
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./$.redef')($.g, NUMBER, $Number);
}
},{"./$":23,"./$.redef":28}],56:[function(require,module,exports){
var $     = require('./$')
  , $def  = require('./$.def')
  , abs   = Math.abs
  , floor = Math.floor
  , _isFinite = $.g.isFinite
  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
function isInteger(it){
  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
}
$def($def.S, 'Number', {
  // 20.1.2.1 Number.EPSILON
  EPSILON: Math.pow(2, -52),
  // 20.1.2.2 Number.isFinite(number)
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  },
  // 20.1.2.3 Number.isInteger(number)
  isInteger: isInteger,
  // 20.1.2.4 Number.isNaN(number)
  isNaN: function isNaN(number){
    return number != number;
  },
  // 20.1.2.5 Number.isSafeInteger(number)
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
  },
  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  // 20.1.2.10 Number.MIN_SAFE_INTEGER
  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
  // 20.1.2.12 Number.parseFloat(string)
  parseFloat: parseFloat,
  // 20.1.2.13 Number.parseInt(string, radix)
  parseInt: parseInt
});
},{"./$":23,"./$.def":12}],57:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
},{"./$.assign":5,"./$.def":12}],58:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $def = require('./$.def');
$def($def.S, 'Object', {
  is: require('./$.same')
});
},{"./$.def":12,"./$.same":30}],59:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.def":12,"./$.set-proto":31}],60:[function(require,module,exports){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
$.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' +
  'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(',')
, function(KEY, ID){
  var fn     = ($.core.Object || {})[KEY] || Object[KEY]
    , forced = 0
    , method = {};
  method[KEY] = ID == 0 ? function freeze(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 1 ? function seal(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 2 ? function preventExtensions(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 3 ? function isFrozen(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 4 ? function isSealed(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 5 ? function isExtensible(it){
    return isObject(it) ? fn(it) : false;
  } : ID == 6 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : ID == 7 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : ID == 8 ? function keys(it){
    return fn(toObject(it));
  } : require('./$.get-names').get;
  try {
    fn('z');
  } catch(e){
    forced = 1;
  }
  $def($def.S + $def.F * forced, 'Object', method);
});
},{"./$":23,"./$.def":12,"./$.get-names":17}],61:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , tmp = {};
tmp[require('./$.wks')('toStringTag')] = 'z';
if(require('./$').FW && cof(tmp) != 'z'){
  require('./$.redef')(Object.prototype, 'toString', function toString(){
    return '[object ' + cof.classof(this) + ']';
  }, true);
}
},{"./$":23,"./$.cof":6,"./$.redef":28,"./$.wks":41}],62:[function(require,module,exports){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , cof      = require('./$.cof')
  , $def     = require('./$.def')
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , setProto = require('./$.set-proto').set
  , same     = require('./$.same')
  , species  = require('./$.species')
  , SPECIES  = require('./$.wks')('species')
  , RECORD   = require('./$.uid').safe('record')
  , PROMISE  = 'Promise'
  , global   = $.g
  , process  = global.process
  , isNode   = cof(process) == 'process'
  , asap     = process && process.nextTick || require('./$.task').set
  , P        = global[PROMISE]
  , isFunction     = $.isFunction
  , isObject       = $.isObject
  , assertFunction = assert.fn
  , assertObject   = assert.obj
  , Wrapper;

function testResolve(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
}

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = isFunction(P) && isFunction(P.resolve) && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && $.DESC){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
function isPromise(it){
  return isObject(it) && (useNative ? cof.classof(it) == 'Promise' : RECORD in it);
}
function sameConstructor(a, b){
  // library wrapper special case
  if(!$.FW && a === P && b === Wrapper)return true;
  return same(a, b);
}
function getConstructor(C){
  var S = assertObject(C)[SPECIES];
  return S != undefined ? S : C;
}
function isThenable(it){
  var then;
  if(isObject(it))then = it.then;
  return isFunction(then) ? then : false;
}
function notify(record){
  var chain = record.c;
  // strange IE + webpack dev server bug - use .call(global)
  if(chain.length)asap.call(global, function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    function run(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    }
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
  });
}
function isUnhandled(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
}
function $reject(value){
  var record = this
    , promise;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  setTimeout(function(){
    // strange IE + webpack dev server bug - use .call(global)
    asap.call(global, function(){
      if(isUnhandled(promise = record.p)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(global.console && console.error){
          console.error('Unhandled promise rejection', value);
        }
      }
      record.a = undefined;
    });
  }, 1);
  notify(record);
}
function $resolve(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      // strange IE + webpack dev server bug - use .call(global)
      asap.call(global, function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
}

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    assertFunction(executor);
    var record = {
      p: assert.inst(this, P, PROMISE),       // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false                                // <- handled rejection
    };
    $.hide(this, RECORD, record);
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var S = assertObject(assertObject(this).constructor)[SPECIES];
      var react = {
        ok:   isFunction(onFulfilled) ? onFulfilled : true,
        fail: isFunction(onRejected)  ? onRejected  : false
      };
      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
        react.res = assertFunction(res);
        react.rej = assertFunction(rej);
      });
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
cof.set(P, PROMISE);
species(P);
species(Wrapper = $.core[PROMISE]);

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new (getConstructor(this))(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.ctx":11,"./$.def":12,"./$.for-of":15,"./$.iter-detect":21,"./$.mix":25,"./$.same":30,"./$.set-proto":31,"./$.species":33,"./$.task":37,"./$.uid":39,"./$.wks":41}],63:[function(require,module,exports){
var $         = require('./$')
  , $def      = require('./$.def')
  , setProto  = require('./$.set-proto')
  , $iter     = require('./$.iter')
  , ITERATOR  = require('./$.wks')('iterator')
  , ITER      = require('./$.uid').safe('iter')
  , step      = $iter.step
  , assert    = require('./$.assert')
  , isObject  = $.isObject
  , getProto  = $.getProto
  , $Reflect  = $.g.Reflect
  , _apply    = Function.apply
  , assertObject = assert.obj
  , _isExtensible = Object.isExtensible || isObject
  , _preventExtensions = Object.preventExtensions
  // IE TP has broken Reflect.enumerate
  , buggyEnumerate = !($Reflect && $Reflect.enumerate && ITERATOR in $Reflect.enumerate({}));

function Enumerate(iterated){
  $.set(this, ITER, {o: iterated, k: undefined, i: 0});
}
$iter.create(Enumerate, 'Object', function(){
  var iter = this[ITER]
    , keys = iter.k
    , key;
  if(keys == undefined){
    iter.k = keys = [];
    for(key in iter.o)keys.push(key);
  }
  do {
    if(iter.i >= keys.length)return step(1);
  } while(!((key = keys[iter.i++]) in iter.o));
  return step(0, key);
});

var reflect = {
  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
  apply: function apply(target, thisArgument, argumentsList){
    return _apply.call(target, thisArgument, argumentsList);
  },
  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
  construct: function construct(target, argumentsList /*, newTarget*/){
    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
      , instance = $.create(isObject(proto) ? proto : Object.prototype)
      , result   = _apply.call(target, instance, argumentsList);
    return isObject(result) ? result : instance;
  },
  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
  defineProperty: function defineProperty(target, propertyKey, attributes){
    assertObject(target);
    try {
      $.setDesc(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = $.getDesc(assertObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  },
  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
  get: function get(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = $.getDesc(assertObject(target), propertyKey), proto;
    if(desc)return $.has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getProto(target))
      ? get(proto, propertyKey, receiver)
      : undefined;
  },
  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return $.getDesc(assertObject(target), propertyKey);
  },
  // 26.1.8 Reflect.getPrototypeOf(target)
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(assertObject(target));
  },
  // 26.1.9 Reflect.has(target, propertyKey)
  has: function has(target, propertyKey){
    return propertyKey in target;
  },
  // 26.1.10 Reflect.isExtensible(target)
  isExtensible: function isExtensible(target){
    return _isExtensible(assertObject(target));
  },
  // 26.1.11 Reflect.ownKeys(target)
  ownKeys: require('./$.own-keys'),
  // 26.1.12 Reflect.preventExtensions(target)
  preventExtensions: function preventExtensions(target){
    assertObject(target);
    try {
      if(_preventExtensions)_preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
  set: function set(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = $.getDesc(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getProto(target))){
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = $.desc(0);
    }
    if($.has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || $.desc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
};
// 26.1.14 Reflect.setPrototypeOf(target, proto)
if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
  setProto.check(target, proto);
  try {
    setProto.set(target, proto);
    return true;
  } catch(e){
    return false;
  }
};

$def($def.G, {Reflect: {}});

$def($def.S + $def.F * buggyEnumerate, 'Reflect', {
  // 26.1.5 Reflect.enumerate(target)
  enumerate: function enumerate(target){
    return new Enumerate(assertObject(target));
  }
});

$def($def.S, 'Reflect', reflect);
},{"./$":23,"./$.assert":4,"./$.def":12,"./$.iter":22,"./$.own-keys":26,"./$.set-proto":31,"./$.uid":39,"./$.wks":41}],64:[function(require,module,exports){
var $       = require('./$')
  , cof     = require('./$.cof')
  , $RegExp = $.g.RegExp
  , Base    = $RegExp
  , proto   = $RegExp.prototype
  , re      = /a/g
  // "new" creates a new object
  , CORRECT_NEW = new $RegExp(re) !== re
  // RegExp allows a regex with flags as the pattern
  , ALLOWS_RE_WITH_FLAGS = function(){
    try {
      return $RegExp(re, 'i') == '/a/i';
    } catch(e){ /* empty */ }
  }();
if($.FW && $.DESC){
  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
    $RegExp = function RegExp(pattern, flags){
      var patternIsRegExp  = cof(pattern) == 'RegExp'
        , flagsIsUndefined = flags === undefined;
      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
      return CORRECT_NEW
        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
        : new Base(patternIsRegExp ? pattern.source : pattern
          , patternIsRegExp && flagsIsUndefined ? pattern.flags : flags);
    };
    $.each.call($.getNames(Base), function(key){
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function(){ return Base[key]; },
        set: function(it){ Base[key] = it; }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./$.redef')($.g, 'RegExp', $RegExp);
  }
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
    configurable: true,
    get: require('./$.replacer')(/^.*\/(\w*)$/, '$1')
  });
}
require('./$.species')($RegExp);
},{"./$":23,"./$.cof":6,"./$.redef":28,"./$.replacer":29,"./$.species":33}],65:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments[0]); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":10,"./$.collection-strong":7}],66:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(false);
$def($def.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./$.def":12,"./$.string-at":34}],67:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def')
  , toLength = $.toLength;

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.endsWith(/./); }), 'String', {
  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that = String($.assertDefined(this))
      , endPosition = arguments[1]
      , len = toLength(that.length)
      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    searchString += '';
    return that.slice(end - searchString.length, end) === searchString;
  }
});
},{"./$":23,"./$.cof":6,"./$.def":12,"./$.throws":38}],68:[function(require,module,exports){
var $def    = require('./$.def')
  , toIndex = require('./$').toIndex
  , fromCharCode = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res = []
      , len = arguments.length
      , i   = 0
      , code;
    while(len > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./$":23,"./$.def":12}],69:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
  includes: function includes(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
  }
});
},{"./$":23,"./$.cof":6,"./$.def":12}],70:[function(require,module,exports){
var set   = require('./$').set
  , $at   = require('./$.string-at')(true)
  , ITER  = require('./$.uid').safe('iter')
  , $iter = require('./$.iter')
  , step  = $iter.step;

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  set(this, ITER, {o: String(iterated), i: 0});
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , index = iter.i
    , point;
  if(index >= O.length)return step(1);
  point = $at(O, index);
  iter.i += point.length;
  return step(0, point);
});
},{"./$":23,"./$.iter":22,"./$.iter-define":20,"./$.string-at":34,"./$.uid":39}],71:[function(require,module,exports){
var $    = require('./$')
  , $def = require('./$.def');

$def($def.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl = $.toObject(callSite.raw)
      , len = $.toLength(tpl.length)
      , sln = arguments.length
      , res = []
      , i   = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < sln)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./$":23,"./$.def":12}],72:[function(require,module,exports){
var $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./$.string-repeat')
});
},{"./$.def":12,"./$.string-repeat":36}],73:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.startsWith(/./); }), 'String', {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  startsWith: function startsWith(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that  = String($.assertDefined(this))
      , index = $.toLength(Math.min(arguments[1], that.length));
    searchString += '';
    return that.slice(index, index + searchString.length) === searchString;
  }
});
},{"./$":23,"./$.cof":6,"./$.def":12,"./$.throws":38}],74:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $        = require('./$')
  , setTag   = require('./$.cof').set
  , uid      = require('./$.uid')
  , shared   = require('./$.shared')
  , $def     = require('./$.def')
  , $redef   = require('./$.redef')
  , keyOf    = require('./$.keyof')
  , enumKeys = require('./$.enum-keys')
  , assertObject = require('./$.assert').obj
  , ObjectProto = Object.prototype
  , DESC     = $.DESC
  , has      = $.has
  , $create  = $.create
  , getDesc  = $.getDesc
  , setDesc  = $.setDesc
  , desc     = $.desc
  , $names   = require('./$.get-names')
  , getNames = $names.get
  , toObject = $.toObject
  , $Symbol  = $.g.Symbol
  , setter   = false
  , TAG      = uid('tag')
  , HIDDEN   = uid('hidden')
  , _propertyIsEnumerable = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols = shared('symbols')
  , useNative = $.isFunction($Symbol);

var setSymbolDesc = DESC ? function(){ // fallback for old Android
  try {
    return $create(setDesc({}, HIDDEN, {
      get: function(){
        return setDesc(this, HIDDEN, {value: false})[HIDDEN];
      }
    }))[HIDDEN] || setDesc;
  } catch(e){
    return function(it, key, D){
      var protoDesc = getDesc(ObjectProto, key);
      if(protoDesc)delete ObjectProto[key];
      setDesc(it, key, D);
      if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
    };
  }
}() : setDesc;

function wrap(tag){
  var sym = AllSymbols[tag] = $.set($create($Symbol.prototype), TAG, tag);
  DESC && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, desc(1, value));
    }
  });
  return sym;
}

function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, desc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = $create(D, {enumerable: desc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
}
function defineProperties(it, P){
  assertObject(it);
  var keys = enumKeys(P = toObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)defineProperty(it, key = keys[i++], P[key]);
  return it;
}
function create(it, P){
  return P === undefined ? $create(it) : defineProperties($create(it), P);
}
function propertyIsEnumerable(key){
  var E = _propertyIsEnumerable.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
}
function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
}
function getOwnPropertyNames(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
}
function getOwnPropertySymbols(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
}

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments[0]));
  };
  $redef($Symbol.prototype, 'toString', function(){
    return this[TAG];
  });

  $.create     = create;
  $.setDesc    = defineProperty;
  $.getDesc    = getOwnPropertyDescriptor;
  $.setDescs   = defineProperties;
  $.getNames   = $names.get = getOwnPropertyNames;
  $.getSymbols = getOwnPropertySymbols;

  if($.DESC && $.FW)$redef(ObjectProto, 'propertyIsEnumerable', propertyIsEnumerable, true);
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
    'species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), function(it){
    var sym = require('./$.wks')(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  }
);

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: getOwnPropertySymbols
});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag($.g.JSON, 'JSON', true);
},{"./$":23,"./$.assert":4,"./$.cof":6,"./$.def":12,"./$.enum-keys":14,"./$.get-names":17,"./$.keyof":24,"./$.redef":28,"./$.shared":32,"./$.uid":39,"./$.wks":41}],75:[function(require,module,exports){
'use strict';
var $         = require('./$')
  , weak      = require('./$.collection-weak')
  , leakStore = weak.leakStore
  , ID        = weak.ID
  , WEAK      = weak.WEAK
  , has       = $.has
  , isObject  = $.isObject
  , isExtensible = Object.isExtensible || isObject
  , tmp       = {};

// 23.3 WeakMap Objects
var $WeakMap = require('./$.collection')('WeakMap', function(get){
  return function WeakMap(){ return get(this, arguments[0]); };
}, {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      if(!isExtensible(key))return leakStore(this).get(key);
      if(has(key, WEAK))return key[WEAK][this[ID]];
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
}, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  $.each.call(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    require('./$.redef')(proto, key, function(a, b){
      // store frozen objects on leaky map
      if(isObject(a) && !isExtensible(a)){
        var result = leakStore(this)[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./$":23,"./$.collection":10,"./$.collection-weak":9,"./$.redef":28}],76:[function(require,module,exports){
'use strict';
var weak = require('./$.collection-weak');

// 23.4 WeakSet Objects
require('./$.collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments[0]); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./$.collection":10,"./$.collection-weak":9}],77:[function(require,module,exports){
'use strict';
var $def      = require('./$.def')
  , $includes = require('./$.array-includes')(true);
$def($def.P, 'Array', {
  // https://github.com/domenic/Array.prototype.includes
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments[1]);
  }
});
require('./$.unscope')('includes');
},{"./$.array-includes":2,"./$.def":12,"./$.unscope":40}],78:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Map');
},{"./$.collection-to-json":8}],79:[function(require,module,exports){
// https://gist.github.com/WebReflection/9353781
var $       = require('./$')
  , $def    = require('./$.def')
  , ownKeys = require('./$.own-keys');

$def($def.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O      = $.toObject(object)
      , result = {};
    $.each.call(ownKeys(O), function(key){
      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
    });
    return result;
  }
});
},{"./$":23,"./$.def":12,"./$.own-keys":26}],80:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $    = require('./$')
  , $def = require('./$.def');
function createObjectToArray(isEntries){
  return function(object){
    var O      = $.toObject(object)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = Array(length)
      , key;
    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
    else while(length > i)result[i] = O[keys[i++]];
    return result;
  };
}
$def($def.S, 'Object', {
  values:  createObjectToArray(false),
  entries: createObjectToArray(true)
});
},{"./$":23,"./$.def":12}],81:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $def = require('./$.def');
$def($def.S, 'RegExp', {
  escape: require('./$.replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&', true)
});

},{"./$.def":12,"./$.replacer":29}],82:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Set');
},{"./$.collection-to-json":8}],83:[function(require,module,exports){
// https://github.com/mathiasbynens/String.prototype.at
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(true);
$def($def.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./$.def":12,"./$.string-at":34}],84:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  lpad: function lpad(n){
    return $pad(this, n, arguments[1], true);
  }
});
},{"./$.def":12,"./$.string-pad":35}],85:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  rpad: function rpad(n){
    return $pad(this, n, arguments[1], false);
  }
});
},{"./$.def":12,"./$.string-pad":35}],86:[function(require,module,exports){
// JavaScript 1.6 / Strawman array statics shim
var $       = require('./$')
  , $def    = require('./$.def')
  , $Array  = $.core.Array || Array
  , statics = {};
function setStatics(keys, length){
  $.each.call(keys.split(','), function(key){
    if(length == undefined && key in $Array)statics[key] = $Array[key];
    else if(key in [])statics[key] = require('./$.ctx')(Function.call, [][key], length);
  });
}
setStatics('pop,reverse,shift,keys,values,entries', 1);
setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
           'reduce,reduceRight,copyWithin,fill,turn');
$def($def.S, 'Array', statics);
},{"./$":23,"./$.ctx":11,"./$.def":12}],87:[function(require,module,exports){
require('./es6.array.iterator');
var $           = require('./$')
  , Iterators   = require('./$.iter').Iterators
  , ITERATOR    = require('./$.wks')('iterator')
  , ArrayValues = Iterators.Array
  , NL          = $.g.NodeList
  , HTC         = $.g.HTMLCollection
  , NLProto     = NL && NL.prototype
  , HTCProto    = HTC && HTC.prototype;
if($.FW){
  if(NL && !(ITERATOR in NLProto))$.hide(NLProto, ITERATOR, ArrayValues);
  if(HTC && !(ITERATOR in HTCProto))$.hide(HTCProto, ITERATOR, ArrayValues);
}
Iterators.NodeList = Iterators.HTMLCollection = ArrayValues;
},{"./$":23,"./$.iter":22,"./$.wks":41,"./es6.array.iterator":48}],88:[function(require,module,exports){
var $def  = require('./$.def')
  , $task = require('./$.task');
$def($def.G + $def.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./$.def":12,"./$.task":37}],89:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var $         = require('./$')
  , $def      = require('./$.def')
  , invoke    = require('./$.invoke')
  , partial   = require('./$.partial')
  , navigator = $.g.navigator
  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
function wrap(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      $.isFunction(fn) ? fn : Function(fn)
    ), time);
  } : set;
}
$def($def.G + $def.B + $def.F * MSIE, {
  setTimeout:  wrap($.g.setTimeout),
  setInterval: wrap($.g.setInterval)
});
},{"./$":23,"./$.def":12,"./$.invoke":18,"./$.partial":27}],90:[function(require,module,exports){
require('./modules/es5');
require('./modules/es6.symbol');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.object.statics-accept-primitives');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.number.constructor');
require('./modules/es6.number.statics');
require('./modules/es6.math');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.iterator');
require('./modules/es6.array.species');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.regexp');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.reflect');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.lpad');
require('./modules/es7.string.rpad');
require('./modules/es7.regexp.escape');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.to-array');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/js.array.statics');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/$').core;

},{"./modules/$":23,"./modules/es5":42,"./modules/es6.array.copy-within":43,"./modules/es6.array.fill":44,"./modules/es6.array.find":46,"./modules/es6.array.find-index":45,"./modules/es6.array.from":47,"./modules/es6.array.iterator":48,"./modules/es6.array.of":49,"./modules/es6.array.species":50,"./modules/es6.function.has-instance":51,"./modules/es6.function.name":52,"./modules/es6.map":53,"./modules/es6.math":54,"./modules/es6.number.constructor":55,"./modules/es6.number.statics":56,"./modules/es6.object.assign":57,"./modules/es6.object.is":58,"./modules/es6.object.set-prototype-of":59,"./modules/es6.object.statics-accept-primitives":60,"./modules/es6.object.to-string":61,"./modules/es6.promise":62,"./modules/es6.reflect":63,"./modules/es6.regexp":64,"./modules/es6.set":65,"./modules/es6.string.code-point-at":66,"./modules/es6.string.ends-with":67,"./modules/es6.string.from-code-point":68,"./modules/es6.string.includes":69,"./modules/es6.string.iterator":70,"./modules/es6.string.raw":71,"./modules/es6.string.repeat":72,"./modules/es6.string.starts-with":73,"./modules/es6.symbol":74,"./modules/es6.weak-map":75,"./modules/es6.weak-set":76,"./modules/es7.array.includes":77,"./modules/es7.map.to-json":78,"./modules/es7.object.get-own-property-descriptors":79,"./modules/es7.object.to-array":80,"./modules/es7.regexp.escape":81,"./modules/es7.set.to-json":82,"./modules/es7.string.at":83,"./modules/es7.string.lpad":84,"./modules/es7.string.rpad":85,"./modules/js.array.statics":86,"./modules/web.dom.iterable":87,"./modules/web.immediate":88,"./modules/web.timers":89}],91:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(
      innerFn, self || null,
      new Context(tryLocsList || [])
    );

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument
        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
        : Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            return result;
          });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(function() {
          return invoke(method, arg);
        }) : new Promise(function(resolve) {
          resolve(invoke(method, arg));
        });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator.
      previousPromise = enqueueResult["catch"](function(ignored){});

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":94}],92:[function(require,module,exports){
module.exports = require("./lib/polyfill");

},{"./lib/polyfill":1}],93:[function(require,module,exports){
module.exports = require("babel-core/polyfill");

},{"babel-core/polyfill":92}],94:[function(require,module,exports){
// shim for using process in browser

'use strict';

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utils = require('./utils');

var _asap = require('./asap');

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFullfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  (0, _asap.asap)(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      resolve(promise, value);
    }, function (reason) {
      reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable) {
  if (maybeThenable.constructor === promise.constructor) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    var then = getThen(maybeThenable);

    if (then === GET_THEN_ERROR) {
      reject(promise, GET_THEN_ERROR.error);
    } else if (then === undefined) {
      fulfill(promise, maybeThenable);
    } else if ((0, _utils.isFunction)(then)) {
      handleForeignThenable(promise, maybeThenable, then);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFullfillment());
  } else if ((0, _utils.objectOrFunction)(value)) {
    handleMaybeThenable(promise, value);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    (0, _asap.asap)(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  (0, _asap.asap)(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var subscribers = parent._subscribers;
  var length = subscribers.length;

  parent._onerror = null;

  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    (0, _asap.asap)(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child,
      callback,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = (0, _utils.isFunction)(callback),
      value,
      error,
      succeeded,
      failed;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

exports.noop = noop;
exports.resolve = resolve;
exports.reject = reject;
exports.fulfill = fulfill;
exports.subscribe = subscribe;
exports.publish = publish;
exports.publishRejection = publishRejection;
exports.initializePromise = initializePromise;
exports.invokeCallback = invokeCallback;
exports.FULFILLED = FULFILLED;
exports.REJECTED = REJECTED;
exports.PENDING = PENDING;

},{"./asap":96,"./utils":103}],96:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.setScheduler = setScheduler;
exports.setAsap = setAsap;
var len = 0;
var toString = ({}).toString;
var vertxNext;
var customSchedulerFn;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

exports.asap = asap;

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  exports.asap = asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  var nextTick = process.nextTick;
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // setImmediate should be used instead instead
  var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
  if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
    nextTick = setImmediate;
  }
  return function () {
    nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  return function () {
    vertxNext(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  return function () {
    setTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertex() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertex();
} else {
  scheduleFlush = useSetTimeout();
}

}).call(this,require('_process'))

},{"_process":94}],97:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utils = require('./utils');

var _internal = require('./-internal');

function Enumerator(Constructor, input) {
  var enumerator = this;

  enumerator._instanceConstructor = Constructor;
  enumerator.promise = new Constructor(_internal.noop);

  if (enumerator._validateInput(input)) {
    enumerator._input = input;
    enumerator.length = input.length;
    enumerator._remaining = input.length;

    enumerator._init();

    if (enumerator.length === 0) {
      (0, _internal.fulfill)(enumerator.promise, enumerator._result);
    } else {
      enumerator.length = enumerator.length || 0;
      enumerator._enumerate();
      if (enumerator._remaining === 0) {
        (0, _internal.fulfill)(enumerator.promise, enumerator._result);
      }
    }
  } else {
    (0, _internal.reject)(enumerator.promise, enumerator._validationError());
  }
}

Enumerator.prototype._validateInput = function (input) {
  return (0, _utils.isArray)(input);
};

Enumerator.prototype._validationError = function () {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._init = function () {
  this._result = new Array(this.length);
};

exports['default'] = Enumerator;

Enumerator.prototype._enumerate = function () {
  var enumerator = this;

  var length = enumerator.length;
  var promise = enumerator.promise;
  var input = enumerator._input;

  for (var i = 0; promise._state === _internal.PENDING && i < length; i++) {
    enumerator._eachEntry(input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var enumerator = this;
  var c = enumerator._instanceConstructor;

  if ((0, _utils.isMaybeThenable)(entry)) {
    if (entry.constructor === c && entry._state !== _internal.PENDING) {
      entry._onerror = null;
      enumerator._settledAt(entry._state, i, entry._result);
    } else {
      enumerator._willSettleAt(c.resolve(entry), i);
    }
  } else {
    enumerator._remaining--;
    enumerator._result[i] = entry;
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var enumerator = this;
  var promise = enumerator.promise;

  if (promise._state === _internal.PENDING) {
    enumerator._remaining--;

    if (state === _internal.REJECTED) {
      (0, _internal.reject)(promise, value);
    } else {
      enumerator._result[i] = value;
    }
  }

  if (enumerator._remaining === 0) {
    (0, _internal.fulfill)(promise, enumerator._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  (0, _internal.subscribe)(promise, undefined, function (value) {
    enumerator._settledAt(_internal.FULFILLED, i, value);
  }, function (reason) {
    enumerator._settledAt(_internal.REJECTED, i, reason);
  });
};
module.exports = exports['default'];

},{"./-internal":95,"./utils":103}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _internal = require('./-internal');

var _asap = require('./asap');

var _promiseAll = require('./promise/all');

var _promiseAll2 = _interopRequireDefault(_promiseAll);

var _promiseRace = require('./promise/race');

var _promiseRace2 = _interopRequireDefault(_promiseRace);

var _promiseResolve = require('./promise/resolve');

var _promiseResolve2 = _interopRequireDefault(_promiseResolve);

var _promiseReject = require('./promise/reject');

var _promiseReject2 = _interopRequireDefault(_promiseReject);

var counter = 0;

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

exports['default'] = Promise;

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  var promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      var xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this._id = counter++;
  this._state = undefined;
  this._result = undefined;
  this._subscribers = [];

  if (_internal.noop !== resolver) {
    if (!(0, _utils.isFunction)(resolver)) {
      needsResolver();
    }

    if (!(this instanceof Promise)) {
      needsNew();
    }

    (0, _internal.initializePromise)(this, resolver);
  }
}

Promise.all = _promiseAll2['default'];
Promise.race = _promiseRace2['default'];
Promise.resolve = _promiseResolve2['default'];
Promise.reject = _promiseReject2['default'];
Promise._setScheduler = _asap.setScheduler;
Promise._setAsap = _asap.setAsap;
Promise._asap = _asap.asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    var result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    var author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: function then(onFulfillment, onRejection) {
    var parent = this;
    var state = parent._state;

    if (state === _internal.FULFILLED && !onFulfillment || state === _internal.REJECTED && !onRejection) {
      return this;
    }

    var child = new this.constructor(_internal.noop);
    var result = parent._result;

    if (state) {
      var callback = arguments[state - 1];
      (0, _asap.asap)(function () {
        (0, _internal.invokeCallback)(state, child, callback, result);
      });
    } else {
      (0, _internal.subscribe)(parent, child, onFulfillment, onRejection);
    }

    return child;
  },

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};
module.exports = exports['default'];

},{"./-internal":95,"./asap":96,"./promise/all":99,"./promise/race":100,"./promise/reject":101,"./promise/resolve":102,"./utils":103}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = all;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _enumerator = require('../enumerator');

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  var promise1 = resolve(1);
  var promise2 = resolve(2);
  var promise3 = resolve(3);
  var promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  var promise1 = resolve(1);
  var promise2 = reject(new Error("2"));
  var promise3 = reject(new Error("3"));
  var promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/

var _enumerator2 = _interopRequireDefault(_enumerator);

function all(entries) {
  return new _enumerator2['default'](this, entries).promise;
}

module.exports = exports['default'];

},{"../enumerator":97}],100:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = race;

var _utils = require("../utils");

var _internal = require('../-internal');

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  var promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  var promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  var promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  var promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/

function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  var promise = new Constructor(_internal.noop);

  if (!(0, _utils.isArray)(entries)) {
    (0, _internal.reject)(promise, new TypeError('You must pass an array to race.'));
    return promise;
  }

  var length = entries.length;

  function onFulfillment(value) {
    (0, _internal.resolve)(promise, value);
  }

  function onRejection(reason) {
    (0, _internal.reject)(promise, reason);
  }

  for (var i = 0; promise._state === _internal.PENDING && i < length; i++) {
    (0, _internal.subscribe)(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
  }

  return promise;
}

module.exports = exports['default'];

},{"../-internal":95,"../utils":103}],101:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = reject;

var _internal = require('../-internal');

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  var promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  var promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/

function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(_internal.noop);
  (0, _internal.reject)(promise, reason);
  return promise;
}

module.exports = exports['default'];

},{"../-internal":95}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = resolve;

var _internal = require('../-internal');

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  var promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  var promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/

function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(_internal.noop);
  (0, _internal.resolve)(promise, object);
  return promise;
}

module.exports = exports['default'];

},{"../-internal":95}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.objectOrFunction = objectOrFunction;
exports.isFunction = isFunction;
exports.isMaybeThenable = isMaybeThenable;

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

function isMaybeThenable(x) {
  return typeof x === 'object' && x !== null;
}

var _isArray;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;
exports.isArray = isArray;

},{}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var ATTR_IGNORE = 'data-skate-ignore';
exports.ATTR_IGNORE = ATTR_IGNORE;
var TYPE_ATTRIBUTE = 'a';
exports.TYPE_ATTRIBUTE = TYPE_ATTRIBUTE;
var TYPE_CLASSNAME = 'c';
exports.TYPE_CLASSNAME = TYPE_CLASSNAME;
var TYPE_ELEMENT = 't';
exports.TYPE_ELEMENT = TYPE_ELEMENT;

},{}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

exports['default'] = function (element) {
  var namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});
  return namespace && (data[namespace] || (data[namespace] = {})) || data;
};

module.exports = exports['default'];

},{}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globals = require('./globals');

var _globals2 = _interopRequireDefault(_globals);

var _lifecycle = require('./lifecycle');

var _mutationObserver = require('./mutation-observer');

var _mutationObserver2 = _interopRequireDefault(_mutationObserver);

var _utils = require('./utils');

/**
 * The document observer handler.
 *
 * @param {Array} mutations The mutations to handle.
 *
 * @returns {undefined}
 */
function documentObserverHandler(mutations) {
  var mutationsLen = mutations.length;

  for (var a = 0; a < mutationsLen; a++) {
    var mutation = mutations[a];
    var addedNodes = mutation.addedNodes;
    var removedNodes = mutation.removedNodes;

    // Since siblings are batched together, we check the first node's parent
    // node to see if it is ignored. If it is then we don't process any added
    // nodes. This prevents having to check every node.
    if (addedNodes && addedNodes.length && !(0, _utils.getClosestIgnoredElement)(addedNodes[0].parentNode)) {
      (0, _lifecycle.initElements)(addedNodes);
    }

    // We can't check batched nodes here because they won't have a parent node.
    if (removedNodes && removedNodes.length) {
      (0, _lifecycle.removeElements)(removedNodes);
    }
  }
}

/**
 * Creates a new mutation observer for listening to Skate definitions for the
 * document.
 *
 * @param {Element} root The element to observe.
 *
 * @returns {MutationObserver}
 */
function createDocumentObserver() {
  var observer = new _mutationObserver2['default'](documentObserverHandler);

  // Observe after the DOM content has loaded.
  observer.observe(document, {
    childList: true,
    subtree: true
  });

  return observer;
}

exports['default'] = {
  register: function register(fixIe) {
    // IE has issues with reporting removedNodes correctly. See the polyfill for
    // details. If we fix IE, we must also re-define the document observer.
    if (fixIe) {
      _mutationObserver2['default'].fixIe();
      this.unregister();
    }

    if (!_globals2['default'].observer) {
      _globals2['default'].observer = createDocumentObserver();
    }

    return this;
  },

  unregister: function unregister() {
    if (_globals2['default'].observer) {
      _globals2['default'].observer.disconnect();
      _globals2['default'].observer = undefined;
    }

    return this;
  }
};
module.exports = exports['default'];

},{"./globals":107,"./lifecycle":108,"./mutation-observer":109,"./utils":112}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
if (!window.__skate) {
  window.__skate = {
    observer: undefined,
    registry: {}
  };
}

exports['default'] = window.__skate;
module.exports = exports['default'];

},{}],108:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _constants = require('./constants');

var _data = require('./data');

var _data2 = _interopRequireDefault(_data);

var _mutationObserver = require('./mutation-observer');

var _mutationObserver2 = _interopRequireDefault(_mutationObserver);

var _registry = require('./registry');

var _registry2 = _interopRequireDefault(_registry);

var _utils = require('./utils');

var elProto = window.HTMLElement.prototype;
var nativeMatchesSelector = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.oMatchesSelector;
// Only IE9 has this msMatchesSelector bug, but best to detect it.
var hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');
var matchesSelector = function matchesSelector(element, selector) {
  if (hasNativeMatchesSelectorDetattachedBug) {
    var clone = element.cloneNode();
    document.createElement('div').appendChild(clone);
    return nativeMatchesSelector.call(clone, selector);
  }
  return nativeMatchesSelector.call(element, selector);
};

/**
 * Parses an event definition and returns information about it.
 *
 * @param {String} e The event to parse.
 *
 * @returns {Object]}
 */
function parseEvent(e) {
  var parts = e.split(' ');
  return {
    name: parts.shift(),
    delegate: parts.join(' ')
  };
}

/**
 * Sets the defined attributes to their default values, if specified.
 *
 * @param {Element} target The web component element.
 * @param {Object} component The web component definition.
 *
 * @returns {undefined}
 */
function initAttributes(target, component) {
  var componentAttributes = component.attributes;

  if (typeof componentAttributes !== 'object') {
    return;
  }

  for (var attribute in componentAttributes) {
    if ((0, _utils.hasOwn)(componentAttributes, attribute) && (0, _utils.hasOwn)(componentAttributes[attribute], 'value') && !target.hasAttribute(attribute)) {
      var value = componentAttributes[attribute].value;
      value = typeof value === 'function' ? value(target) : value;
      target.setAttribute(attribute, value);
    }
  }
}

/**
 * Defines a property that proxies the specified attribute.
 *
 * @param {Element} target The web component element.
 * @param {String} attribute The attribute name to proxy.
 *
 * @returns {undefined}
 */
function defineAttributeProperty(target, attribute) {
  Object.defineProperty(target, (0, _utils.camelCase)(attribute), {
    get: function get() {
      return this.getAttribute(attribute);
    },
    set: function set(value) {
      if (value === undefined) {
        this.removeAttribute(attribute);
      } else {
        this.setAttribute(attribute, value);
      }
    }
  });
}

/**
 * Adds links from attributes to properties.
 *
 * @param {Element} target The web component element.
 * @param {Object} component The web component definition.
 *
 * @returns {undefined}
 */
function addAttributeToPropertyLinks(target, component) {
  var componentAttributes = component.attributes;

  if (typeof componentAttributes !== 'object') {
    return;
  }

  for (var attribute in componentAttributes) {
    if ((0, _utils.hasOwn)(componentAttributes, attribute) && !(0, _utils.hasOwn)(target, attribute)) {
      defineAttributeProperty(target, attribute);
    }
  }
}

function triggerAttributeChanged(target, component, data) {
  var callback;
  var type;
  var name = data.name;
  var newValue = data.newValue;
  var oldValue = data.oldValue;
  var newValueIsString = typeof newValue === 'string';
  var oldValueIsString = typeof oldValue === 'string';
  var attrs = component.attributes;
  var specific = attrs && attrs[name];

  if (!oldValueIsString && newValueIsString) {
    type = 'created';
  } else if (oldValueIsString && newValueIsString) {
    type = 'updated';
  } else if (oldValueIsString && !newValueIsString) {
    type = 'removed';
  }

  if (specific && typeof specific[type] === 'function') {
    callback = specific[type];
  } else if (specific && typeof specific.fallback === 'function') {
    callback = specific.fallback;
  } else if (typeof specific === 'function') {
    callback = specific;
  } else if (typeof attrs === 'function') {
    callback = attrs;
  }

  // Ensure values are null if undefined.
  newValue = newValue === undefined ? null : newValue;
  oldValue = oldValue === undefined ? null : oldValue;

  // There may still not be a callback.
  if (callback) {
    callback(target, {
      type: type,
      name: name,
      newValue: newValue,
      oldValue: oldValue
    });
  }
}

function triggerAttributesCreated(target, component) {
  var a;
  var attrs = target.attributes;
  var attrsCopy = [];
  var attrsLen = attrs.length;

  for (a = 0; a < attrsLen; a++) {
    attrsCopy.push(attrs[a]);
  }

  // In default web components, attribute changes aren't triggered for
  // attributes that already exist on an element when it is bound. This sucks
  // when you want to reuse and separate code for attributes away from your
  // lifecycle callbacks. Skate will initialise each attribute by calling the
  // created callback for the attributes that already exist on the element.
  for (a = 0; a < attrsLen; a++) {
    var attr = attrsCopy[a];
    triggerAttributeChanged(target, component, {
      name: attr.nodeName,
      newValue: attr.value || attr.nodeValue
    });
  }
}

function addAttributeListeners(target, component) {
  var attrs = target.attributes;

  if (!component.attributes || _registry2['default'].isNativeCustomElement(component.id)) {
    return;
  }

  var observer = new _mutationObserver2['default'](function (mutations) {
    mutations.forEach(function (mutation) {
      var name = mutation.attributeName;
      var attr = attrs[name];

      triggerAttributeChanged(target, component, {
        name: name,
        newValue: attr && (attr.value || attr.nodeValue),
        oldValue: mutation.oldValue
      });
    });
  });

  observer.observe(target, {
    attributes: true,
    attributeOldValue: true
  });
}

/**
 * Binds event listeners for the specified event handlers.
 *
 * @param {Element} target The component element.
 * @param {Object} component The component data.
 *
 * @returns {undefined}
 */
function addEventListeners(target, component) {
  if (typeof component.events !== 'object') {
    return;
  }

  function makeHandler(handler, delegate) {
    return function (e) {
      // If we're not delegating, trigger directly on the component element.
      if (!delegate) {
        return handler(target, e, target);
      }

      // If we're delegating, but the target doesn't match, then we've have
      // to go up the tree until we find a matching ancestor or stop at the
      // component element, or document. If a matching ancestor is found, the
      // handler is triggered on it.
      var current = e.target;

      while (current && current !== document && current !== target.parentNode) {
        if (matchesSelector(current, delegate)) {
          return handler(target, e, current);
        }

        current = current.parentNode;
      }
    };
  }

  (0, _utils.objEach)(component.events, function (handler, name) {
    var evt = parseEvent(name);
    var useCapture = !!evt.delegate && (evt.name === 'blur' || evt.name === 'focus');
    target.addEventListener(evt.name, makeHandler(handler, evt.delegate), useCapture);
  });
}

/**
 * Triggers the created lifecycle callback.
 *
 * @param {Element} target The component element.
 * @param {Object} component The component data.
 *
 * @returns {undefined}
 */
function triggerCreated(target, component) {
  var targetData = (0, _data2['default'])(target, component.id);

  if (targetData.created) {
    return;
  }

  targetData.created = true;

  // TODO: This doesn't need to happen if using native.
  (0, _utils.inherit)(target, component.prototype, true);

  // We use the unresolved / resolved attributes to flag whether or not the
  // element has been templated or not.
  if (component.template && !target.hasAttribute(component.resolvedAttribute)) {
    component.template(target);
  }

  target.removeAttribute(component.unresolvedAttribute);
  target.setAttribute(component.resolvedAttribute, '');
  addEventListeners(target, component);
  addAttributeListeners(target, component);
  addAttributeToPropertyLinks(target, component);
  initAttributes(target, component);
  triggerAttributesCreated(target, component);

  if (component.created) {
    component.created(target);
  }
}

/**
 * Triggers the attached lifecycle callback.
 *
 * @param {Element} target The component element.
 * @param {Object} component The component data.
 *
 * @returns {undefined}
 */
function triggerAttached(target, component) {
  var targetData = (0, _data2['default'])(target, component.id);

  if (targetData.attached) {
    return;
  }

  if (!(0, _utils.elementContains)(document, target)) {
    return;
  }

  targetData.attached = true;

  if (component.attached) {
    component.attached(target);
  }

  targetData.detached = false;
}

/**
 * Triggers the detached lifecycle callback.
 *
 * @param {Element} target The component element.
 * @param {Object} component The component data.
 *
 * @returns {undefined}
 */
function triggerDetached(target, component) {
  var targetData = (0, _data2['default'])(target, component.id);

  if (targetData.detached) {
    return;
  }

  targetData.detached = true;

  if (component.detached) {
    component.detached(target);
  }

  targetData.attached = false;
}

/**
 * Triggers the entire element lifecycle if it's not being ignored.
 *
 * @param {Element} target The component element.
 * @param {Object} component The component data.
 *
 * @returns {undefined}
 */
function triggerLifecycle(target, component) {
  triggerCreated(target, component);
  triggerAttached(target, component);
}

/**
 * Initialises a set of elements.
 *
 * @param {DOMNodeList | Array} elements A traversable set of elements.
 *
 * @returns {undefined}
 */
function initElements(elements) {
  var elementsLen = elements.length;

  for (var a = 0; a < elementsLen; a++) {
    var element = elements[a];

    if (element.nodeType !== 1 || element.attributes[_constants.ATTR_IGNORE]) {
      continue;
    }

    var currentNodeDefinitions = _registry2['default'].getForElement(element);
    var currentNodeDefinitionsLength = currentNodeDefinitions.length;

    for (var b = 0; b < currentNodeDefinitionsLength; b++) {
      triggerLifecycle(element, currentNodeDefinitions[b]);
    }

    // When <object> tag is used to expose NPAPI api to js may have different behaviour then other
    // tags. One of those differences is that it's childNodes can be undefined.
    var elementChildNodes = element.childNodes || [];
    var elementChildNodesLen = elementChildNodes.length;

    if (elementChildNodesLen) {
      initElements(elementChildNodes);
    }
  }
}

/**
 * Triggers the remove lifecycle callback on all of the elements.
 *
 * @param {DOMNodeList} elements The elements to trigger the remove lifecycle
 * callback on.
 *
 * @returns {undefined}
 */
function removeElements(elements) {
  var len = elements.length;

  for (var a = 0; a < len; a++) {
    var element = elements[a];

    if (element.nodeType !== 1) {
      continue;
    }

    removeElements(element.childNodes);

    var definitions = _registry2['default'].getForElement(element);
    var definitionsLen = definitions.length;

    for (var b = 0; b < definitionsLen; b++) {
      triggerDetached(element, definitions[b]);
    }
  }
}

exports.initElements = initElements;
exports.removeElements = removeElements;
exports.triggerAttached = triggerAttached;
exports.triggerAttributeChanged = triggerAttributeChanged;
exports.triggerCreated = triggerCreated;
exports.triggerDetached = triggerDetached;

},{"./constants":104,"./data":105,"./mutation-observer":109,"./registry":110,"./utils":112}],109:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utils = require('./utils');

var Attr = window.Attr;
var NativeMutationObserver = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver;
var isFixingIe = false;
var isIe = window.navigator.userAgent.indexOf('Trident') > -1;

/**
 * Creates a new mutation record.
 *
 * @param {Element} target The HTML element that was affected.
 * @param {String} type The type of mutation.
 *
 * @returns {Object}
 */
function newMutationRecord(target, type) {
  return {
    addedNodes: null,
    attributeName: null,
    attributeNamespace: null,
    nextSibling: null,
    oldValue: null,
    previousSibling: null,
    removedNodes: null,
    target: target,
    type: type || 'childList'
  };
}

/**
 * Takes an element and recursively saves it's tree structure on each element so
 * that they can be restored later after IE screws things up.
 *
 * @param {Node} node The node to save the tree for.
 *
 * @returns {undefined}
 */
function walkTree(node, cb) {
  var childNodes = node.childNodes;

  if (!childNodes) {
    return;
  }

  var childNodesLen = childNodes.length;

  for (var a = 0; a < childNodesLen; a++) {
    var childNode = childNodes[a];
    cb(childNode);
    walkTree(childNode, cb);
  }
}

// Mutation Observer "Polyfill"
// ----------------------------

/**
 * This "polyfill" only polyfills what we need for Skate to function. It
 * batches updates and does the bare minimum during synchronous operation
 * which make mutation event performance bearable. The rest is batched on the
 * next tick. Like mutation observers, each mutation is divided into sibling
 * groups for each parent that had mutations. All attribute mutations are
 * batched into separate records regardless of the element they occured on.
 *
 * @param {Function} callback The callback to execute with the mutation info.
 *
 * @returns {undefined}
 */
function MutationObserver(callback) {
  if (NativeMutationObserver && !isFixingIe) {
    return new NativeMutationObserver(callback);
  }

  this.callback = callback;
  this.elements = [];
}

/**
 * IE 11 has a bug that prevents descendant nodes from being reported as removed
 * to a mutation observer in IE 11 if an ancestor node's innerHTML is reset.
 * This same bug also happens when using Mutation Events in IE 9 / 10. Because of
 * this, we must ensure that observers and events get triggered properly on
 * those descendant nodes. In order to do this we have to override `innerHTML`
 * and then manually trigger an event.
 *
 * See: https://connect.microsoft.com/IE/feedback/details/817132/ie-11-childnodes-are-missing-from-mutationobserver-mutations-removednodes-after-setting-innerhtml
 *
 * @returns {undefined}
 */
MutationObserver.fixIe = function () {
  // Fix once only if we need to.
  if (!isIe || isFixingIe) {
    return;
  }

  // We have to call the old innerHTML getter and setter.
  var oldInnerHTML = Object.getOwnPropertyDescriptor(_utils.elementPrototype, 'innerHTML');

  // This redefines the innerHTML property so that we can ensure that events
  // are properly triggered.
  Object.defineProperty(_utils.elementPrototype, 'innerHTML', {
    get: function get() {
      return oldInnerHTML.get.call(this);
    },
    set: function set(html) {
      walkTree(this, function (node) {
        var mutationEvent = document.createEvent('MutationEvent');
        mutationEvent.initMutationEvent('DOMNodeRemoved', true, false, null, null, null, null, null);
        node.dispatchEvent(mutationEvent);
      });

      oldInnerHTML.set.call(this, html);
    }
  });

  // Flag so the polyfill is used for all subsequent Mutation Observer objects.
  isFixingIe = true;
};

Object.defineProperty(MutationObserver, 'isFixingIe', {
  get: function get() {
    return isFixingIe;
  }
});

MutationObserver.prototype = {
  observe: function observe(target, options) {
    function addEventToBatch(e) {
      batchedEvents.push(e);
      batchEvents();
    }

    function batchEvent(e) {
      var eTarget = e.target;

      // In some test environments, e.target has been nulled after the tests
      // are done and a batch is still processing.
      if (!eTarget) {
        return;
      }

      var eType = e.type;
      var eTargetParent = eTarget.parentNode;

      if (!canTriggerInsertOrRemove(eTargetParent)) {
        return;
      }

      // The same bug that affects IE 11 also affects IE 9 / 10 with Mutation
      // Events.
      //
      // IE 11 bug: https://connect.microsoft.com/IE/feedback/details/817132/ie-11-childnodes-are-missing-from-mutationobserver-mutations-removednodes-after-setting-innerhtml
      var shouldWorkAroundIeRemoveBug = isFixingIe && eType === 'DOMNodeRemoved';
      var isDescendant = lastBatchedElement && lastBatchedElement.nodeType === 1 && (0, _utils.elementContains)(lastBatchedElement, eTarget);

      // This checks to see if the element is contained in the last batched
      // element. If it is, then we don't batch it because elements are
      // batched into first-children of a given parent. However, IE is (of
      // course) an exception to this and destroys the DOM tree heirarchy
      // before the callback gets fired if the element was removed. Because of
      // this, we have to let through all descendants that had the event
      // triggered on it.
      if (!shouldWorkAroundIeRemoveBug && isDescendant) {
        return;
      }

      if (!lastBatchedRecord || lastBatchedRecord.target !== eTargetParent) {
        batchedRecords.push(lastBatchedRecord = newMutationRecord(eTargetParent));
      }

      if (eType === 'DOMNodeInserted') {
        if (!lastBatchedRecord.addedNodes) {
          lastBatchedRecord.addedNodes = [];
        }

        lastBatchedRecord.addedNodes.push(eTarget);
      } else {
        if (!lastBatchedRecord.removedNodes) {
          lastBatchedRecord.removedNodes = [];
        }

        lastBatchedRecord.removedNodes.push(eTarget);
      }

      lastBatchedElement = eTarget;
    }

    function canTriggerAttributeModification(eTarget) {
      return options.attributes && (options.subtree || eTarget === target);
    }

    function canTriggerInsertOrRemove(eTargetParent) {
      return options.childList && (options.subtree || eTargetParent === target);
    }

    var that = this;

    // Batching insert and remove.
    var lastBatchedElement;
    var lastBatchedRecord;
    var batchedEvents = [];
    var batchedRecords = [];
    var batchEvents = (0, _utils.debounce)(function () {
      var batchedEventsLen = batchedEvents.length;

      for (var a = 0; a < batchedEventsLen; a++) {
        batchEvent(batchedEvents[a]);
      }

      that.callback(batchedRecords);
      batchedEvents = [];
      batchedRecords = [];
      lastBatchedElement = undefined;
      lastBatchedRecord = undefined;
    });

    // Batching attributes.
    var attributeOldValueCache = {};
    var attributeMutations = [];
    var batchAttributeMods = (0, _utils.debounce)(function () {
      // We keep track of the old length just in case attributes are
      // modified within a handler.
      var len = attributeMutations.length;

      // Call the handler with the current modifications.
      that.callback(attributeMutations);

      // We remove only up to the current point just in case more
      // modifications were queued.
      attributeMutations.splice(0, len);
    });

    var observed = {
      target: target,
      options: options,
      insertHandler: addEventToBatch,
      removeHandler: addEventToBatch,
      attributeHandler: function attributeHandler(e) {
        var eTarget = e.target;

        if (!(e.relatedNode instanceof Attr)) {
          // IE10 fires two mutation events for attributes, one with the
          // target as the relatedNode, and one where it's the attribute.
          //
          // Re: relatedNode, "In the case of the DOMAttrModified event
          // it indicates the Attr node which was modified, added, or
          // removed." [1]
          //
          // [1]: https://msdn.microsoft.com/en-us/library/ff943606%28v=vs.85%29.aspx
          return;
        }

        if (!canTriggerAttributeModification(eTarget)) {
          return;
        }

        var eAttrName = e.attrName;
        var ePrevValue = e.prevValue;
        var eNewValue = e.newValue;
        var record = newMutationRecord(eTarget, 'attributes');
        record.attributeName = eAttrName;

        if (options.attributeOldValue) {
          record.oldValue = attributeOldValueCache[eAttrName] || ePrevValue || null;
        }

        attributeMutations.push(record);

        // We keep track of old values so that when IE incorrectly reports
        // the old value we can ensure it is actually correct.
        if (options.attributeOldValue) {
          attributeOldValueCache[eAttrName] = eNewValue;
        }

        batchAttributeMods();
      }
    };

    this.elements.push(observed);

    if (options.childList) {
      target.addEventListener('DOMNodeInserted', observed.insertHandler);
      target.addEventListener('DOMNodeRemoved', observed.removeHandler);
    }

    if (options.attributes) {
      target.addEventListener('DOMAttrModified', observed.attributeHandler);
    }

    return this;
  },

  disconnect: function disconnect() {
    (0, _utils.objEach)(this.elements, function (observed) {
      observed.target.removeEventListener('DOMNodeInserted', observed.insertHandler);
      observed.target.removeEventListener('DOMNodeRemoved', observed.removeHandler);
      observed.target.removeEventListener('DOMAttrModified', observed.attributeHandler);
    });

    this.elements = [];

    return this;
  }
};

exports['default'] = MutationObserver;
module.exports = exports['default'];

},{"./utils":112}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _constants = require('./constants');

var _globals = require('./globals');

var _globals2 = _interopRequireDefault(_globals);

var _utils = require('./utils');

/**
 * Returns the class list for the specified element.
 *
 * @param {Element} element The element to get the class list for.
 *
 * @returns {ClassList | Array}
 */
function getClassList(element) {
  var classList = element.classList;

  if (classList) {
    return classList;
  }

  var attrs = element.attributes;

  return attrs['class'] && attrs['class'].nodeValue.split(/\s+/) || [];
}

exports['default'] = {
  clear: function clear() {
    _globals2['default'].registry = {};
    return this;
  },

  get: function get(id) {
    return (0, _utils.hasOwn)(_globals2['default'].registry, id) && _globals2['default'].registry[id];
  },

  getForElement: function getForElement(element) {
    var attrs = element.attributes;
    var attrsLen = attrs.length;
    var definitions = [];
    var isAttr = attrs.is;
    var isAttrValue = isAttr && (isAttr.value || isAttr.nodeValue);

    // Using localName as fallback for edge cases when processing <object> tag that is used
    // as inteface to NPAPI plugin.
    var tag = (element.tagName || element.localName).toLowerCase();
    var isAttrOrTag = isAttrValue || tag;
    var definition;
    var tagToExtend;

    if (this.isType(isAttrOrTag, _constants.TYPE_ELEMENT)) {
      definition = _globals2['default'].registry[isAttrOrTag];
      tagToExtend = definition['extends'];

      if (isAttrValue) {
        if (tag === tagToExtend) {
          definitions.push(definition);
        }
      } else if (!tagToExtend) {
        definitions.push(definition);
      }
    }

    for (var a = 0; a < attrsLen; a++) {
      var attr = attrs[a].nodeName;

      if (this.isType(attr, _constants.TYPE_ATTRIBUTE)) {
        definition = _globals2['default'].registry[attr];
        tagToExtend = definition['extends'];

        if (!tagToExtend || tag === tagToExtend) {
          definitions.push(definition);
        }
      }
    }

    var classList = getClassList(element);
    var classListLen = classList.length;

    for (var b = 0; b < classListLen; b++) {
      var className = classList[b];

      if (this.isType(className, _constants.TYPE_CLASSNAME)) {
        definition = _globals2['default'].registry[className];
        tagToExtend = definition['extends'];

        if (!tagToExtend || tag === tagToExtend) {
          definitions.push(definition);
        }
      }
    }

    return definitions;
  },

  isType: function isType(id, type) {
    var def = this.get(id);
    return def && def.type === type;
  },

  isNativeCustomElement: function isNativeCustomElement(id) {
    return (0, _utils.supportsNativeCustomElements)() && this.isType(id, _constants.TYPE_ELEMENT) && (0, _utils.isValidNativeCustomElementName)(id);
  },

  set: function set(id, definition) {
    if ((0, _utils.hasOwn)(_globals2['default'].registry, id)) {
      throw new Error('A component definition of type "' + definition.type + '" with the ID of "' + id + '" already exists.');
    }

    _globals2['default'].registry[id] = definition;

    return this;
  }
};
module.exports = exports['default'];

},{"./constants":104,"./globals":107,"./utils":112}],111:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _constants = require('./constants');

var _documentObserver = require('./document-observer');

var _documentObserver2 = _interopRequireDefault(_documentObserver);

var _lifecycle = require('./lifecycle');

var _registry = require('./registry');

var _registry2 = _interopRequireDefault(_registry);

var _utils = require('./utils');

var _version = require('./version');

var _version2 = _interopRequireDefault(_version);

var HTMLElement = window.HTMLElement;

// IE <= 10 can fire "interactive" too early (#243).
var isOldIE = !!document.attachEvent; // attachEvent was removed in IE11.

function isReady() {
  if (isOldIE) {
    return document.readyState === 'complete';
  } else {
    return document.readyState === 'interactive' || document.readyState === 'complete';
  }
}

/**
 * Initialises all valid elements in the document. Ensures that it does not
 * happen more than once in the same execution, and that it happens after the DOM is ready.
 *
 * @returns {undefined}
 */
var initDocument = (0, _utils.debounce)(function () {
  var initialiseSkateElementsOnDomLoad = function initialiseSkateElementsOnDomLoad() {
    (0, _lifecycle.initElements)(document.documentElement.childNodes);
  };
  if (isReady()) {
    initialiseSkateElementsOnDomLoad();
  } else {
    if (isOldIE) {
      window.addEventListener('load', initialiseSkateElementsOnDomLoad);
    } else {
      document.addEventListener('DOMContentLoaded', initialiseSkateElementsOnDomLoad);
    }
  }
});

/**
 * Creates a constructor for the specified definition.
 *
 * @param {Object} definition The definition information to use for generating the constructor.
 *
 * @returns {Function} The element constructor.
 */
function makeElementConstructor(definition) {
  function CustomElement() {
    var element;
    var tagToExtend = definition['extends'];
    var definitionId = definition.id;

    if (tagToExtend) {
      element = document.createElement(tagToExtend);
      element.setAttribute('is', definitionId);
    } else {
      element = document.createElement(definitionId);
    }

    // Ensure the definition prototype is up to date with the element's
    // prototype. This ensures that overwriting the element prototype still
    // works.
    definition.prototype = CustomElement.prototype;

    // If they use the constructor we don't have to wait until it's attached.
    (0, _lifecycle.triggerCreated)(element, definition);

    return element;
  }

  // This allows modifications to the element prototype propagate to the
  // definition prototype.
  CustomElement.prototype = definition.prototype;

  return CustomElement;
}

// Public API
// ----------

/**
 * Creates a listener for the specified definition.
 *
 * @param {String} id The ID of the definition.
 * @param {Object | Function} definition The definition definition.
 *
 * @returns {Function} Constructor that returns a custom element.
 */
function skate(id, definition) {
  // Just in case the definition is shared, we duplicate it so that internal
  // modifications to the original aren't shared.
  definition = (0, _utils.inherit)({}, definition);
  definition = (0, _utils.inherit)(definition, skate.defaults);
  definition.id = id;

  _registry2['default'].set(id, definition);

  if (_registry2['default'].isNativeCustomElement(id)) {
    var elementPrototype = definition['extends'] ? document.createElement(definition['extends']).constructor.prototype : HTMLElement.prototype;

    if (!elementPrototype.isPrototypeOf(definition.prototype)) {
      definition.prototype = (0, _utils.inherit)(Object.create(elementPrototype), definition.prototype, true);
    }

    var options = {
      prototype: (0, _utils.inherit)(definition.prototype, {
        createdCallback: function createdCallback() {
          (0, _lifecycle.triggerCreated)(this, definition);
        },
        attachedCallback: function attachedCallback() {
          (0, _lifecycle.triggerAttached)(this, definition);
        },
        detachedCallback: function detachedCallback() {
          (0, _lifecycle.triggerDetached)(this, definition);
        },
        attributeChangedCallback: function attributeChangedCallback(name, oldValue, newValue) {
          (0, _lifecycle.triggerAttributeChanged)(this, definition, {
            name: name,
            oldValue: oldValue,
            newValue: newValue
          });
        }
      })
    };

    if (definition['extends']) {
      options['extends'] = definition['extends'];
    }

    return document.registerElement(id, options);
  }

  initDocument();
  _documentObserver2['default'].register(!!definition.detached);

  if (_registry2['default'].isType(id, _constants.TYPE_ELEMENT)) {
    return makeElementConstructor(definition);
  }
}

/**
 * Synchronously initialises the specified element or elements and descendants.
 *
 * @param {Mixed} nodes The node, or nodes to initialise. Can be anything:
 *                      jQuery, DOMNodeList, DOMNode, selector etc.
 *
 * @returns {skate}
 */
skate.init = function (nodes) {
  var nodesToUse = nodes;

  if (!nodes) {
    return nodes;
  }

  if (typeof nodes === 'string') {
    nodesToUse = nodes = document.querySelectorAll(nodes);
  } else if (nodes instanceof HTMLElement) {
    nodesToUse = [nodes];
  }

  (0, _lifecycle.initElements)(nodesToUse);

  return nodes;
};

// Restriction type constants.
skate.type = {
  ATTRIBUTE: _constants.TYPE_ATTRIBUTE,
  CLASSNAME: _constants.TYPE_CLASSNAME,
  ELEMENT: _constants.TYPE_ELEMENT
};

// Makes checking the version easy when debugging.
skate.version = _version2['default'];

/**
 * The default options for a definition.
 *
 * @var {Object}
 */
skate.defaults = {
  // Attribute lifecycle callback or callbacks.
  attributes: undefined,

  // The events to manage the binding and unbinding of during the definition's
  // lifecycle.
  events: undefined,

  // Restricts a particular definition to binding explicitly to an element with
  // a tag name that matches the specified value.
  'extends': undefined,

  // The ID of the definition. This is automatically set in the `skate()`
  // function.
  id: '',

  // Properties and methods to add to each element.
  prototype: {},

  // The attribute name to add after calling the created() callback.
  resolvedAttribute: 'resolved',

  // The template to replace the content of the element with.
  template: undefined,

  // The type of bindings to allow.
  type: _constants.TYPE_ELEMENT,

  // The attribute name to remove after calling the created() callback.
  unresolvedAttribute: 'unresolved'
};

// Exporting
// ---------

var previousSkate = window.skate;
skate.noConflict = function () {
  window.skate = previousSkate;
  return skate;
};

// Global
window.skate = skate;

// ES6
exports['default'] = skate;
module.exports = exports['default'];

},{"./constants":104,"./document-observer":106,"./lifecycle":108,"./registry":110,"./utils":112,"./version":113}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.hasOwn = hasOwn;
exports.camelCase = camelCase;
exports.elementContains = elementContains;
exports.debounce = debounce;
exports.getClosestIgnoredElement = getClosestIgnoredElement;
exports.inherit = inherit;
exports.objEach = objEach;
exports.supportsNativeCustomElements = supportsNativeCustomElements;
exports.isValidNativeCustomElementName = isValidNativeCustomElementName;

var _constants = require('./constants');

var DocumentFragment = window.DocumentFragment;
var elementPrototype = window.HTMLElement.prototype;
exports.elementPrototype = elementPrototype;
var elementPrototypeContains = elementPrototype.contains;

/**
 * Checks {}.hasOwnProperty in a safe way.
 *
 * @param {Object} obj The object the property is on.
 * @param {String} key The object key to check.
 *
 * @returns {Boolean}
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

/**
 * Camel-cases the specified string.
 *
 * @param {String} str The string to camel-case.
 *
 * @returns {String}
 */

function camelCase(str) {
  return str.split(/-/g).map(function (str, index) {
    return index === 0 ? str : str[0].toUpperCase() + str.substring(1);
  }).join('');
}

/**
 * Returns whether or not the source element contains the target element.
 * This is for browsers that don't support Element.prototype.contains on an
 * HTMLUnknownElement.
 *
 * @param {HTMLElement} source The source element.
 * @param {HTMLElement} target The target element.
 *
 * @returns {Boolean}
 */

function elementContains(source, target) {
  // The document element does not have the contains method in IE.
  if (source === document && !source.contains) {
    return document.head.contains(target) || document.body.contains(target);
  }

  return source.contains ? source.contains(target) : elementPrototypeContains.call(source, target);
}

/**
 * Returns a function that will prevent more than one call in a single clock
 * tick.
 *
 * @param {Function} fn The function to call.
 *
 * @returns {Function}
 */

function debounce(fn) {
  var called = false;

  return function () {
    if (!called) {
      called = true;
      setTimeout(function () {
        called = false;
        fn();
      }, 1);
    }
  };
}

/**
 * Returns whether or not the specified element has been selectively ignored.
 *
 * @param {Element} element The element to check and traverse up from.
 *
 * @returns {Boolean}
 */

function getClosestIgnoredElement(element) {
  var parent = element;

  while (parent && parent !== document && !(parent instanceof DocumentFragment)) {
    if (parent.hasAttribute(_constants.ATTR_IGNORE)) {
      return parent;
    }

    parent = parent.parentNode;
  }
}

/**
 * Merges the second argument into the first.
 *
 * @param {Object} child The object to merge into.
 * @param {Object} parent The object to merge from.
 * @param {Boolean} overwrite Whether or not to overwrite properties on the child.
 *
 * @returns {Object} Returns the child object.
 */

function inherit(child, parent, overwrite) {
  var names = Object.getOwnPropertyNames(parent);
  var namesLen = names.length;

  for (var a = 0; a < namesLen; a++) {
    var name = names[a];

    if (overwrite || child[name] === undefined) {
      var desc = Object.getOwnPropertyDescriptor(parent, name);
      var shouldDefineProps = desc.get || desc.set || !desc.writable || !desc.enumerable || !desc.configurable;

      if (shouldDefineProps) {
        Object.defineProperty(child, name, desc);
      } else {
        child[name] = parent[name];
      }
    }
  }

  return child;
}

/**
 * Traverses an object checking hasOwnProperty.
 *
 * @param {Object} obj The object to traverse.
 * @param {Function} fn The function to call for each item in the object.
 *
 * @returns {undefined}
 */

function objEach(obj, fn) {
  for (var a in obj) {
    if (hasOwn(obj, a)) {
      fn(obj[a], a);
    }
  }
}

function supportsNativeCustomElements() {
  return typeof document.registerElement === 'function';
}

function isValidNativeCustomElementName(name) {
  return name.indexOf('-') > 0;
}

},{"./constants":104}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = '0.13.7';
module.exports = exports['default'];

},{}],114:[function(require,module,exports){
/**
 * Высчитывает и заменяет AVT (attribute value templates) внутри строки:
 * "foo {position() + 1}" –> "foo 2"
 */
'use strict';

var xpath = require('xpath');
var stringStream = require('string-stream');
var utils = require('./utils');

module.exports = function (str, context) {
	return split(str).map(function (token) {
		if (token.type === 'string') {
			return token.value;
		}

		var result = xpath.select1(token.value, context);
		return result ? utils.stringify(result) : '';
	}).join('');
};

function split(data) {
	var out = [];
	var expr = function expr(e) {
		out.push({ type: 'expression', value: e });
	};
	var str = function str(s) {
		out.push({ type: 'string', value: s });
	};

	var stream = stringStream(data),
	    ch;
	while (!stream.eol()) {
		if (stream.next() === '{') {
			stream.backUp(1);
			str(stream.current());
			stream.start = stream.pos + 1;
			if (stream.skipToPair('{', '}', true)) {
				expr(stream.current(true));
				stream.start = stream.pos;
			} else {
				throw new Error('Invalid expression: ' + str);
			}
		}
	}
	str(stream.current());
	return out.filter(function (token) {
		return token.value;
	});
}

},{"./utils":125,"string-stream":129,"xpath":130}],115:[function(require,module,exports){
/**
 * Контекст трансформации дерева: захватывает текущий контекстный элемент
 * и предоставляет интерфейс для вывода данных
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var marked0$0 = [transform, defaultHandler].map(regeneratorRuntime.mark);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var debug = require('debug')('template:context');
var avt = require('../avt');
var Node = require('../dom/node');

module.exports = (function () {
	function AbstractContext(handlers) {
		_classCallCheck(this, AbstractContext);

		this._handlers = new Map();
		this._context = [];

		if (handlers) {
			Object.keys(handlers).forEach(function (nodeName) {
				this.registerHandler(nodeName, handlers[nodeName]);
			}, this);
		}
	}

	_createClass(AbstractContext, [{
		key: 'enter',
		value: function enter(elem) {
			this._context.push(elem);
			return elem;
		}
	}, {
		key: 'leave',
		value: function leave() {
			if (this._context.length > 1) {
				return this._context.pop();
			}
		}
	}, {
		key: 'evalAVT',
		value: function evalAVT(str, context) {
			return avt(str, context || this.context);
		}
	}, {
		key: 'registerHandler',
		value: function registerHandler(nodeName, gen) {
			this._handlers.set(nodeName, gen);
		}
	}, {
		key: 'getHandlerForNode',
		value: function getHandlerForNode(node, gen) {
			var handler;
			if (node.nodeType === Node.ELEMENT_NODE) {
				handler = this._handlers.get(node.nodeName);
			}
			return handler || this.constructor.defaultHandler;
		}
	}, {
		key: 'transform',
		value: (function (_transform) {
			function transform(_x) {
				return _transform.apply(this, arguments);
			}

			transform.toString = function () {
				return _transform.toString();
			};

			return transform;
		})(function (node) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = transform(node, this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var n = _step.value;

					debug('transforming %s', nodeStr(node));
					continue;
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		})
	}, {
		key: 'pushElement',
		value: function pushElement(name, attributes) {
			throw new Error('Not implemented');
		}
	}, {
		key: 'pushAttribute',
		value: function pushAttribute(name, value) {
			throw new Error('Not implemented');
		}
	}, {
		key: 'pushText',
		value: function pushText(value) {
			throw new Error('Not implemented');
		}
	}, {
		key: 'popElement',
		value: function popElement() {
			throw new Error('Not implemented');
		}
	}, {
		key: 'context',
		get: function get() {
			return this._context[this._context.length - 1];
		}
	}]);

	return AbstractContext;
})();

module.exports.defaultHandler = defaultHandler;

function transform(node, ctx) {
	var handler, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, next;

	return regeneratorRuntime.wrap(function transform$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				handler = ctx.getHandlerForNode(node);
				_iteratorNormalCompletion2 = true;
				_didIteratorError2 = false;
				_iteratorError2 = undefined;
				context$1$0.prev = 4;
				_iterator2 = handler(node, ctx)[Symbol.iterator]();

			case 6:
				if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
					context$1$0.next = 14;
					break;
				}

				next = _step2.value;
				context$1$0.next = 10;
				return next;

			case 10:
				return context$1$0.delegateYield(transform(next, ctx), 't0', 11);

			case 11:
				_iteratorNormalCompletion2 = true;
				context$1$0.next = 6;
				break;

			case 14:
				context$1$0.next = 20;
				break;

			case 16:
				context$1$0.prev = 16;
				context$1$0.t1 = context$1$0['catch'](4);
				_didIteratorError2 = true;
				_iteratorError2 = context$1$0.t1;

			case 20:
				context$1$0.prev = 20;
				context$1$0.prev = 21;

				if (!_iteratorNormalCompletion2 && _iterator2['return']) {
					_iterator2['return']();
				}

			case 23:
				context$1$0.prev = 23;

				if (!_didIteratorError2) {
					context$1$0.next = 26;
					break;
				}

				throw _iteratorError2;

			case 26:
				return context$1$0.finish(23);

			case 27:
				return context$1$0.finish(20);

			case 28:
			case 'end':
				return context$1$0.stop();
		}
	}, marked0$0[0], this, [[4, 16, 20, 28], [21,, 23, 27]]);
}

function defaultHandler(node, ctx) {
	var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, child, attrs, i, il, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4;

	return regeneratorRuntime.wrap(function defaultHandler$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				ctx = ctx || this;

				if (!(node.nodeType === Node.DOCUMENT_NODE)) {
					context$1$0.next = 30;
					break;
				}

				_iteratorNormalCompletion3 = true;
				_didIteratorError3 = false;
				_iteratorError3 = undefined;
				context$1$0.prev = 5;
				_iterator3 = node.childNodes[Symbol.iterator]();

			case 7:
				if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
					context$1$0.next = 14;
					break;
				}

				child = _step3.value;
				context$1$0.next = 11;
				return child;

			case 11:
				_iteratorNormalCompletion3 = true;
				context$1$0.next = 7;
				break;

			case 14:
				context$1$0.next = 20;
				break;

			case 16:
				context$1$0.prev = 16;
				context$1$0.t0 = context$1$0['catch'](5);
				_didIteratorError3 = true;
				_iteratorError3 = context$1$0.t0;

			case 20:
				context$1$0.prev = 20;
				context$1$0.prev = 21;

				if (!_iteratorNormalCompletion3 && _iterator3['return']) {
					_iterator3['return']();
				}

			case 23:
				context$1$0.prev = 23;

				if (!_didIteratorError3) {
					context$1$0.next = 26;
					break;
				}

				throw _iteratorError3;

			case 26:
				return context$1$0.finish(23);

			case 27:
				return context$1$0.finish(20);

			case 28:
				context$1$0.next = 64;
				break;

			case 30:
				if (!(node.nodeType === Node.ELEMENT_NODE)) {
					context$1$0.next = 63;
					break;
				}

				ctx.pushElement(node.nodeName);
				attrs = node.attributes;

				for (i = 0, il = attrs.length; i < il; i++) {
					ctx.pushAttribute(attrs[i].name, ctx.evalAVT(attrs[i].value));
				}
				_iteratorNormalCompletion4 = true;
				_didIteratorError4 = false;
				_iteratorError4 = undefined;
				context$1$0.prev = 37;
				_iterator4 = node.childNodes[Symbol.iterator]();

			case 39:
				if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
					context$1$0.next = 46;
					break;
				}

				child = _step4.value;
				context$1$0.next = 43;
				return child;

			case 43:
				_iteratorNormalCompletion4 = true;
				context$1$0.next = 39;
				break;

			case 46:
				context$1$0.next = 52;
				break;

			case 48:
				context$1$0.prev = 48;
				context$1$0.t1 = context$1$0['catch'](37);
				_didIteratorError4 = true;
				_iteratorError4 = context$1$0.t1;

			case 52:
				context$1$0.prev = 52;
				context$1$0.prev = 53;

				if (!_iteratorNormalCompletion4 && _iterator4['return']) {
					_iterator4['return']();
				}

			case 55:
				context$1$0.prev = 55;

				if (!_didIteratorError4) {
					context$1$0.next = 58;
					break;
				}

				throw _iteratorError4;

			case 58:
				return context$1$0.finish(55);

			case 59:
				return context$1$0.finish(52);

			case 60:
				ctx.popElement();
				context$1$0.next = 64;
				break;

			case 63:
				if (node.nodeType === Node.TEXT_NODE) {
					ctx.pushText(node.nodeValue);
				} else if (node.nodeType === Node.ATTRIBUTE_NODE) {
					ctx.pushAttribute(node);
				}

			case 64:
			case 'end':
				return context$1$0.stop();
		}
	}, marked0$0[1], this, [[5, 16, 20, 28], [21,, 23, 27], [37, 48, 52, 60], [53,, 55, 59]]);
}

function nodeStr(node) {
	switch (node.nodeType) {
		case Node.DOCUMENT_NODE:
			return '#document';
		case Node.TEXT_NODE:
			return '"' + node.nodeValue + '"';
		case Node.ELEMENT_NODE:
			return '<' + node.nodeName + '>';
		case Node.ATTRIBUTE_NODE:
			return '@' + node.name;
	}
}

},{"../avt":114,"../dom/node":122,"debug":126}],116:[function(require,module,exports){
/**
 * Вариация контекста преобразования для генерации DOM-дерева
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AbstractContext = require('./abstract');
var Document = require('../dom/document');
var utils = require('../utils');
var debug = require('debug')('template:dom-context');

module.exports = (function (_AbstractContext) {
	_inherits(DOMContext, _AbstractContext);

	function DOMContext(handlers) {
		_classCallCheck(this, DOMContext);

		_get(Object.getPrototypeOf(DOMContext.prototype), 'constructor', this).call(this, handlers);
		this.output = new Document();
		this.outputCtx = this.output;
		this._doc = this.output.ownerDocument;
	}

	_createClass(DOMContext, [{
		key: 'pushElement',
		value: function pushElement(name, attributes) {
			debug('push element %s', name);
			var elem = this._doc.createElement(name);
			this.outputCtx.appendChild(elem);
			this.outputCtx = elem;
			if (Array.isArray(attributes)) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var attr = _step.value;

						this.pushAttribute(attr.name, attr.value);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator['return']) {
							_iterator['return']();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			} else if (typeof attributes === 'object') {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = Object.keys(attributes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _name = _step2.value;

						this.pushAttribute(_name, attributes[_name]);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2['return']) {
							_iterator2['return']();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
		}
	}, {
		key: 'pushAttribute',
		value: function pushAttribute(name, value) {
			if (typeof name === 'object') {
				value = name.value;
				name = name.name;
			}

			debug('push attribute %s', name);
			this.outputCtx.setAttribute(name, value);
		}
	}, {
		key: 'pushText',
		value: function pushText(value) {
			debug('push text %s', value);
			var node = this._doc.createTextNode(utils.stringify(value));
			this.outputCtx.appendChild(node);
		}
	}, {
		key: 'popElement',
		value: function popElement() {
			debug('pop element');
			if (this.outputCtx.parentNode) {
				this.outputCtx = this.outputCtx.parentNode;
			}
		}
	}, {
		key: 'transform',
		value: function transform(node) {
			_get(Object.getPrototypeOf(DOMContext.prototype), 'transform', this).call(this, node);
			return this.output;
		}
	}]);

	return DOMContext;
})(AbstractContext);

},{"../dom/document":119,"../utils":125,"./abstract":115,"debug":126}],117:[function(require,module,exports){
/**
 * Контекст для преобразования дерева через декларативный шаблон
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var marked0$0 = [templateHandler, applyTemplateHandler].map(regeneratorRuntime.mark);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var xpath = require('xpath');
var extend = require('xtend');
var debug = require('debug')('template:template-ctx');
var DOMContext = require('./dom');
var Document = require('../dom/document');
var Node = require('../dom/node');

var defaultTemplate = {};
var defaultHandlers = extend(require('../handlers'), {
	'template': templateHandler,
	'apply-template': applyTemplateHandler
});

module.exports = (function (_DOMContext) {
	_inherits(TemplateContext, _DOMContext);

	function TemplateContext(templateDoc, handlers) {
		_classCallCheck(this, TemplateContext);

		_get(Object.getPrototypeOf(TemplateContext.prototype), 'constructor', this).call(this, extend(defaultHandlers, handlers || {}));
		// создаём карту шаблонов: из всех документов получаем имена
		// шаблонов и храним их в порядке добавления
		var templateMap = this._templateMap = new Map();
		var docs = Array.isArray(templateDoc) ? templateDoc : [templateDoc];
		docs.forEach(function (doc) {
			findTemplates(doc).forEach(function (template) {
				var name = template.getAttribute('name') || defaultTemplate;
				var list = templateMap.get(name);
				if (!list) {
					list = [template];
				} else {
					list.push(template);
				}
				templateMap.set(name, list);
			});
		});
	}

	_createClass(TemplateContext, [{
		key: 'getByName',
		value: function getByName(name) {
			var list = this._templateMap.get(name);
			return list ? list[list.length - 1] : null;
		}
	}, {
		key: 'transform',
		value: function transform(data) {
			var entryPoint = this._templateMap.get(defaultTemplate);
			if (!entryPoint) {
				throw new Error('No entry point (default template)');
			}
			this.enter(data);
			return _get(Object.getPrototypeOf(TemplateContext.prototype), 'transform', this).call(this, entryPoint[0]);
		}
	}]);

	return TemplateContext;
})(DOMContext);

function findTemplates(doc) {
	var root = doc.ownerDocument.documentElement;
	var out = [];
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = root.childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var child = _step.value;

			if (child.nodeName === 'template') {
				out.push(child);
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator['return']) {
				_iterator['return']();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return out;
}

/**
 * Обработка элемента <template>
 */
function templateHandler(node, ctx) {
	var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, child;

	return regeneratorRuntime.wrap(function templateHandler$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				_iteratorNormalCompletion2 = true;
				_didIteratorError2 = false;
				_iteratorError2 = undefined;
				context$1$0.prev = 3;
				_iterator2 = node.childNodes[Symbol.iterator]();

			case 5:
				if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
					context$1$0.next = 12;
					break;
				}

				child = _step2.value;
				context$1$0.next = 9;
				return child;

			case 9:
				_iteratorNormalCompletion2 = true;
				context$1$0.next = 5;
				break;

			case 12:
				context$1$0.next = 18;
				break;

			case 14:
				context$1$0.prev = 14;
				context$1$0.t0 = context$1$0['catch'](3);
				_didIteratorError2 = true;
				_iteratorError2 = context$1$0.t0;

			case 18:
				context$1$0.prev = 18;
				context$1$0.prev = 19;

				if (!_iteratorNormalCompletion2 && _iterator2['return']) {
					_iterator2['return']();
				}

			case 21:
				context$1$0.prev = 21;

				if (!_didIteratorError2) {
					context$1$0.next = 24;
					break;
				}

				throw _iteratorError2;

			case 24:
				return context$1$0.finish(21);

			case 25:
				return context$1$0.finish(18);

			case 26:
			case 'end':
				return context$1$0.stop();
		}
	}, marked0$0[0], this, [[3, 14, 18, 26], [19,, 21, 25]]);
}

/**
 * Обработка элемента <apply-template name="" select="">:
 * находим шаблон с указанным именем в списке зарегистрированных и, если есть
 * атрибут select, устанавливаем текущий контекст, равный результату 
 * этого выражения
 */
function applyTemplateHandler(node, ctx) {
	var tmplName, tmpl, ctxExpr, result, i, il;
	return regeneratorRuntime.wrap(function applyTemplateHandler$(context$1$0) {
		while (1) switch (context$1$0.prev = context$1$0.next) {
			case 0:
				debug('apply template');
				tmplName = node.getAttribute('name');

				if (tmplName) {
					context$1$0.next = 5;
					break;
				}

				debug('no template name, aborting');
				return context$1$0.abrupt('return');

			case 5:
				tmpl = ctx.getByName(tmplName);

				if (!tmpl) {
					debug('no template for name %s, aborting', tmplName);
				}

				ctxExpr = node.getAttribute('select');

				if (!ctxExpr) {
					context$1$0.next = 21;
					break;
				}

				result = xpath.select(ctxExpr, ctx.context);
				i = 0, il = result.length;

			case 11:
				if (!(i < il)) {
					context$1$0.next = 19;
					break;
				}

				ctx.enter(result[0]);
				context$1$0.next = 15;
				return tmpl;

			case 15:
				ctx.leave();

			case 16:
				i++;
				context$1$0.next = 11;
				break;

			case 19:
				context$1$0.next = 23;
				break;

			case 21:
				context$1$0.next = 23;
				return tmpl;

			case 23:
			case 'end':
				return context$1$0.stop();
		}
	}, marked0$0[1], this);
}

},{"../dom/document":119,"../dom/node":122,"../handlers":124,"./dom":116,"debug":126,"xpath":130,"xtend":131}],118:[function(require,module,exports){
/**
 * Класс для представления атрибута элемента
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Node = require('./node');

module.exports = (function (_Node) {
	_inherits(Attribute, _Node);

	function Attribute(name, value) {
		_classCallCheck(this, Attribute);

		if (!name) {
			throw new Error('Attribute name must be specified');
		}
		_get(Object.getPrototypeOf(Attribute.prototype), 'constructor', this).call(this, Node.ATTRIBUTE_NODE);

		this.nodeName = name;
		this.nodeValue = value;
		this.ownerElement = null;
	}

	_createClass(Attribute, [{
		key: 'ownerDocument',
		get: function get() {
			return ctx.ownerElement && ctx.ownerElement.ownerDocument;
		}
	}, {
		key: 'name',
		get: function get() {
			return this.nodeName;
		},
		set: function set(value) {
			return this.nodeName = value;
		}
	}, {
		key: 'value',
		get: function get() {
			return this.nodeValue;
		},
		set: function set(value) {
			return this.nodeValue = value;
		}
	}]);

	return Attribute;
})(Node);

},{"./node":122}],119:[function(require,module,exports){
/**
 * Класс для представляения корневого элемента дерева
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Node = require('./node');
var Element = require('./element');
var Text = require('./text');
var Attribute = require('./attribute');

module.exports = (function (_Node) {
	_inherits(Document, _Node);

	function Document() {
		_classCallCheck(this, Document);

		_get(Object.getPrototypeOf(Document.prototype), 'constructor', this).call(this, Node.DOCUMENT_NODE);
	}

	// createDocumentFragment()
	// createComment(data)
	// createCDATASection(data)
	// createProcessingInstruction(target, data)
	// createEntityReference(name)
	// importNode(importedNode, deep)

	_createClass(Document, [{
		key: 'createElement',
		value: function createElement(tagName) {
			return new Element(tagName);
		}
	}, {
		key: 'createTextNode',
		value: function createTextNode(data) {
			return new Text(data);
		}
	}, {
		key: 'createAttribute',
		value: function createAttribute(name) {
			return new Attribute(name);
		}
	}, {
		key: 'getElementsByTagName',
		value: function getElementsByTagName(name) {
			return Element.prototype.getElementsByTagName.call(this, name);
		}
	}, {
		key: 'getElementById',
		value: function getElementById(elementId) {
			throw new Error('Not implemented');
		}
	}, {
		key: 'ownerDocument',
		get: function get() {
			return this;
		}
	}, {
		key: 'documentElement',
		get: function get() {
			for (var i = 0, il = this._childNodes.length; i < il; i++) {
				if (this._childNodes[i].nodeType === Node.ELEMENT_NODE) {
					return this._childNodes[i];
				}
			}
		}
	}, {
		key: 'innerHTML',
		get: function get() {
			return this._childNodes.map(function (node) {
				return node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.outerHTML;
			}).join('');
		}
	}, {
		key: 'outerHTML',
		get: function get() {
			return this.innerHTML;
		}
	}]);

	return Document;
})(Node);

},{"./attribute":118,"./element":120,"./node":122,"./text":123}],120:[function(require,module,exports){
/**
 * Класс для представления узла элемента
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Node = require('./node');
var Attribute = require('./attribute');
var nodeList = require('./node-list');

module.exports = (function (_Node) {
	_inherits(Element, _Node);

	function Element(name) {
		_classCallCheck(this, Element);

		if (!name) {
			throw new Error('Element name must be specified');
		}

		_get(Object.getPrototypeOf(Element.prototype), 'constructor', this).call(this, Node.ELEMENT_NODE);
		this.nodeName = name;
	}

	_createClass(Element, [{
		key: 'getAttribute',
		value: function getAttribute(name) {
			var attr = this._attributes.get(name);
			return attr ? attr.value : void 0;
		}
	}, {
		key: 'setAttribute',
		value: function setAttribute(name, value) {
			if (name instanceof Attribute) {
				// replace attribute node
				return this.setAttributeNode(name);
			}

			var attr = this.getAttributeNode(name);
			if (!attr) {
				attr = new Attribute(name, value);
			} else {
				attr.value = value;
			}
			this.setAttributeNode(attr);
		}
	}, {
		key: 'removeAttribute',
		value: function removeAttribute(name) {
			this._attributes['delete'](name);
		}
	}, {
		key: 'removeAttributeNode',
		value: function removeAttributeNode(attr) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var item = _step.value;

					if (item[1] === attr) {
						this._attributes['delete'](item[0]);
						break;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}
	}, {
		key: 'hasAttribute',
		value: function hasAttribute(name) {
			return this._attributes.has(name);
		}
	}, {
		key: 'getAttributeNode',
		value: function getAttributeNode(name) {
			return this._attributes.get(name);
		}
	}, {
		key: 'setAttributeNode',
		value: function setAttributeNode(attr) {
			var prev = this._attributes.get(attr.name);
			if (prev && prev !== attr) {
				prev.remove();
			}
			this._attributes.set(attr.name, attr);
			attr.ownerElement = this;
		}
	}, {
		key: 'getElementsByTagName',
		value: function getElementsByTagName(name) {
			var out = nodeList();
			var all = name === '*';
			for (var i = 0, il = this._childNodes.length; i < il; i++) {
				var node = this._childNodes[i];
				if (node.nodeType === Node.ELEMENT_NODE) {
					if (all || node.nodeName === name) {
						out.push(node);
					}
					out = out.concat(node.getElementsByTagName(name));
				}
			}
			return out;
		}
	}, {
		key: 'tagName',
		get: function get() {
			return this.nodeName;
		}
	}, {
		key: 'innerHTML',
		get: function get() {
			return this._childNodes.map(stringify).join('');
		}
	}, {
		key: 'outerHTML',
		get: function get() {
			return stringify(this);
		}
	}]);

	return Element;
})(Node);

// Данные элементы не могут содержать контент следовательно не могут иметь закрываюший тег.
// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
var voidElementsList = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];

function stringify(node) {
	if (node.nodeType === Node.TEXT_NODE) {
		return node.nodeValue;
	}

	if (node.nodeType === Node.ELEMENT_NODE) {
		var attrs = node.attributes.map(function (attr) {
			return ' ' + attr.name + '="' + attr.value + '"';
		}).join('');
		var nodeName = node.nodeName;

		if (~voidElementsList.indexOf(nodeName)) {
			return '<' + nodeName + attrs + ' />';
		}
		return '<' + nodeName + attrs + '>' + node._childNodes.map(stringify).join('') + '</' + nodeName + '>';
	}

	throw new TypeError('Unknown element type: ' + node.nodeType);
};

},{"./attribute":118,"./node":122,"./node-list":121}],121:[function(require,module,exports){
'use strict';

'use srtict';

module.exports = function (arr) {
	arr = arr || [];
	arr.item = item;
	return arr;
};

function item(n) {
	return this[n];
}

},{}],122:[function(require,module,exports){
/**
 * Базовый класс для представляения узла в дереве
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var nodeList = require('./node-list');

var Node = module.exports = (function () {
	function _class(type) {
		_classCallCheck(this, _class);

		this.nodeType = type;
		this.nodeName = null;
		this.nodeValue = null;
		this.parentNode = null;
		this.nextSibling = null;
		this.previousSibling = null;

		this._childNodes = [];
		this._attributes = new Map();
	}

	_createClass(_class, [{
		key: 'appendChild',
		value: function appendChild(node) {
			return insertChildAt(this, node, 'last');
		}
	}, {
		key: 'insertBefore',
		value: function insertBefore(node, prev) {
			var ix = this._childNodes.indexOf(prev);
			if (ix !== -1) {
				insertChildAt(this, node, ix);
			}
			return node;
		}
	}, {
		key: 'removeChild',
		value: function removeChild(node) {
			var children = this._childNodes;
			var ix = children.indexOf(node);
			if (ix === -1) {
				return node;
			}

			var prev = children[ix - 1];
			var next = children[ix + 1];
			children.splice(ix, 1);

			if (prev) {
				prev.nextSibling = next;
			}

			if (next) {
				next.previousSibling = prev;
			}
		}
	}, {
		key: 'replaceChild',
		value: function replaceChild(newChild, oldChild) {
			var ix = this._childNodes.indexOf(oldChild);
			if (ix !== -1) {
				this.removeChild(oldChild);
				insertChildAt(this, newChild, ix);
			}
		}
	}, {
		key: 'normalize',
		value: function normalize() {
			throw new Error('Not implemented');
		}
	}, {
		key: 'cloneNode',
		value: function cloneNode(deep) {
			throw new Error('Not implemented');
		}
	}, {
		key: 'hasChildNodes',
		value: function hasChildNodes() {
			return !!this._childNodes.length;
		}
	}, {
		key: 'hasAttributes',
		value: function hasAttributes() {
			return !!this._attributes.size;
		}
	}, {
		key: 'childNodes',
		get: function get() {
			return this._childNodes.slice(0);
		}
	}, {
		key: 'firstChild',
		get: function get() {
			return this._childNodes[0];
		}
	}, {
		key: 'lastChild',
		get: function get() {
			return this._childNodes[this._childNodes.length - 1];
		}
	}, {
		key: 'attributes',
		get: function get() {
			var out = nodeList();
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._attributes.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var attr = _step.value;

					out.push(attr);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return out;
		}
	}, {
		key: 'ownerDocument',
		get: function get() {
			return this.parentNode && this.parentNode.ownerDocument;
		}
	}, {
		key: 'localName',
		get: function get() {
			return this.nodeName;
		}
	}]);

	return _class;
})();

Node.ELEMENT_NODE = 1;
Node.ATTRIBUTE_NODE = 2;
Node.TEXT_NODE = 3;
Node.CDATA_SECTION_NODE = 4;
Node.ENTITY_REFERENCE_NODE = 5;
Node.ENTITY_NODE = 6;
Node.PROCESSING_INSTRUCTION_NODE = 7;
Node.COMMENT_NODE = 8;
Node.DOCUMENT_NODE = 9;
Node.DOCUMENT_TYPE_NODE = 10;
Node.DOCUMENT_FRAGMENT_NODE = 11;

function insertChildAt(parent, child, pos) {
	// remove child from previous parent
	if (child.parentNode) {
		child.parentNode.removeChild(child);
	}

	var children = parent._childNodes;
	if (pos === 'last') {
		pos = children.length;
	} else if (pos === 'first') {
		pos = 0;
	}

	pos = Math.min(Math.max(0, pos), children.length);
	var prev = children[pos - 1];
	var next = children[pos + 1];

	children.splice(pos, 0, child);
	child.parentNode = parent;
	child.previousSibling = prev;
	child.nextSibling = next;

	if (prev) {
		prev.nextSibling = child;
	}

	if (next) {
		next.previousSibling = child;
	}

	return child;
}

},{"./node-list":121}],123:[function(require,module,exports){
/**
 * Класс для представления текстового узла
 */
'use strict';

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Node = require('./node');

module.exports = (function (_Node) {
	_inherits(Text, _Node);

	function Text(value) {
		_classCallCheck(this, Text);

		_get(Object.getPrototypeOf(Text.prototype), 'constructor', this).call(this, Node.TEXT_NODE);
		this.nodeValue = value || '';
	}

	return Text;
})(Node);

},{"./node":122}],124:[function(require,module,exports){
/**
 * Стандартные хэндлеры для элементов шаблона
 */
'use strict';

var xpath = require('xpath');
var utils = require('./utils');
var Node = require('./dom/node');

module.exports = {
	/**
  * Обработка <attribute name="" value=""/>:
  * добавляет атрибут контекстному сгенерированному элементу
  */
	'attribute': regeneratorRuntime.mark(function attribute(node, ctx) {
		var value, parent, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, child;

		return regeneratorRuntime.wrap(function attribute$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					value = '';

					if (!node.hasAttribute('value')) {
						context$1$0.next = 5;
						break;
					}

					value = node.getAttribute('value');
					context$1$0.next = 35;
					break;

				case 5:
					parent = ctx.outputCtx;

					ctx.outputCtx = parent.ownerDocument.createElement('span');
					_iteratorNormalCompletion = true;
					_didIteratorError = false;
					_iteratorError = undefined;
					context$1$0.prev = 10;
					_iterator = node.childNodes[Symbol.iterator]();

				case 12:
					if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
						context$1$0.next = 19;
						break;
					}

					child = _step.value;
					context$1$0.next = 16;
					return child;

				case 16:
					_iteratorNormalCompletion = true;
					context$1$0.next = 12;
					break;

				case 19:
					context$1$0.next = 25;
					break;

				case 21:
					context$1$0.prev = 21;
					context$1$0.t0 = context$1$0['catch'](10);
					_didIteratorError = true;
					_iteratorError = context$1$0.t0;

				case 25:
					context$1$0.prev = 25;
					context$1$0.prev = 26;

					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}

				case 28:
					context$1$0.prev = 28;

					if (!_didIteratorError) {
						context$1$0.next = 31;
						break;
					}

					throw _iteratorError;

				case 31:
					return context$1$0.finish(28);

				case 32:
					return context$1$0.finish(25);

				case 33:
					value = utils.innerText(ctx.outputCtx);
					ctx.outputCtx = parent;

				case 35:
					ctx.pushAttribute(node.getAttribute('name'), value);

				case 36:
				case 'end':
					return context$1$0.stop();
			}
		}, attribute, this, [[10, 21, 25, 33], [26,, 28, 32]]);
	}),

	/**
  * Обработка <value-of select="..."/>:
  * по xpath-запросу из атрибута select достаёт результат и, если он есть,
  * выводит его текстовое содержимое
  */
	'value-of': regeneratorRuntime.mark(function valueOf(node, ctx) {
		var expr, result;
		return regeneratorRuntime.wrap(function valueOf$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					expr = node.getAttribute('select');

					if (expr) {
						result = xpath.select1(expr, ctx.context);

						if (result != null) {
							ctx.pushText(result);
						}
					}

				case 2:
				case 'end':
					return context$1$0.stop();
			}
		}, valueOf, this);
	}),

	/**
  * Обработка <copy-of select="..."/>:
  * по xpath-запросу из атрибута select достаёт результат и, если он есть,
  * копирует его содержимое
  */
	'copy-of': regeneratorRuntime.mark(function copyOf(node, ctx) {
		var expr, result, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, child;

		return regeneratorRuntime.wrap(function copyOf$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					expr = node.getAttribute('select');

					if (!expr) {
						context$1$0.next = 22;
						break;
					}

					result = xpath.select(expr, ctx.context);
					_iteratorNormalCompletion2 = true;
					_didIteratorError2 = false;
					_iteratorError2 = undefined;
					context$1$0.prev = 6;

					for (_iterator2 = result[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						child = _step2.value;

						copyNode(child, ctx);
					}
					context$1$0.next = 14;
					break;

				case 10:
					context$1$0.prev = 10;
					context$1$0.t0 = context$1$0['catch'](6);
					_didIteratorError2 = true;
					_iteratorError2 = context$1$0.t0;

				case 14:
					context$1$0.prev = 14;
					context$1$0.prev = 15;

					if (!_iteratorNormalCompletion2 && _iterator2['return']) {
						_iterator2['return']();
					}

				case 17:
					context$1$0.prev = 17;

					if (!_didIteratorError2) {
						context$1$0.next = 20;
						break;
					}

					throw _iteratorError2;

				case 20:
					return context$1$0.finish(17);

				case 21:
					return context$1$0.finish(14);

				case 22:
				case 'end':
					return context$1$0.stop();
			}
		}, copyOf, this, [[6, 10, 14, 22], [15,, 17, 21]]);
	}),

	/**
  * Обработка <if test="..."/>:
  * по xpath-запросу из атрибута test достаёт результат и приводит его к Boolean, 
  * если результат положительный, то выполняет вложенный шаблон.
  */
	'if': regeneratorRuntime.mark(function _if(node, ctx) {
		var expr, result, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, child;

		return regeneratorRuntime.wrap(function _if$(context$1$0) {
			while (1) switch (context$1$0.prev = context$1$0.next) {
				case 0:
					expr = node.getAttribute('test');

					if (!expr) {
						context$1$0.next = 30;
						break;
					}

					result = xpath.select(expr, ctx.context);

					if (!(Array.isArray(result) ? result.filter(Boolean).length : result)) {
						context$1$0.next = 30;
						break;
					}

					_iteratorNormalCompletion3 = true;
					_didIteratorError3 = false;
					_iteratorError3 = undefined;
					context$1$0.prev = 7;
					_iterator3 = node.childNodes[Symbol.iterator]();

				case 9:
					if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
						context$1$0.next = 16;
						break;
					}

					child = _step3.value;
					context$1$0.next = 13;
					return child;

				case 13:
					_iteratorNormalCompletion3 = true;
					context$1$0.next = 9;
					break;

				case 16:
					context$1$0.next = 22;
					break;

				case 18:
					context$1$0.prev = 18;
					context$1$0.t0 = context$1$0['catch'](7);
					_didIteratorError3 = true;
					_iteratorError3 = context$1$0.t0;

				case 22:
					context$1$0.prev = 22;
					context$1$0.prev = 23;

					if (!_iteratorNormalCompletion3 && _iterator3['return']) {
						_iterator3['return']();
					}

				case 25:
					context$1$0.prev = 25;

					if (!_didIteratorError3) {
						context$1$0.next = 28;
						break;
					}

					throw _iteratorError3;

				case 28:
					return context$1$0.finish(25);

				case 29:
					return context$1$0.finish(22);

				case 30:
				case 'end':
					return context$1$0.stop();
			}
		}, _if, this, [[7, 18, 22, 30], [23,, 25, 29]]);
	})
};

function copyNode(node, ctx) {
	if (node.nodeType === Node.ELEMENT_NODE) {
		ctx.pushElement(node.nodeName, node.attributes);
		var _iteratorNormalCompletion4 = true;
		var _didIteratorError4 = false;
		var _iteratorError4 = undefined;

		try {
			for (var _iterator4 = node.childNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
				var child = _step4.value;

				copyNode(child, ctx);
			}
		} catch (err) {
			_didIteratorError4 = true;
			_iteratorError4 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion4 && _iterator4['return']) {
					_iterator4['return']();
				}
			} finally {
				if (_didIteratorError4) {
					throw _iteratorError4;
				}
			}
		}

		ctx.popElement();
	} else if (node.nodeType === Node.TEXT_NODE) {
		ctx.pushText(node.nodeValue);
	} else if (node.type === Node.ATTRIBUTE_NODE) {
		ctx.pushAttribute(node.name, node.value);
	}
}

},{"./dom/node":122,"./utils":125,"xpath":130}],125:[function(require,module,exports){
'use strict';

var Node = require('./dom/node');

module.exports = {
	stringify: function stringify(obj) {
		if (typeof obj === 'object' && 'nodeType' in obj) {
			if (obj.nodeType === Node.ELEMENT_NODE) {
				return innerText(obj);
			}

			if (obj.nodeType === Node.ATTRIBUTE_NODE) {
				return obj.value;
			}

			return 'nodeValue' in obj ? obj.nodeValue : '';
		}

		return String(obj);
	},

	innerText: (function (_innerText) {
		function innerText(_x) {
			return _innerText.apply(this, arguments);
		}

		innerText.toString = function () {
			return _innerText.toString();
		};

		return innerText;
	})(function (node) {
		return innerText(node);
	})
};

function innerText(node) {
	if ('innerText' in node) {
		return node.innerText;
	}

	if (node.nodeType === Node.TEXT_NODE) {
		return node.nodeValue;
	}

	return node.childNodes.map(function (node) {
		if (node.nodeType === Node.TEXT_NODE) {
			return node.nodeValue;
		} else if (node.nodeType === Node.ELEMENT_NODE) {
			return innerText(node);
		}
		return '';
	}).join('');
}

},{"./dom/node":122}],126:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":127}],127:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":128}],128:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],129:[function(require,module,exports){
/**
 * A trimmed version of CodeMirror's StringStream module for string parsing
 */
if (typeof module === 'object' && typeof define !== 'function') {
	var define = function (factory) {
		module.exports = factory(require, exports, module);
	};
}

define(function(require, exports, module) {
	/**
	 * @type StringStream
	 * @constructor
	 * @param {String} string Assuming that bound string should be
	 * immutable
	 */
	function StringStream(string) {
		this.pos = this.start = 0;
		this.string = string;
		this._length = string.length;
	}
	
	StringStream.prototype = {
		/**
		 * Returns true only if the stream is at the end of the line.
		 * @returns {Boolean}
		 */
		eol: function() {
			return this.pos >= this._length;
		},
		
		/**
		 * Returns true only if the stream is at the start of the line
		 * @returns {Boolean}
		 */
		sol: function() {
			return this.pos === 0;
		},
		
		/**
		 * Returns the next character in the stream without advancing it. 
		 * Will return <code>undefined</code> at the end of the line.
		 * @returns {String}
		 */
		peek: function() {
			return this.string.charAt(this.pos);
		},
		
		/**
		 * Returns the next character in the stream and advances it.
		 * Also returns <code>undefined</code> when no more characters are available.
		 * @returns {String}
		 */
		next: function() {
			if (this.pos < this._length)
				return this.string.charAt(this.pos++);
		},
		
		/**
		 * match can be a character, a regular expression, or a function that
		 * takes a character and returns a boolean. If the next character in the
		 * stream 'matches' the given argument, it is consumed and returned.
		 * Otherwise, undefined is returned.
		 * @param {Object} match
		 * @returns {String}
		 */
		eat: function(match) {
			var ch = this.string.charAt(this.pos), ok;
			if (typeof match == "string")
				ok = ch == match;
			else
				ok = ch && (match.test ? match.test(ch) : match(ch));
			
			if (ok) {
				++this.pos;
				return ch;
			}
		},
		
		/**
		 * Repeatedly calls <code>eat</code> with the given argument, until it
		 * fails. Returns <code>true</code> if any characters were eaten.
		 * @param {Object} match
		 * @returns {Boolean}
		 */
		eatWhile: function(match) {
			var start = this.pos;
			while (this.eat(match)) {}
			return this.pos > start;
		},
		
		/**
		 * Shortcut for <code>eatWhile</code> when matching white-space.
		 * @returns {Boolean}
		 */
		eatSpace: function() {
			var start = this.pos;
			while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
				++this.pos;
			return this.pos > start;
		},
		
		/**
		 * Moves the position to the end of the line.
		 */
		skipToEnd: function() {
			this.pos = this._length;
		},
		
		/**
		 * Skips to the next occurrence of the given character, if found on the
		 * current line (doesn't advance the stream if the character does not
		 * occur on the line). Returns true if the character was found.
		 * @param {String} ch
		 * @returns {Boolean}
		 */
		skipTo: function(ch) {
			var found = this.string.indexOf(ch, this.pos);
			if (found > -1) {
				this.pos = found;
				return true;
			}
		},
		
		/**
		 * Skips to <code>close</code> character which is pair to <code>open</code>
		 * character, considering possible pair nesting. This function is used
		 * to consume pair of characters, like opening and closing braces
		 * @param {String} open
		 * @param {String} close
		 * @returns {Boolean} Returns <code>true</code> if pair was successfully
		 * consumed
		 */
		skipToPair: function(open, close, skipString) {
			var braceCount = 0, ch;
			var pos = this.pos, len = this._length;
			while (pos < len) {
				ch = this.string.charAt(pos++);
				if (ch == open) {
					braceCount++;
				} else if (ch == close) {
					braceCount--;
					if (braceCount < 1) {
						this.pos = pos;
						return true;
					}
				} else if (skipString && (ch == '"' || ch == "'")) {
					this.skipString(ch);
				}
			}
			
			return false;
		},

		/**
		 * A helper function which, in case of either single or
		 * double quote was found in current position, skips entire
		 * string (quoted value)
		 * @return {Boolean} Wether quoted string was skipped
		 */
		skipQuoted: function(noBackup) {
			var ch = this.string.charAt(noBackup ? this.pos : this.pos - 1);
			if (ch === '"' || ch === "'") {
				if (noBackup) {
					this.pos++;
				}
				return this.skipString(ch);
			}
		},

		/**
		 * A custom function to skip string literal, e.g. a "double-quoted"
		 * or 'single-quoted' value
		 * @param  {String} quote An opening quote
		 * @return {Boolean}
		 */
		skipString: function(quote) {
			var pos = this.pos, len = this._length, ch;
			while (pos < len) {
				ch = this.string.charAt(pos++);
				if (ch == '\\') {
					continue;
				} else if (ch == quote) {
					this.pos = pos;
					return true;
				}
			}

			return false;
		},
		
		/**
		 * Backs up the stream n characters. Backing it up further than the
		 * start of the current token will cause things to break, so be careful.
		 * @param {Number} n
		 */
		backUp : function(n) {
			this.pos -= n;
		},
		
		/**
		 * Act like a multi-character <code>eat</code>—if <code>consume</code> is true or
		 * not given—or a look-ahead that doesn't update the stream position—if
		 * it is false. <code>pattern</code> can be either a string or a
		 * regular expression starting with ^. When it is a string,
		 * <code>caseInsensitive</code> can be set to true to make the match
		 * case-insensitive. When successfully matching a regular expression,
		 * the returned value will be the array returned by <code>match</code>,
		 * in case you need to extract matched groups.
		 * 
		 * @param {RegExp} pattern
		 * @param {Boolean} consume
		 * @param {Boolean} caseInsensitive
		 * @returns
		 */
		match: function(pattern, consume, caseInsensitive) {
			if (typeof pattern == "string") {
				var cased = caseInsensitive
					? function(str) {return str.toLowerCase();}
					: function(str) {return str;};
				
				if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {
					if (consume !== false)
						this.pos += pattern.length;
					return true;
				}
			} else {
				var match = this.string.slice(this.pos).match(pattern);
				if (match && consume !== false)
					this.pos += match[0].length;
				return match;
			}
		},
		
		/**
		 * Get the string between the start of the current token and the 
		 * current stream position.
		 * @returns {String}
		 */
		current: function(backUp) {
			return this.string.slice(this.start, this.pos - (backUp ? 1 : 0));
		}
	};

	module.exports = function(string) {
		return new StringStream(string);
	};

	/** @deprecated */
	module.exports.create = module.exports;
	return module.exports;
});
},{}],130:[function(require,module,exports){
/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the Creative Commons Attribution-ShareAlike
 * License. To view a copy of this license, visit
 *
 *   http://creativecommons.org/licenses/by-sa/2.0/
 *
 * or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford,
 * California 94305, USA.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to S閎astien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   S閎astien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
if(typeof exports === 'undefined' ) {
	xpath = {};
}
(function(exports) {
	
// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == "ancestor") {
			return Step.ANCESTOR;
		} else if (rhs[0] == "ancestor-or-self") {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == "attribute") {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == "child") {
			return Step.CHILD;
		} else if (rhs[0] == "descendant") {
			return Step.DESCENDANT;
		} else if (rhs[0] == "descendant-or-self") {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == "following") {
			return Step.FOLLOWING;
		} else if (rhs[0] == "following-sibling") {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == "namespace") {
			return Step.NAMESPACE;
		} else if (rhs[0] == "parent") {
			return Step.PARENT;
		} else if (rhs[0] == "preceding") {
			return Step.PRECEDING;
		} else if (rhs[0] == "preceding-sibling") {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == "self") {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == "comment") {
			return new NodeTest(NodeTest.COMMENT, undefined);
		} else if (rhs[0] == "text") {
			return new NodeTest(NodeTest.TEXT, undefined);
		} else if (rhs[0] == "processing-instruction") {
			return new NodeTest(NodeTest.PI, undefined);
		} else if (rhs[0] == "node") {
			return new NodeTest(NodeTest.NODE, undefined);
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest(NodeTest.PI, rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTANY, undefined);
	};
	this.reduceActions[69] = function(rhs) {
		var prefix = rhs[0].substring(0, rhs[0].indexOf(":"));
		return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);
	};
};

XPathParser.actionTable = [
	" s s        sssssssss    s ss  s  ss",
	"                 s                  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                rrrrr               ",
	" s s        sssssssss    s ss  s  ss",
	"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	" s s        sssssssss    s ss  s  ss",
	"                            s       ",
	"                            s       ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"  s                                 ",
	"                            s       ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"a                                   ",
	"r       s                    rr  r  ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrs  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr sr  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                sssss               ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"              s                     ",
	"                             s      ",
	"                rrrrr               ",
	" s s        sssssssss    s sss s  ss",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss      ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             rr     ",
	"                             s      ",
	"                             rs     ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"                                 r  ",
	"                                 s  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s s        sssssssss    s ss  s  ss",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             r      "
];

XPathParser.actionTableNumber = [
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                 J                  ",
	"a  aaaaaaaaa         aaaaaaa aa  a  ",
	"                YYYYY               ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                            N       ",
	"                            O       ",
	"e  eeeeeeeee         eeeeeee ee ee  ",
	"f  fffffffff         fffffff ff ff  ",
	"d  ddddddddd         ddddddd dd dd  ",
	"B  BBBBBBBBB         BBBBBBB BB BB  ",
	"A  AAAAAAAAA         AAAAAAA AA AA  ",
	"  P                                 ",
	"                            Q       ",
	" 1           .  +*)('          #  \" ",
	"b  bbbbbbbbb         bbbbbbb bb  b  ",
	"                                    ",
	"!       S                    !!  !  ",
	"\"      T\"                    \"\"  \"  ",
	"$   V  $$            U       $$  $  ",
	"&   &ZY&&            &XW     &&  &  ",
	")   )))))            )))\\[   ))  )  ",
	".   ....._^]         .....   ..  .  ",
	"1   11111111         11111   11  1  ",
	"5   55555555         55555`  55  5  ",
	"7   77777777         777777  77  7  ",
	"9   99999999         999999  99  9  ",
	":  c::::::::         ::::::b :: a:  ",
	"I  fIIIIIIII         IIIIIIe II  I  ",
	"=  =========         ======= == ==  ",
	"?  ?????????         ??????? ?? ??  ",
	"C  CCCCCCCCC         CCCCCCC CC CC  ",
	"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	"M   MMMMMMMM         MMMMMM  MM  M  ",
	"N  NNNNNNNNN         NNNNNNN NN  N  ",
	"P  PPPPPPPPP         PPPPPPP PP  P  ",
	"                +*)('               ",
	"R  RRRRRRRRR         RRRRRRR RR aR  ",
	"U  UUUUUUUUU         UUUUUUU UU  U  ",
	"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	"c  ccccccccc         ccccccc cc cc  ",
	"                             j      ",
	"L  fLLLLLLLL         LLLLLLe LL  L  ",
	"6   66666666         66666   66  6  ",
	"              k                     ",
	"                             l      ",
	"                XXXXX               ",
	" 1 0        /.-,+*)('    & %$m #  \"!",
	"_  f________         ______e __  _  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('      %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	">  >>>>>>>>>         >>>>>>> >> >>  ",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	"V  VVVVVVVVV         VVVVVVV VV aV  ",
	"T  TTTTTTTTT         TTTTTTT TT  T  ",
	"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	"                             \x87      ",
	"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	"D  DDDDDDDDD         DDDDDDD DD DD  ",
	"                             HH     ",
	"                             \x88      ",
	"                             F\x89     ",
	"#      T#                    ##  #  ",
	"%   V  %%            U       %%  %  ",
	"'   'ZY''            'XW     ''  '  ",
	"(   (ZY((            (XW     ((  (  ",
	"+   +++++            +++\\[   ++  +  ",
	"*   *****            ***\\[   **  *  ",
	"-   -----            ---\\[   --  -  ",
	",   ,,,,,            ,,,\\[   ,,  ,  ",
	"0   00000_^]         00000   00  0  ",
	"/   /////_^]         /////   //  /  ",
	"2   22222222         22222   22  2  ",
	"3   33333333         33333   33  3  ",
	"4   44444444         44444   44  4  ",
	"8   88888888         888888  88  8  ",
	"                                 ^  ",
	"                                 \x8a  ",
	";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	"<  f<<<<<<<<         <<<<<<e <<  <  ",
	"O  OOOOOOOOO         OOOOOOO OO  O  ",
	"`  `````````         ``````` ``  `  ",
	"S  SSSSSSSSS         SSSSSSS SS  S  ",
	"W  WWWWWWWWW         WWWWWWW WW  W  ",
	"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	"E  EEEEEEEEE         EEEEEEE EE EE  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	"                             G      "
];

XPathParser.gotoTable = [
	"3456789:;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"L456789:;<=>?@ AB  CDEFGH IJ ",
	"            M        EFGH IJ ",
	"       N;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"            S        EFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"              e              ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                        h  J ",
	"              i          j   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ ABpqCDEFGH IJ ",
	"                             ",
	"  r6789:;<=>?@ AB  CDEFGH IJ ",
	"   s789:;<=>?@ AB  CDEFGH IJ ",
	"    t89:;<=>?@ AB  CDEFGH IJ ",
	"    u89:;<=>?@ AB  CDEFGH IJ ",
	"     v9:;<=>?@ AB  CDEFGH IJ ",
	"     w9:;<=>?@ AB  CDEFGH IJ ",
	"     x9:;<=>?@ AB  CDEFGH IJ ",
	"     y9:;<=>?@ AB  CDEFGH IJ ",
	"      z:;<=>?@ AB  CDEFGH IJ ",
	"      {:;<=>?@ AB  CDEFGH IJ ",
	"       |;<=>?@ AB  CDEFGH IJ ",
	"       };<=>?@ AB  CDEFGH IJ ",
	"       ~;<=>?@ AB  CDEFGH IJ ",
	"         \x7f=>?@ AB  CDEFGH IJ ",
	"\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	"            \x82        EFGH IJ ",
	"            \x83        EFGH IJ ",
	"                             ",
	"                     \x84 GH IJ ",
	"                     \x85 GH IJ ",
	"              i          \x86   ",
	"              i          \x87   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	"                             ",
	"                             "
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + '\0';

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = s.charAt(pos++);
		}
		if (c == '\0' || pos >= s.length) {
			break;
		}

		if (c == '(') {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ')') {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '[') {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ']') {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '@') {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ',') {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '|') {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '+') {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '-') {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '=') {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '$') {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == '.') {
			c = s.charAt(pos++);
			if (c == '.') {
				types.push(XPathParser.DOUBLEDOT);
				values.push("..");
				c = s.charAt(pos++);
				continue;
			}
			if (c >= '0' && c <= '9') {
				var number = "." + c;
				c = s.charAt(pos++);
				while (c >= '0' && c <= '9') {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push('.');
			continue;
		}

		if (c == '\'' || c == '"') {
			var delimiter = c;
			var literal = "";
			while ((c = s.charAt(pos++)) != delimiter) {
				literal += c;
			}
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c >= '0' && c <= '9') {
			var number = c;
			c = s.charAt(pos++);
			while (c >= '0' && c <= '9') {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == '.') {
				if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c >= '0' && c <= '9') {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == '*') {
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == ':') {
			if (s.charAt(pos) == ':') {
				types.push(XPathParser.DOUBLECOLON);
				values.push("::");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '/') {
			c = s.charAt(pos++);
			if (c == '/') {
				types.push(XPathParser.DOUBLESLASH);
				values.push("//");
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push('/');
			continue;
		}

		if (c == '!') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.NOTEQUAL);
				values.push("!=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '<') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push("<=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push('<');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '>') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(">=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push('>');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					if (name == "and") {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == "or") {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == "mod") {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == "div") {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == ':') {
				if (s.charAt(pos) == '*') {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + ":*");
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
					name += ':';
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == '(') {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == ':') {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == '(') {
				if (name == "comment" || name == "text" || name == "node") {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == "processing-instruction") {
					if (s.charAt(pos) == ')') {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error("Unexpected character " + c);
	}
	types.push(1);
	values.push("[EOF]");
	return [types, values];
};

XPathParser.SHIFT = 's';
XPathParser.REDUCE = 'r';
XPathParser.ACCEPT = 'a';

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push("_S");

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i < num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error("XPath parse error");
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;
	c.caseInsensitive = false;
	if (c.contextNode != null) {
		var doc = c.contextNode;
		if (doc.nodeType != 9 /*Node.DOCUMENT_NODE*/) {
			doc = doc.ownerDocument;
		}
		try {
			c.caseInsensitive = doc.implementation.hasFeature("HTML", "2.0");
		} catch (e) {
			c.caseInsensitive = true;
		}
	}
	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return "<Expression>";
};

Expression.prototype.evaluate = function(c) {
	throw new Error("Could not evaluate expression.");
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return "-" + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return this.lhs.toString() + " | " + this.rhs.toString();
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length > 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

PathExpr.prototype.evaluate = function(c) {
	var nodes;
	var xpc = new XPathContext();
	xpc.variableResolver = c.variableResolver;
	xpc.functionResolver = c.functionResolver;
	xpc.namespaceResolver = c.namespaceResolver;
	xpc.expressionContextNode = c.expressionContextNode;
	xpc.virtualRoot = c.virtualRoot;
	xpc.caseInsensitive = c.caseInsensitive;
	if (this.filter == null) {
		nodes = [ c.contextNode ];
	} else {
		var ns = this.filter.evaluate(c);
		if (!Utilities.instance_of(ns, XNodeSet)) {
			if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
				throw new Error("Path expression filter must evaluate to a nodset if predicates or location path are used");
			}
			return ns;
		}
		nodes = ns.toArray();
		if (this.filterPredicates != null) {
			// apply each of the predicates in turn
			for (var j = 0; j < this.filterPredicates.length; j++) {
				var pred = this.filterPredicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					}
				}
				nodes = newNodes;
			}
		}
	}
	if (this.locationPath != null) {
		if (this.locationPath.absolute) {
			if (nodes[0].nodeType != 9 /*Node.DOCUMENT_NODE*/) {
				if (xpc.virtualRoot != null) {
					nodes = [ xpc.virtualRoot ];
				} else {
					if (nodes[0].ownerDocument == null) {
						// IE 5.5 doesn't have ownerDocument?
						var n = nodes[0];
						while (n.parentNode != null) {
							n = n.parentNode;
						}
						nodes = [ n ];
					} else {
						nodes = [ nodes[0].ownerDocument ];
					}
				}
			} else {
				nodes = [ nodes[0] ];
			}
		}
		for (var i = 0; i < this.locationPath.steps.length; i++) {
			var step = this.locationPath.steps[i];
			var newNodes = [];
			for (var j = 0; j < nodes.length; j++) {
				xpc.contextNode = nodes[j];
				switch (step.axis) {
					case Step.ANCESTOR:
						// look at all the ancestor nodes
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var m;
						if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
							m = this.getOwnerElement(xpc.contextNode);
						} else {
							m = xpc.contextNode.parentNode;
						}
						while (m != null) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
							m = m.parentNode;
						}
						break;

					case Step.ANCESTORORSELF:
						// look at all the ancestor nodes and the current node
						for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? this.getOwnerElement(m) : m.parentNode) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
						}
						break;

					case Step.ATTRIBUTE:
						// look at the attributes
						var nnm = xpc.contextNode.attributes;
						if (nnm != null) {
							for (var k = 0; k < nnm.length; k++) {
								var m = nnm.item(k);
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
							}
						}
						break;

					case Step.CHILD:
						// look at all child elements
						for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.DESCENDANT:
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.DESCENDANTORSELF:
						// look at self
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.FOLLOWING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var st = [];
						if (xpc.contextNode.firstChild != null) {
							st.unshift(xpc.contextNode.firstChild);
						} else {
							st.unshift(xpc.contextNode.nextSibling);
						}
						for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
							st.unshift(m.nextSibling);
						}
						do {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						} while (st.length > 0);
						break;

					case Step.FOLLOWINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.NAMESPACE:
						var n = {};
						if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
							n["xml"] = XPath.XML_NAMESPACE_URI;
							n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
							for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
								for (var k = 0; k < m.attributes.length; k++) {
									var attr = m.attributes.item(k);
									var nm = String(attr.name);
									if (nm == "xmlns") {
										if (n[""] == undefined) {
											n[""] = attr.value;
										}
									} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
										var pre = nm.substring(6, nm.length);
										if (n[pre] == undefined) {
											n[pre] = attr.value;
										}
									}
								}
							}
							for (var pre in n) {
								var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
								if (step.nodeTest.matches(nsn, xpc)) {
									newNodes.push(nsn);
								}
							}
						}
						break;

					case Step.PARENT:
						m = null;
						if (xpc.contextNode !== xpc.virtualRoot) {
							if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
								m = this.getOwnerElement(xpc.contextNode);
							} else {
								m = xpc.contextNode.parentNode;
							}
						}
						if (m != null && step.nodeTest.matches(m, xpc)) {
							newNodes.push(m);
						}
						break;

					case Step.PRECEDING:
						var st;
						if (xpc.virtualRoot != null) {
							st = [ xpc.virtualRoot ];
						} else {
							st = xpc.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
								? [ xpc.contextNode ]
								: [ xpc.contextNode.ownerDocument ];
						}
						outer: while (st.length > 0) {
							for (var m = st.pop(); m != null; ) {
								if (m == xpc.contextNode) {
									break outer;
								}
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.unshift(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.PRECEDINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.SELF:
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						break;

					default:
				}
			}
			nodes = newNodes;
			// apply each of the predicates in turn
			for (var j = 0; j < step.predicates.length; j++) {
				var pred = step.predicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					} else {
					}
				}
				nodes = newNodes;
			}
		}
	}
	var ns = new XNodeSet();
	ns.addArray(nodes);
	return ns;
};

PathExpr.prototype.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	if (Utilities.instance_of(res, XNumber)) {
		return c.contextPosition == res.numberValue();
	}
	return res.booleanValue();
};

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var s = this.filter.toString();
		if (Utilities.instance_of(this.filter, XString)) {
			s = "'" + s + "'";
		}
		if (this.filterPredicates != undefined) {
			for (var i = 0; i < this.filterPredicates.length; i++) {
				s = s + "[" + this.filterPredicates[i].toString() + "]";
			}
		}
		if (this.locationPath != undefined) {
			if (!this.locationPath.absolute) {
				s += "/";
			}
			s += this.locationPath.toString();
		}
		return s;
	}
	return this.locationPath.toString();
};

PathExpr.prototype.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode("..");
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName("*");
	for (var i = 0; i < elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j < nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length > 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	var s;
	if (this.absolute) {
		s = "/";
	} else {
		s = "";
	}
	for (var i = 0; i < this.steps.length; i++) {
		if (i != 0) {
			s += "/";
		}
		s += this.steps[i].toString();
	}
	return s;
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length > 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	var s;
	switch (this.axis) {
		case Step.ANCESTOR:
			s = "ancestor";
			break;
		case Step.ANCESTORORSELF:
			s = "ancestor-or-self";
			break;
		case Step.ATTRIBUTE:
			s = "attribute";
			break;
		case Step.CHILD:
			s = "child";
			break;
		case Step.DESCENDANT:
			s = "descendant";
			break;
		case Step.DESCENDANTORSELF:
			s = "descendant-or-self";
			break;
		case Step.FOLLOWING:
			s = "following";
			break;
		case Step.FOLLOWINGSIBLING:
			s = "following-sibling";
			break;
		case Step.NAMESPACE:
			s = "namespace";
			break;
		case Step.PARENT:
			s = "parent";
			break;
		case Step.PRECEDING:
			s = "preceding";
			break;
		case Step.PRECEDINGSIBLING:
			s = "preceding-sibling";
			break;
		case Step.SELF:
			s = "self";
			break;
	}
	s += "::";
	s += this.nodeTest.toString();
	for (var i = 0; i < this.predicates.length; i++) {
		s += "[" + this.predicates[i].toString() + "]";
	}
	return s;
};

Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length > 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			return "*";
		case NodeTest.NAMETESTPREFIXANY:
			return this.value + ":*";
		case NodeTest.NAMETESTRESOLVEDANY:
			return "{" + this.value + "}*";
		case NodeTest.NAMETESTQNAME:
			return this.value;
		case NodeTest.NAMETESTRESOLVEDNAME:
			return "{" + this.namespaceURI + "}" + this.value;
		case NodeTest.COMMENT:
			return "comment()";
		case NodeTest.TEXT:
			return "text()";
		case NodeTest.PI:
			if (this.value != undefined) {
				return "processing-instruction(\"" + this.value + "\")";
			}
			return "processing-instruction()";
		case NodeTest.NODE:
			return "node()";
	}
	return "<unknown nodetest type>";
};

NodeTest.prototype.matches = function(n, xpc) {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				return true;
			}
			return false;
		case NodeTest.NAMETESTPREFIXANY:
			if ((n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE*/)) {
				var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);
				if (ns == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				return ns == (n.namespaceURI || '');
			}
			return false;
		case NodeTest.NAMETESTQNAME:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);
				if (test[0] == null) {
					throw new Error("Cannot resolve QName " + this.value);
				}
				test[0] = String(test[0]);
				test[1] = String(test[1]);
				if (test[0] == "") {
					test[0] = null;
				}
				var node = [n.namespaceURI || '', n.localName];
				node[0] = String(node[0]);
				node[1] = String(node[1]);
				if (node[0] == "") {
					node[0] = null;
				}
				if (xpc.caseInsensitive) {
					return test[0] == node[0] && String(test[1]).toLowerCase() == String(node[1]).toLowerCase();
				}
				return test[0] == node[0] && test[1] == node[1];
			}
			return false;
		case NodeTest.COMMENT:
			return n.nodeType == 8 /*Node.COMMENT_NODE*/;
		case NodeTest.TEXT:
			return n.nodeType == 3 /*Node.TEXT_NODE*/ || n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/;
		case NodeTest.PI:
			return n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/
				&& (this.value == null || n.nodeName == this.value);
		case NodeTest.NODE:
			return n.nodeType == 9 /*Node.DOCUMENT_NODE*/
				|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
				|| n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
				|| n.nodeType == 3 /*Node.TEXT_NODE*/
				|| n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/
				|| n.nodeType == 8 /*Node.COMMENT_NODE*/
				|| n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/;
	}
	return false;
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length > 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return "$" + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
	return c.variableResolver.getVariable(this.variable, c);
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length > 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + "(";
	for (var i = 0; i < this.arguments.length; i++) {
		if (i > 0) {
			s += ", ";
		}
		s += this.arguments[i].toString();
	}
	return s + ")";
};

FunctionCall.prototype.evaluate = function(c) {
	var f = c.functionResolver.getFunction(this.functionName, c);
	if (f == undefined) {
		throw new Error("Unknown function " + this.functionName);
	}
	var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length > 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = s;
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error("Cannot convert string to nodeset");
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XString.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XString.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XString.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length > 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = Number(n);
};

XNumber.prototype.toString = function() {
	return this.num;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	return new XString(this.num);
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error("Cannot convert number to nodeset");
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num < r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num > r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num <= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num >= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length > 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error("Cannot convert boolean to nodeset");
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.num().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XBoolean.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XBoolean.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XBoolean.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth > rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth < lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth > rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

AVLTree.prototype.order = function(n1, n2) {
	if (n1 === n2) {
		return 0;
	}
	var d1 = 0;
	var d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode) {
		d2++;
	}
	if (d1 > d2) {
		while (d1 > d2) {
			n1 = n1.parentNode;
			d1--;
		}
		if (n1 == n2) {
			return 1;
		}
	} else if (d2 > d1) {
		while (d2 > d1) {
			n2 = n2.parentNode;
			d2--;
		}
		if (n1 == n2) {
			return -1;
		}
	}
	while (n1.parentNode != n2.parentNode) {
		n1 = n1.parentNode;
		n2 = n2.parentNode;
	}
	while (n1.previousSibling != null && n2.previousSibling != null) {
		n1 = n1.previousSibling;
		n2 = n2.previousSibling;
	}
	if (n1.previousSibling == null) {
		return -1;
	}
	return 1;
};

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = this.order(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
	this.tree = null;
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return "";
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.tree != null);
};

XNodeSet.prototype.booleanValue = function() {
	return this.tree != null;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return this.stringForNodeRec(n);
	}
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForNodeRec = function(n) {
	var s = "";
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
		if (n2.nodeType == 3 /*Node.TEXT_NODE*/) {
			s += n2.nodeValue;
		} else if (n2.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			s += this.stringForNodeRec(n2);
		}
	}
	return s;
};

XNodeSet.prototype.first = function() {
	var p = this.tree;
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    var added;
    if (this.tree == null) {
        this.tree = new AVLTree(n);
        added = true;
    } else {
        added = this.tree.add(n);
    }
    if (added) {
        this.size++;
    }
};

XNodeSet.prototype.addArray = function(ns) {
	for (var i = 0; i < ns.length; i++) {
		this.add(ns[i]);
	}
};

XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.tree, a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var b = r.toArray();
		for (var j = 0; j < b.length; j++) {
			var n2 = b[j];
			var r = new XString(this.stringForNode(n2));
			var res = o(l, r);
			if (res.booleanValue()) {
				return res;
			}
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.equals);
	}
	return this.compareWithNodeSet(r, Operators.equals);
};

XNodeSet.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.notequal);
	}
	return this.compareWithNodeSet(r, Operators.notequal);
};

XNodeSet.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthan);
	}
	return this.compareWithNodeSet(r, Operators.lessthan);
};

XNodeSet.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthan);
	}
	return this.compareWithNodeSet(r, Operators.greaterthan);
};

XNodeSet.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.lessthanorequal);
};

XNodeSet.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.greaterthanorequal);
};

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
	ns.tree = this.tree;
	ns.size = this.size;
	ns.addArray(r.toArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = "#namespace";
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(vn, c) {
	var parts = Utilities.splitQName(vn);
	if (parts[0] != null) {
		parts[0] = c.namespaceResolver.getNamespace(parts[0], c.expressionContextNode);
        if (parts[0] == null) {
            throw new Error("Cannot resolve QName " + fn);
        }
	}
	return this.getVariableWithName(parts[0], parts[1], c.expressionContextNode);
};

VariableResolver.prototype.getVariableWithName = function(ns, ln, c) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions["{}last"] = Functions.last;
	this.functions["{}position"] = Functions.position;
	this.functions["{}count"] = Functions.count;
	this.functions["{}id"] = Functions.id;
	this.functions["{}local-name"] = Functions.localName;
	this.functions["{}namespace-uri"] = Functions.namespaceURI;
	this.functions["{}name"] = Functions.name;
	this.functions["{}string"] = Functions.string;
	this.functions["{}concat"] = Functions.concat;
	this.functions["{}starts-with"] = Functions.startsWith;
	this.functions["{}contains"] = Functions.contains;
	this.functions["{}substring-before"] = Functions.substringBefore;
	this.functions["{}substring-after"] = Functions.substringAfter;
	this.functions["{}substring"] = Functions.substring;
	this.functions["{}string-length"] = Functions.stringLength;
	this.functions["{}normalize-space"] = Functions.normalizeSpace;
	this.functions["{}translate"] = Functions.translate;
	this.functions["{}boolean"] = Functions.boolean_;
	this.functions["{}not"] = Functions.not;
	this.functions["{}true"] = Functions.true_;
	this.functions["{}false"] = Functions.false_;
	this.functions["{}lang"] = Functions.lang;
	this.functions["{}number"] = Functions.number;
	this.functions["{}sum"] = Functions.sum;
	this.functions["{}floor"] = Functions.floor;
	this.functions["{}ceiling"] = Functions.ceiling;
	this.functions["{}round"] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions["{" + ns + "}" + ln] = f;
};

FunctionResolver.prototype.getFunction = function(fn, c) {
	var parts = Utilities.resolveQName(fn, c.namespaceResolver, c.contextNode, false);
    if (parts[0] == null) {
        throw new Error("Cannot resolve QName " + fn);
    }
	return this.getFunctionWithName(parts[0], parts[1], c.contextNode);
};

FunctionResolver.prototype.getFunctionWithName = function(ns, ln, c) {
	return this.functions["{" + ns + "}" + ln];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == "xml") {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == "xmlns") {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.prototype.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i < nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.nodeName;
			if (aname == "xmlns" && prefix == ""
					|| aname == "xmlns:" + prefix) {
				return String(a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

Functions = new Object();

Functions.last = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function last expects ()");
	}
	return new XNumber(c.contextSize);
};

Functions.position = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error("Function position expects ()");
	}
	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error("Function count expects (node-set)");
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error("Function id expects (object)");
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(" ");
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i < ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function local-name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.localName ? n.localName : n.baseName);
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function namespace-uri expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/ || n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.localName == null) {
		return new XString("");
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error("Function string expects (object?)");
};

Functions.concat = function() {
	var c = arguments[0];
	if (arguments.length < 3) {
		throw new Error("Function concat expects (string, string, string*)");
	}
	var s = "";
	for (var i = 1; i < arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function startsWith expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function contains expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) != -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-before expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-after expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString("");
	}
	return new XString(s1.substring(i + s2.length));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error("Function substring expects (string, number, number?)");
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function string-length expects (string?)");
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function normalize-space expects (string?)");
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = "";
	while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i <= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += " ";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function() {
	var c = arguments[0];
	if (arguments.length != 4) {
		throw new Error("Function translate expects (string, string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	var s3 = arguments[3].evaluate(c).stringValue();
	var map = [];
	for (var i = 0; i < s2.length; i++) {
		var j = s2.charCodeAt(i);
		if (map[j] == undefined) {
			var k = i > s3.length ? "" : s3.charAt(i);
			map[j] = k;
		}
	}
	var t = "";
	for (var i = 0; i < s1.length; i++) {
		var c = s1.charCodeAt(i);
		var r = map[c];
		if (r == undefined) {
			t += s1.charAt(i);
		} else {
			t += r;
		}
	}
	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function boolean expects (object)");
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function not expects (object)");
	}
	return arguments[1].evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function true expects ()");
	}
	return new XBoolean(true);
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function false expects ()");
	}
	return new XBoolean(false);
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function lang expects (string)");
	}
	var lang;
	for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return new XBoolean(false);
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&& (lang.length == s.length || lang.charAt(s.length) == '-'));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error("Function number expects (object?)");
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error("Function sum expects (node-set)");
	}
	ns = ns.toArray();
	var n = 0;
	for (var i = 0; i < ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function floor expects (number)");
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function ceiling expects (number)");
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function round expects (number)");
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

Utilities = new Object();

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(":");
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace("", n);
			if (parts[0] == null) {
				parts[0] = "";
			}
		} else {
			parts[0] = "";
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c >= 0x0041 && c <= 0x005A ||
		c >= 0x0061 && c <= 0x007A ||
		c >= 0x00C0 && c <= 0x00D6 ||
		c >= 0x00D8 && c <= 0x00F6 ||
		c >= 0x00F8 && c <= 0x00FF ||
		c >= 0x0100 && c <= 0x0131 ||
		c >= 0x0134 && c <= 0x013E ||
		c >= 0x0141 && c <= 0x0148 ||
		c >= 0x014A && c <= 0x017E ||
		c >= 0x0180 && c <= 0x01C3 ||
		c >= 0x01CD && c <= 0x01F0 ||
		c >= 0x01F4 && c <= 0x01F5 ||
		c >= 0x01FA && c <= 0x0217 ||
		c >= 0x0250 && c <= 0x02A8 ||
		c >= 0x02BB && c <= 0x02C1 ||
		c == 0x0386 ||
		c >= 0x0388 && c <= 0x038A ||
		c == 0x038C ||
		c >= 0x038E && c <= 0x03A1 ||
		c >= 0x03A3 && c <= 0x03CE ||
		c >= 0x03D0 && c <= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c >= 0x03E2 && c <= 0x03F3 ||
		c >= 0x0401 && c <= 0x040C ||
		c >= 0x040E && c <= 0x044F ||
		c >= 0x0451 && c <= 0x045C ||
		c >= 0x045E && c <= 0x0481 ||
		c >= 0x0490 && c <= 0x04C4 ||
		c >= 0x04C7 && c <= 0x04C8 ||
		c >= 0x04CB && c <= 0x04CC ||
		c >= 0x04D0 && c <= 0x04EB ||
		c >= 0x04EE && c <= 0x04F5 ||
		c >= 0x04F8 && c <= 0x04F9 ||
		c >= 0x0531 && c <= 0x0556 ||
		c == 0x0559 ||
		c >= 0x0561 && c <= 0x0586 ||
		c >= 0x05D0 && c <= 0x05EA ||
		c >= 0x05F0 && c <= 0x05F2 ||
		c >= 0x0621 && c <= 0x063A ||
		c >= 0x0641 && c <= 0x064A ||
		c >= 0x0671 && c <= 0x06B7 ||
		c >= 0x06BA && c <= 0x06BE ||
		c >= 0x06C0 && c <= 0x06CE ||
		c >= 0x06D0 && c <= 0x06D3 ||
		c == 0x06D5 ||
		c >= 0x06E5 && c <= 0x06E6 ||
		c >= 0x0905 && c <= 0x0939 ||
		c == 0x093D ||
		c >= 0x0958 && c <= 0x0961 ||
		c >= 0x0985 && c <= 0x098C ||
		c >= 0x098F && c <= 0x0990 ||
		c >= 0x0993 && c <= 0x09A8 ||
		c >= 0x09AA && c <= 0x09B0 ||
		c == 0x09B2 ||
		c >= 0x09B6 && c <= 0x09B9 ||
		c >= 0x09DC && c <= 0x09DD ||
		c >= 0x09DF && c <= 0x09E1 ||
		c >= 0x09F0 && c <= 0x09F1 ||
		c >= 0x0A05 && c <= 0x0A0A ||
		c >= 0x0A0F && c <= 0x0A10 ||
		c >= 0x0A13 && c <= 0x0A28 ||
		c >= 0x0A2A && c <= 0x0A30 ||
		c >= 0x0A32 && c <= 0x0A33 ||
		c >= 0x0A35 && c <= 0x0A36 ||
		c >= 0x0A38 && c <= 0x0A39 ||
		c >= 0x0A59 && c <= 0x0A5C ||
		c == 0x0A5E ||
		c >= 0x0A72 && c <= 0x0A74 ||
		c >= 0x0A85 && c <= 0x0A8B ||
		c == 0x0A8D ||
		c >= 0x0A8F && c <= 0x0A91 ||
		c >= 0x0A93 && c <= 0x0AA8 ||
		c >= 0x0AAA && c <= 0x0AB0 ||
		c >= 0x0AB2 && c <= 0x0AB3 ||
		c >= 0x0AB5 && c <= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c >= 0x0B05 && c <= 0x0B0C ||
		c >= 0x0B0F && c <= 0x0B10 ||
		c >= 0x0B13 && c <= 0x0B28 ||
		c >= 0x0B2A && c <= 0x0B30 ||
		c >= 0x0B32 && c <= 0x0B33 ||
		c >= 0x0B36 && c <= 0x0B39 ||
		c == 0x0B3D ||
		c >= 0x0B5C && c <= 0x0B5D ||
		c >= 0x0B5F && c <= 0x0B61 ||
		c >= 0x0B85 && c <= 0x0B8A ||
		c >= 0x0B8E && c <= 0x0B90 ||
		c >= 0x0B92 && c <= 0x0B95 ||
		c >= 0x0B99 && c <= 0x0B9A ||
		c == 0x0B9C ||
		c >= 0x0B9E && c <= 0x0B9F ||
		c >= 0x0BA3 && c <= 0x0BA4 ||
		c >= 0x0BA8 && c <= 0x0BAA ||
		c >= 0x0BAE && c <= 0x0BB5 ||
		c >= 0x0BB7 && c <= 0x0BB9 ||
		c >= 0x0C05 && c <= 0x0C0C ||
		c >= 0x0C0E && c <= 0x0C10 ||
		c >= 0x0C12 && c <= 0x0C28 ||
		c >= 0x0C2A && c <= 0x0C33 ||
		c >= 0x0C35 && c <= 0x0C39 ||
		c >= 0x0C60 && c <= 0x0C61 ||
		c >= 0x0C85 && c <= 0x0C8C ||
		c >= 0x0C8E && c <= 0x0C90 ||
		c >= 0x0C92 && c <= 0x0CA8 ||
		c >= 0x0CAA && c <= 0x0CB3 ||
		c >= 0x0CB5 && c <= 0x0CB9 ||
		c == 0x0CDE ||
		c >= 0x0CE0 && c <= 0x0CE1 ||
		c >= 0x0D05 && c <= 0x0D0C ||
		c >= 0x0D0E && c <= 0x0D10 ||
		c >= 0x0D12 && c <= 0x0D28 ||
		c >= 0x0D2A && c <= 0x0D39 ||
		c >= 0x0D60 && c <= 0x0D61 ||
		c >= 0x0E01 && c <= 0x0E2E ||
		c == 0x0E30 ||
		c >= 0x0E32 && c <= 0x0E33 ||
		c >= 0x0E40 && c <= 0x0E45 ||
		c >= 0x0E81 && c <= 0x0E82 ||
		c == 0x0E84 ||
		c >= 0x0E87 && c <= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c >= 0x0E94 && c <= 0x0E97 ||
		c >= 0x0E99 && c <= 0x0E9F ||
		c >= 0x0EA1 && c <= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c >= 0x0EAA && c <= 0x0EAB ||
		c >= 0x0EAD && c <= 0x0EAE ||
		c == 0x0EB0 ||
		c >= 0x0EB2 && c <= 0x0EB3 ||
		c == 0x0EBD ||
		c >= 0x0EC0 && c <= 0x0EC4 ||
		c >= 0x0F40 && c <= 0x0F47 ||
		c >= 0x0F49 && c <= 0x0F69 ||
		c >= 0x10A0 && c <= 0x10C5 ||
		c >= 0x10D0 && c <= 0x10F6 ||
		c == 0x1100 ||
		c >= 0x1102 && c <= 0x1103 ||
		c >= 0x1105 && c <= 0x1107 ||
		c == 0x1109 ||
		c >= 0x110B && c <= 0x110C ||
		c >= 0x110E && c <= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c >= 0x1154 && c <= 0x1155 ||
		c == 0x1159 ||
		c >= 0x115F && c <= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c >= 0x116D && c <= 0x116E ||
		c >= 0x1172 && c <= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c >= 0x11AE && c <= 0x11AF ||
		c >= 0x11B7 && c <= 0x11B8 ||
		c == 0x11BA ||
		c >= 0x11BC && c <= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c >= 0x1E00 && c <= 0x1E9B ||
		c >= 0x1EA0 && c <= 0x1EF9 ||
		c >= 0x1F00 && c <= 0x1F15 ||
		c >= 0x1F18 && c <= 0x1F1D ||
		c >= 0x1F20 && c <= 0x1F45 ||
		c >= 0x1F48 && c <= 0x1F4D ||
		c >= 0x1F50 && c <= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c >= 0x1F5F && c <= 0x1F7D ||
		c >= 0x1F80 && c <= 0x1FB4 ||
		c >= 0x1FB6 && c <= 0x1FBC ||
		c == 0x1FBE ||
		c >= 0x1FC2 && c <= 0x1FC4 ||
		c >= 0x1FC6 && c <= 0x1FCC ||
		c >= 0x1FD0 && c <= 0x1FD3 ||
		c >= 0x1FD6 && c <= 0x1FDB ||
		c >= 0x1FE0 && c <= 0x1FEC ||
		c >= 0x1FF2 && c <= 0x1FF4 ||
		c >= 0x1FF6 && c <= 0x1FFC ||
		c == 0x2126 ||
		c >= 0x212A && c <= 0x212B ||
		c == 0x212E ||
		c >= 0x2180 && c <= 0x2182 ||
		c >= 0x3041 && c <= 0x3094 ||
		c >= 0x30A1 && c <= 0x30FA ||
		c >= 0x3105 && c <= 0x312C ||
		c >= 0xAC00 && c <= 0xD7A3 ||
		c >= 0x4E00 && c <= 0x9FA5 ||
		c == 0x3007 ||
		c >= 0x3021 && c <= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c >= 0x0030 && c <= 0x0039
		|| c >= 0x0660 && c <= 0x0669
		|| c >= 0x06F0 && c <= 0x06F9
		|| c >= 0x0966 && c <= 0x096F
		|| c >= 0x09E6 && c <= 0x09EF
		|| c >= 0x0A66 && c <= 0x0A6F
		|| c >= 0x0AE6 && c <= 0x0AEF
		|| c >= 0x0B66 && c <= 0x0B6F
		|| c >= 0x0BE7 && c <= 0x0BEF
		|| c >= 0x0C66 && c <= 0x0C6F
		|| c >= 0x0CE6 && c <= 0x0CEF
		|| c >= 0x0D66 && c <= 0x0D6F
		|| c >= 0x0E50 && c <= 0x0E59
		|| c >= 0x0ED0 && c <= 0x0ED9
		|| c >= 0x0F20 && c <= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c >= 0x0300 && c <= 0x0345
		|| c >= 0x0360 && c <= 0x0361
		|| c >= 0x0483 && c <= 0x0486
		|| c >= 0x0591 && c <= 0x05A1
		|| c >= 0x05A3 && c <= 0x05B9
		|| c >= 0x05BB && c <= 0x05BD
		|| c == 0x05BF
		|| c >= 0x05C1 && c <= 0x05C2
		|| c == 0x05C4
		|| c >= 0x064B && c <= 0x0652
		|| c == 0x0670
		|| c >= 0x06D6 && c <= 0x06DC
		|| c >= 0x06DD && c <= 0x06DF
		|| c >= 0x06E0 && c <= 0x06E4
		|| c >= 0x06E7 && c <= 0x06E8
		|| c >= 0x06EA && c <= 0x06ED
		|| c >= 0x0901 && c <= 0x0903
		|| c == 0x093C
		|| c >= 0x093E && c <= 0x094C
		|| c == 0x094D
		|| c >= 0x0951 && c <= 0x0954
		|| c >= 0x0962 && c <= 0x0963
		|| c >= 0x0981 && c <= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c >= 0x09C0 && c <= 0x09C4
		|| c >= 0x09C7 && c <= 0x09C8
		|| c >= 0x09CB && c <= 0x09CD
		|| c == 0x09D7
		|| c >= 0x09E2 && c <= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c >= 0x0A40 && c <= 0x0A42
		|| c >= 0x0A47 && c <= 0x0A48
		|| c >= 0x0A4B && c <= 0x0A4D
		|| c >= 0x0A70 && c <= 0x0A71
		|| c >= 0x0A81 && c <= 0x0A83
		|| c == 0x0ABC
		|| c >= 0x0ABE && c <= 0x0AC5
		|| c >= 0x0AC7 && c <= 0x0AC9
		|| c >= 0x0ACB && c <= 0x0ACD
		|| c >= 0x0B01 && c <= 0x0B03
		|| c == 0x0B3C
		|| c >= 0x0B3E && c <= 0x0B43
		|| c >= 0x0B47 && c <= 0x0B48
		|| c >= 0x0B4B && c <= 0x0B4D
		|| c >= 0x0B56 && c <= 0x0B57
		|| c >= 0x0B82 && c <= 0x0B83
		|| c >= 0x0BBE && c <= 0x0BC2
		|| c >= 0x0BC6 && c <= 0x0BC8
		|| c >= 0x0BCA && c <= 0x0BCD
		|| c == 0x0BD7
		|| c >= 0x0C01 && c <= 0x0C03
		|| c >= 0x0C3E && c <= 0x0C44
		|| c >= 0x0C46 && c <= 0x0C48
		|| c >= 0x0C4A && c <= 0x0C4D
		|| c >= 0x0C55 && c <= 0x0C56
		|| c >= 0x0C82 && c <= 0x0C83
		|| c >= 0x0CBE && c <= 0x0CC4
		|| c >= 0x0CC6 && c <= 0x0CC8
		|| c >= 0x0CCA && c <= 0x0CCD
		|| c >= 0x0CD5 && c <= 0x0CD6
		|| c >= 0x0D02 && c <= 0x0D03
		|| c >= 0x0D3E && c <= 0x0D43
		|| c >= 0x0D46 && c <= 0x0D48
		|| c >= 0x0D4A && c <= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c >= 0x0E34 && c <= 0x0E3A
		|| c >= 0x0E47 && c <= 0x0E4E
		|| c == 0x0EB1
		|| c >= 0x0EB4 && c <= 0x0EB9
		|| c >= 0x0EBB && c <= 0x0EBC
		|| c >= 0x0EC8 && c <= 0x0ECD
		|| c >= 0x0F18 && c <= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c >= 0x0F71 && c <= 0x0F84
		|| c >= 0x0F86 && c <= 0x0F8B
		|| c >= 0x0F90 && c <= 0x0F95
		|| c == 0x0F97
		|| c >= 0x0F99 && c <= 0x0FAD
		|| c >= 0x0FB1 && c <= 0x0FB7
		|| c == 0x0FB9
		|| c >= 0x20D0 && c <= 0x20DC
		|| c == 0x20E1
		|| c >= 0x302A && c <= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c >= 0x3031 && c <= 0x3035
		|| c >= 0x309D && c <= 0x309E
		|| c >= 0x30FC && c <= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute("id") == id
				|| n.getAttributeNS(null, "id") == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

XPathException.prototype = {};
XPathException.prototype.constructor = XPathException;
XPathException.superclass = Object.prototype;

function XPathException(c, e) {
	this.code = c;
	this.exception = e;
}

XPathException.prototype.toString = function() {
	var msg = this.exception ? ": " + this.exception.toString() : "";
	switch (this.code) {
		case XPathException.INVALID_EXPRESSION_ERR:
			return "Invalid expression" + msg;
		case XPathException.TYPE_ERR:
			return "Type error" + msg;
	}
};

XPathException.INVALID_EXPRESSION_ERR = 51;
XPathException.TYPE_ERR = 52;

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t < 0 || t > 9) {
			throw { code: 0, toString: function() { return "Request type not supported"; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&& document.implementation.hasFeature
				&& document.implementation.hasFeature("XPath", null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

exports.XPathResult = XPathResult;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(typeof exports !== 'undefined' ? exports : xpath);

},{}],131:[function(require,module,exports){
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var htmlTags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'];
exports.htmlTags = htmlTags;

},{}],133:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var selectorsRegex = /(^\s*|}\s*|\s*)([@*.#\w\d\s-:\[\]\(\)="'>+~]+)(,|{[^}]+})/g;
var commentsRegex = /\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g; // http://ostermiller.org/findcomment.html

exports['default'] = function (styles, selector) {
	var selectorPattern = selector.replace(/([\[\]\(\)^$*+.,\{\}|?!:])/g, '\\$1');
	var prefixRegex = new RegExp(selectorPattern + '\\s', 'g');

	// Так как префикс проставляется абсолютно всему у чего имеется следующая
	// кострукция `aaa[, bbb] {}` для полного и правильного проставления префиксов
	// операция разбивается на несколько шагов:
	//
	// 1. Удаляем коментарии из исходного кода. Для работы стилей это не важно, но сильно
	//    поможет избежать проблем с неправильным срабатыванием префиксера.
	// 2. Проставляем префиксы.
	// 3. Обрабатываем кейс, когда у at-селекторов не может быть никаких префиксов.
	//    Более подробно об этом описано тут: https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face
	// 4. Обрабатываем кейс, когда первая регулярка могла заменить путь
	//    в конструкции `url()` востанавливая его в первоначальное значение.
	// 5. Так как считается что элемент с префикс-селектором у нас будет корневым
	//    элементом, то все селекторы :host заменяем на селектор префикса.
	return (styles || '').replace(commentsRegex, '').replace(selectorsRegex, '$1' + selector + ' $2$3')

	// Коректирующие пост-обработки
	.replace(new RegExp(selectorPattern + '\\s(@(charset|document|font-face|import|keyframes|media|page|supports))', 'g'), '$1').replace(/url\([^)]+\)/g, function (match) {
		return match.replace(prefixRegex, '');
	}).replace(new RegExp('(' + selectorPattern + ')\\s(:host)', 'g'), '$1').replace(new RegExp('(' + selectorPattern + ')([^{,]+)(:host)([^{,]+[{,])', 'g'), '$2$1$4');
};

module.exports = exports['default'];

},{}],134:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.nodesToArray = nodesToArray;
exports.isInDOM = isInDOM;
exports.toArray = toArray;
exports.createNode = createNode;
exports.createTextNode = createTextNode;
exports.generateUID = generateUID;
exports.capitalize = capitalize;
exports.HtmlAttrToUvdomAttr = HtmlAttrToUvdomAttr;
exports.UvdomAttrToHtmlAttr = UvdomAttrToHtmlAttr;
exports.isCommonElement = isCommonElement;
exports.parseNodeStyles = parseNodeStyles;
exports.hash = hash;

var _entities = require('./entities');

if (typeof window === 'undefined') {
	var jsdom = require('jsdom').jsdom;
	var jsWindow = jsdom().defaultView;
}

var _ref = jsWindow || window;

var HTMLCollection = _ref.HTMLCollection;
var NodeList = _ref.NodeList;
var document = _ref.document;
var btoa = _ref.btoa;

var counter = 0;

var eventNameRegex = /^on([a-z]+)$/;
exports.eventNameRegex = eventNameRegex;
var domTagNameRegex = /^([a-z]+:)?(h[1-6]|[a-z]+)$/;

exports.domTagNameRegex = domTagNameRegex;

function nodesToArray(nodes) {
	var list = [];

	if (nodes instanceof HTMLCollection || nodes instanceof NodeList) {
		list = list.concat(toArray(nodes));
	} else if (nodes) {
		list.push(nodes);
	}
	return list;
}

function isInDOM(node) {
	return document.body.contains(node);
}

function toArray() {
	var arr = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

	return Array.prototype.slice.call(arr, 0);
}

function createNode() {
	var name = arguments.length <= 0 || arguments[0] === undefined ? 'span' : arguments[0];

	return document.createElement(name);
}

function createTextNode() {
	var text = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	return document.createTextNode(text);
}

function generateUID() {
	return ++counter;
}

function capitalize(word) {
	word = '' + word;
	return word.charAt(0).toUpperCase() + word.slice(1);
}

// Стандартные html атрибуты которые пишутся через `-`.
var attrTransformExeptionList = ['http-equiv', 'accept-charset'];

// Кастомные атрибуты специфичные для dsl, которые не должны трансформироваться.
// [TODO] Нужно от этого избавиться.
attrTransformExeptionList = attrTransformExeptionList.concat(['bind-to-node']);

var attrsMapping = {
	'class': 'className'
};
var reverseAttrsMapping = {};

Object.keys(attrsMapping).forEach(function (attr) {
	return reverseAttrsMapping[attrsMapping[attr]] = attr;
});

function HtmlAttrToUvdomAttr(name) {
	if (~name.indexOf('-') && !/^data-.+$/.test(name) && attrTransformExeptionList.indexOf(name) < 0) {
		name = name.split('-').map(function (part, i) {
			return !i ? part : capitalize(part);
		}).join('');
	}
	return attrsMapping[name] || name;
}

function UvdomAttrToHtmlAttr(name) {
	if (reverseAttrsMapping[name]) {
		return reverseAttrsMapping[name];
	}

	if (! ~name.indexOf('-')) {
		name = name.split(/([A-Z]{2,}|[A-Z][^A-Z]+)/).filter(Boolean).map(function (item) {
			return item.toLowerCase();
		}).join('-');
	}
	return name;
}

function isCommonElement(tagName) {
	return domTagNameRegex.test(tagName) && (tagName.indexOf(':') > 0 || _entities.htmlTags.indexOf(tagName) >= 0);
}

function rulesForCssText(styleContent) {
	var styleElement = document.createElement('style');

	styleElement.textContent = styleContent;
	document.body.appendChild(styleElement);

	return styleElement.sheet.cssRules;
}

function parseNodeStyles(nodeName, styles) {
	var CSSStyleDeclaration = {};
	var styleDeclaration;

	if (jsWindow) {
		var rules = rulesForCssText(nodeName + ' { ' + styles + ' }');
		styleDeclaration = rules[0].style;
	} else {
		var targetNode = createNode(nodeName);
		targetNode.style.cssText = styles;
		styleDeclaration = targetNode.style;
	}

	for (var i = 0; i < styleDeclaration.length; i++) {
		var name = styleDeclaration[i];

		CSSStyleDeclaration[camelizeStyleName(name)] = styleDeclaration.getPropertyValue(name);
	}

	return CSSStyleDeclaration;
}

var hyphenPattern = /-(.)/g;
var msPattern = /^-ms-/;

function camelize(string) {
	return string.replace(hyphenPattern, function (_, character) {
		return character.toUpperCase();
	});
}

function camelizeStyleName(string) {
	return camelize(string.replace(msPattern, 'ms-'));
}

function hash() {
	var str = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	return str.split('').reduce(function (prev, value) {
		prev = (prev << 5) - prev + value.charCodeAt(0);
		return prev & prev;
	}, 0);
}

},{"./entities":132,"jsdom":undefined}],135:[function(require,module,exports){
'use strict';

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports['default'] = parser;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libUtils = require('./lib/utils');

var _transformsReact = require('./transforms/react');

var _transformsReact2 = _interopRequireDefault(_transformsReact);

var _transformsHtml = require('./transforms/html');

var _transformsHtml2 = _interopRequireDefault(_transformsHtml);

var _libPrefixStyles = require('./lib/prefix-styles');

var _libPrefixStyles2 = _interopRequireDefault(_libPrefixStyles);

var assign = require('object-assign');

var nodeTypes = {
	ELEMENT_NODE: 1,
	ATTRIBUTE_NODE: 2,
	TEXT_NODE: 3,
	CDATA_SECTION_NODE: 4,
	ENTITY_REFERENCE_NODE: 5,
	ENTITY_NODE: 6,
	PROCESSING_INSTRUCTION_NODE: 7,
	COMMENT_NODE: 8,
	DOCUMENT_NODE: 9,
	DOCUMENT_TYPE_NODE: 10,
	DOCUMENT_FRAGMENT_NODE: 11,
	NOTATION_NODE: 12
};

function parser() {
	var target = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	if (typeof target === 'string' && target) {
		var content = target;

		target = (0, _libUtils.createNode)();
		target.innerHTML = content;
		target.setAttribute('data-is-uvdoom-wrapper', true);
	} else if (typeof target.cloneNode !== 'function') {
		return {};
	}

	return parseNodes((0, _libUtils.nodesToArray)(target.cloneNode(true)), params);
}

assign(parser, {
	uvdomToReact: _transformsReact2['default'],
	uvdomToHTML: _transformsHtml2['default']
});

function parseNodes() {
	var _this = this;

	var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	var vNodes = [];

	nodes.forEach(function (node) {
		var vNode = {};

		if (node.nodeType === nodeTypes.ELEMENT_NODE) {
			var tagName = node.tagName.toLowerCase();

			if (typeof params.onTagNameResolve === 'function') {
				tagName = params.onTagNameResolve(node) || tagName;
			}

			if ((0, _libUtils.isCommonElement)(tagName)) {
				vNode.tag = tagName;
			} else {
				vNode.component = tagName;
			}

			if (node.hasAttributes()) {
				(0, _libUtils.toArray)(node.attributes).forEach(function (attr) {
					var name = attr.name;

					// Преобразовываем название атрибута в нотацию UVDOM.
					var value = attr.value;
					name = (0, _libUtils.HtmlAttrToUvdomAttr)(name);

					if (vNode.component && name === 'is') {
						vNode['extends'] = value;
					} else if (['key', 'ref'].indexOf(name) >= 0) {
						if (name === 'key') {
							value = parseInt(value, 10);
							isNaN(value) && (value = null);
						}
						value != null && (vNode[name] = value);
					} else if (_libUtils.eventNameRegex.test(name)) {
						var match = name.match(_libUtils.eventNameRegex);

						if (match) {
							vNode.events || (vNode.events = {});
							vNode.events[match[1]] = value;
						}
					} else {
						try {
							value = JSON.parse(value);
						} catch (e) {}

						if (name === 'style') {
							name = 'cssText';
						}

						vNode.attrs || (vNode.attrs = {});
						vNode.attrs[name] = value;
					}
				});
			}

			processNodeChildren(node, vNode, params);

			vNodes.push(assign(Object.create({
				toReact: _transformsReact2['default'].bind(_this, vNode),
				toHTML: _transformsHtml2['default'].bind(_this, vNode)
			}), vNode));
		} else if (node.nodeType === nodeTypes.TEXT_NODE) {
			var text = node.textContent.replace(/[\t\n\r]+/g, '');

			text && vNodes.push(text);
		} else if (node.nodeType === nodeTypes.DOCUMENT_FRAGMENT_NODE) {
			vNode.tag = 'document-fragment';
			processNodeChildren(node, vNode, params);
			vNodes.push(vNode);
		} else if ([nodeTypes.COMMENT_NODE, nodeTypes.CDATA_SECTION_NODE].indexOf(node.nodeType) < 0) {
			console.warn('Unhandled node type: ' + node.nodeType);
		}
	});

	if (!vNodes.length) {
		return null;
	}

	return vNodes.length > 1 ? vNodes : vNodes[0];
}

var shadowRootIds = [];
var shadowRootsCache = {};

function checkIfNodeIsText(node) {
	return node.tag === 'span' && typeof node.children === 'string' && (node.attrs == null || !Object.keys(node.attrs).length);
}

function processNodeChildren(node, vNode) {
	var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	if (node.childNodes) {
		var childNodes = parseNodes((0, _libUtils.nodesToArray)(node.childNodes), params);

		if (childNodes) {
			// В ИЕ если в тексте есть переносы строк, то текст разбивается на ноды.
			// Для унификации мерджим текстовые ноды.
			if (Array.isArray(childNodes)) {
				if (childNodes.some(function (node) {
					return !checkIfNodeIsText(node);
				})) {
					var mergedChildNodes = [];

					childNodes.forEach(function (node) {
						if (checkIfNodeIsText(node)) {
							var prevIndex = mergedChildNodes.length - 1;
							var prev = mergedChildNodes[prevIndex];

							if (typeof prev === 'string') {
								mergedChildNodes[prevIndex] += node.children;
							} else {
								mergedChildNodes.push(node.children);
							}
						} else {
							mergedChildNodes.push(node);
						}
					});

					childNodes = mergedChildNodes;
					mergedChildNodes = void 0;
				} else {
					childNodes = childNodes.reduce(function (prev, next) {
						return (prev.children || prev) + next.children;
					});
				}
			}

			vNode.children = childNodes;

			var styles = [].concat(childNodes).filter(function (child) {
				return child.tag === 'style';
			});

			if (!styles.length) {
				return vNode;
			}

			styles = styles.map(unifyStylesContent).reduce(function (prev, next) {
				var nextIndex = childNodes.indexOf(next);

				if (~nextIndex) {
					childNodes.splice(nextIndex, 1);
				}

				prev.children += next.children;
				return prev;
			});

			if (styles && !Object.keys(shadowRootsCache).some(function (shadowRootId) {
				return styles.children === shadowRootsCache[shadowRootId];
			})) {
				var shadowRootStylesHash = (0, _libUtils.hash)(styles.children);
				var shadowRootId = shadowRootIds.indexOf(shadowRootStylesHash);

				if (! ~shadowRootId) {
					shadowRootId = shadowRootIds.push(shadowRootStylesHash) - 1;
				}

				styles.children = (0, _libPrefixStyles2['default'])(styles.children, '[data-shadow-root-id="' + shadowRootId + '"]');
				shadowRootsCache[shadowRootId] = styles.children;

				// Если у ноды есть shadow-root id, то создаем враппер с этим айди, на который и будут
				// завязаны стили.
				vNode.children = {
					tag: 'span',
					attrs: {
						'data-shadow-root-id': shadowRootId
					},
					children: vNode.children
				};
			}
		}
	}
	return vNode;
}

// IE по некоторым причинам может дробить текстовые ноды на множество нод.
// Чтоб небыло проблем делаем их объединение в одну строку.
function unifyStylesContent(node) {
	if (Array.isArray(node.children)) {
		node.children = node.children.join('');
	}
	return node;
}
module.exports = exports['default'];

},{"./lib/prefix-styles":133,"./lib/utils":134,"./transforms/html":137,"./transforms/react":138,"object-assign":135}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _libUtils = require('../lib/utils');

var assign = require('object-assign');

exports['default'] = function (uvdom, params) {
	if (typeof uvdom === 'object' && !Array.isArray(uvdom)) {
		var type = uvdom.tag || uvdom.component;

		if (typeof type === 'string' && type) {
			return toHTML(params, uvdom);
		}
	}
	return null;
};

function toHTML(params, uvdom) {
	if (params === undefined) params = {};

	var processNodes = toHTML.bind(this, params);

	if (Array.isArray(uvdom)) {
		if (uvdom.length === 1) {
			return processNodes(uvdom[0]);
		}
		return uvdom.map(processNodes);
	} else if (uvdom != null && typeof uvdom === 'object') {
		var type = typeof params.onTypeNameResolve === 'function' ? params.onTypeNameResolve(uvdom) : uvdom.tag || uvdom.component;
		var children = processNodes(uvdom.children);
		var node = (0, _libUtils.createNode)(type);

		if (Array.isArray(children)) {
			children.map(processTextNode).forEach(function (child) {
				node.appendChild(child);
			});
		} else if (children != null) {
			node.appendChild(processTextNode(children));
		}

		if (uvdom.events) {
			Object.keys(uvdom.events).forEach(function (eventName) {
				node.setAttribute('on' + eventName, uvdom.events[eventName]);
			});
		}

		if (uvdom.attrs) {
			Object.keys(uvdom.attrs).forEach(function (attr) {
				if (attr === 'style') {
					return;
				} else if (attr === 'cssText') {
					return node.setAttribute('style', uvdom.attrs[attr]);
				}
				node.setAttribute((0, _libUtils.UvdomAttrToHtmlAttr)(attr), uvdom.attrs[attr]);
			});
		}

		['key', 'ref'].forEach(function (prop) {
			prop in uvdom && node.setAttribute(prop, uvdom[prop]);
		});

		return node;
	}
	return uvdom;
}

function processTextNode(node) {
	if (typeof node === 'string') {
		return (0, _libUtils.createTextNode)(node);
	}
	return node;
}
module.exports = exports['default'];

},{"../lib/utils":134,"object-assign":135}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var _slice = Array.prototype.slice;

var _reactEvents = require('./react/events');

var _libUtils = require('../lib/utils');

var assign = require('object-assign');

var tagsMapping = {
	'document-fragment': 'span'
};

exports['default'] = function (uvdom, params) {
	if (typeof uvdom === 'object' && !Array.isArray(uvdom)) {
		var type = uvdom.tag || uvdom.component;

		if (typeof type === 'string' && type) {
			return toReact(params, uvdom);
		}
	}
	return null;
};

function overrideProps() {
	var props = {};
	assign.apply(undefined, [props].concat(_slice.call(arguments)));

	var excludeList = ['extends', 'children'];
	var result = assign(Object.create(this), this, {
		props: assign({}, this.props)
	});

	Object.keys(props).forEach(function (propName) {
		if (props[propName] && excludeList.indexOf(propName) < 0) {
			result.props[propName] = props[propName];
		}
	});

	var propsChildrenMap = {};

	[].concat(props.children).filter(function (child) {
		return child;
	}).forEach(function (child) {
		child.type && (propsChildrenMap[child.type] = child);
	});

	var children = [].concat(this.props.children).map(function (child) {
		var propsChild = propsChildrenMap[child.type];
		var result = undefined;

		if (propsChild) {
			result = assign({}, child, propsChild);
			delete propsChildrenMap[child.type];
		}

		return result || child;
	});

	var newChildList = Object.keys(propsChildrenMap);

	if (newChildList.length) {
		children = children.concat(newChildList.map(function (name) {
			return propsChildrenMap[name];
		}));
	}

	if (children.length > 0) {
		result.props.children = children.length === 1 ? children[0] : children;
	}

	return result;
}

function toReact(params, uvdom) {
	if (params === undefined) params = {};
	var mapper = params.mapper;
	var owner = params.owner;

	var processNodes = toReact.bind(this, params);

	// Чтоб отрисовать реактовский компонент необходимо нужно у ReactElement получить его `type`
	// который и передается в рендеринг.
	// Если у переданного компонента нет свойства `type`, то считаем что это не валидный
	// ReactElement. Другие проверки делать нет смысла.
	if (typeof mapper === 'object') {
		mapper = (function (mapping) {
			return function (name) {
				return (mapping[name] || {}).type;
			};
		})(mapper);
	} else if (typeof mapper === 'function') {
		mapper = (function (originalMapper) {
			return function (name, node) {
				return (originalMapper(name, node) || {}).type;
			};
		})(mapper);
	} else if (typeof mapper !== 'function') {
		mapper = function () {
			return null;
		};
	}

	if (Array.isArray(uvdom)) {
		if (uvdom.length === 1) {
			return processNodes(uvdom[0]);
		}
		return uvdom.map(processNodes);
	} else if (uvdom != null && typeof uvdom === 'object') {
		var type = typeof params.onTypeNameResolve === 'function' ? params.onTypeNameResolve(uvdom) : tagsMapping[uvdom.tag] || uvdom.tag || mapper(uvdom.component, uvdom) || uvdom.component;
		var children = processNodes(uvdom.children);
		var props = {};

		if (children) {
			props.children = children;
		}

		if (uvdom['extends']) {
			props['extends'] = uvdom['extends'];
		}

		var events = {};

		if (uvdom.events) {
			Object.keys(uvdom.events).forEach(function (eventName) {
				var nativeEventName = 'on' + eventName;
				var reactEvent = _reactEvents.eventsMap[nativeEventName];

				events[reactEvent || nativeEventName] = uvdom.events[eventName];
			});
		}

		var attrs = assign({}, uvdom.attrs);

		// Стили должны быть представлены в виде CSSStyleDeclaration.
		if (typeof type === 'string' && attrs.cssText) {
			attrs.style = (0, _libUtils.parseNodeStyles)(type, attrs.cssText);
			delete attrs.cssText;
		}

		// Минимальный контракт компонента, который будет принят react.js без ошибок это:
		// {
		//     type: 'span',
		//     props: {},
		//     _store: {},
		//     _owner: {}, // Необходим для использования референса
		//     _isReactElement: true
		// }
		var component = {
			type: type,
			props: assign(props, events, attrs),
			_store: {},
			_owner: {},
			_isReactElement: true
		};

		['key', 'ref'].forEach(function (prop) {
			return prop in uvdom && (component[prop] = uvdom[prop]);
		});

		if (component.ref && !owner) {
			console.warn('You should pass component as "owner" param to be able to user references');
		}

		if (owner) {
			component._owner = owner;
		}

		if (component.type === 'style') {
			component.props.dangerouslySetInnerHTML = {
				__html: component.props.children
			};
			delete component.props.children;
		}

		return assign(Object.create({
			overrideProps: overrideProps
		}), component);
	}
	return uvdom;
}
module.exports = exports['default'];

},{"../lib/utils":134,"./react/events":139,"object-assign":135}],139:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var eventsMap = {
	oncopy: 'onCopy',
	oncut: 'onCut',
	onpaste: 'onPaste',
	onkeydown: 'onKeyDown',
	onkeypress: 'onKeyPress',
	onkeyup: 'onKeyUp',
	onfocus: 'onFocus',
	onblur: 'onBlur',
	onchange: 'onChange',
	oninput: 'onInput',
	onsubmit: 'onSubmit',
	onclick: 'onClick',
	oncontextmenu: 'onContextMenu',
	ondoubleclick: 'onDoubleClick',
	ondrag: 'onDrag',
	ondragend: 'onDragEnd',
	ondragenter: 'onDragEnter',
	ondragexit: 'onDragExit',
	ondragleave: 'onDragLeave',
	ondragover: 'onDragOver',
	ondragstart: 'onDragStart',
	ondrop: 'onDrop',
	onmousedown: 'onMouseDown',
	onmouseenter: 'onMouseEnter',
	onmouseleave: 'onMouseLeave',
	onmousemove: 'onMouseMove',
	onmouseout: 'onMouseOut',
	onmouseover: 'onMouseOver',
	onmouseup: 'onMouseUp',
	ontouchcancel: 'onTouchCancel',
	ontouchend: 'onTouchEnd',
	ontouchmove: 'onTouchMove',
	ontouchstart: 'onTouchStart',
	onscroll: 'onScroll',
	onwheel: 'onWheel'
};
exports.eventsMap = eventsMap;

},{}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _skatejsSrcSkate = require('skatejs/src/skate');

var _skatejsSrcSkate2 = _interopRequireDefault(_skatejsSrcSkate);

var _uvdoomLibUtils = require('uvdoom/lib/utils');

var _skatejsSrcMutationObserver = require('skatejs/src/mutation-observer');

var _skatejsSrcMutationObserver2 = _interopRequireDefault(_skatejsSrcMutationObserver);

var _libUtils = require('./lib/utils');

var _renderer = require('./renderer');

var _renderer2 = _interopRequireDefault(_renderer);

var _template = require('./template');

var _template2 = _interopRequireDefault(_template);

var _model = require('./model');

var _model2 = _interopRequireDefault(_model);

var _dependencyResolver = require('./dependencyResolver');

var _componentSpecification = require('./component/specification');

exports['default'] = function (params) {
	var scripts = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

	if (typeof scripts === 'function') {
		scripts = [scripts];
	}

	return (0, _dependencyResolver.resolve)((0, _libUtils.assign)((0, _libUtils.deepCopy)(_componentSpecification.defaults), params)).then(function (instance) {
		scripts.forEach(function (script) {
			return script.call(instance);
		});

		var componentProto = gatherUserContract(instance, _componentSpecification.defaults);
		var Model = (0, _model2['default'])(instance.name);
		var attributes = {};

		instance.hostAttributes.forEach(function (attrName) {
			attributes[attrName] = function (element, change) {
				// Если по каким-то причинам модель не была готова, то даже не пытаемся
				// обрабатывать атрибуты.
				if (element.modelNode == null) {
					return;
				}

				var name = change.name;
				var newValue = change.newValue;

				var property = element.modelNode.querySelector('content[name="' + name + '"]');

				if (property && property.textContent != newValue) {
					property.textContent = newValue;
				}
			};
		});

		var HTMLCustomElement = (0, _skatejsSrcSkate2['default'])(instance.name, {
			prototype: (0, _libUtils.assign)({
				template: instance.template
			}, componentProto, {
				_attached: false,
				_ready: false,

				renderNode: null,
				modelNode: null,
				render: null,

				renderModel: function renderModel(force) {
					var _this = this;

					var renderingTree;

					// Если мы мы поменяли в модели то что не отслеживается
					// MutationObserver (например атрибуты у потомков), то force поможет
					// при рендеринге сбросить кеш в модели.
					if (force) {
						this.modelNode.flushDump();
					}

					// Шаблон может быть как функцией так и UVDOM деревом.
					// Если шаблон – функция, то передаем ему модель и ждем на выходе
					// преобразованное UVDOM дерево.
					// Если шаблон – UVDOM дерево, то отправляем его и модель на преобразование
					// в XSL шаблонизатор.
					if (this.template == null) {
						return (0, _libUtils.warning)('Unable to locate template for "%s" component', instance.name);
					} else if (typeof this.template === 'function') {
						renderingTree = this.template((0, _libUtils.resolveModelRefs)(this.modelNode.dump()));
					} else if (this.template.children != null) {
						renderingTree = (0, _template2['default'])(this.template, (0, _libUtils.resolveModelRefs)(this.modelNode.dump()));
					}

					// Отправляем полученное UVDOM дерево на отрисовку.
					renderingTree && this.render(renderingTree, function () {
						typeof instance.rendered === 'function' && instance.rendered.call(_this);
						!_this._ready && typeof instance.ready === 'function' && instance.ready.call(_this);
						_this._ready = true;
					});
				}
			}),

			attributes: attributes,

			events: instance.events,

			template: function template(element) {
				if (element.modelNode != null) {
					return;
				}

				var outerModel = (0, _libUtils.HTMLtoModel)(element);
				var attrModel = {};

				// Собираем пользовательские атрибуты.
				instance.hostAttributes.forEach(function (attrName) {
					var attrValue = element.getAttribute(attrName);

					if (attrValue) {
						attrModel[attrName] = attrValue;
					}
				});

				var model = (0, _libUtils.assign)({}, instance.model, outerModel, attrModel);

				element.modelNode = new Model();
				element.modelNode.addEventListener('model-changed', onModelChange.bind(element, instance));
				element.modelNode.fill(model);
				element.modelNode.resume();

				// Делаем автобинд контекста к пользовательским методам.
				Object.keys(componentProto).forEach(function (methodName) {
					element[methodName] = element[methodName].bind(element);
				});

				typeof instance.prepare === 'function' && instance.prepare.call(element);
			},

			created: function created(element) {
				// При клонировании элемента вызывает хук `created` но не вызывается `template`,
				// поэтому делаем это самостоятельно.
				if (element.modelNode == null) {
					this.template(element);
				}

				// Если это повторный вызов метода из-за не консистентности поведения в разных
				// браузерах, то проверяем условия необходимые для правильной условии если они
				// выполняются, то выходим их метода.
				if (element.renderNode && element.contains(element.renderNode) && element.contains(element.modelNode)) {
					return;
				}

				clearContent(element);

				element.renderNode = document.createElement(instance.name + '-view');
				element.render = (0, _renderer2['default'])(element.renderNode);

				element.appendChild(element.renderNode);
				element.appendChild(element.modelNode);

				// Реализовываем специальное поведение у компонентов. В качестве childNodes
				// компонент может содержать только вью и модель. Для остальных элементов
				// применяются следующие правила:
				// 1. Если нода является тегом, имеет `nodeName` == 'content' и атрибут `name`,
				//    то ее переносим в модель;
				// 2. В остальных случаях выносим ноду за пределы компонента. Помещая ее сразу
				//    после компонента (`nextSibling`).
				var observer = new _skatejsSrcMutationObserver2['default'](function (mutations) {
					mutations.filter(Boolean).forEach(function (mutation) {
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = mutation.addedNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var node = _step.value;

								if (node.nodeName.toLowerCase() === 'content') {
									var propName = node.getAttribute('name');

									if (propName == null) {
										return moveChildAwayFromNode(node);
									}

									var modelProp = element.modelNode.querySelector('content[name="' + propName + '"]');

									if (modelProp) {
										element.modelNode.replaceChild(node, modelProp);
									} else {
										element.modelNode.appendChild(node);
									}
									return;
								}
								moveChildAwayFromNode(node);
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					});
				});

				observer.observe(element, {
					childList: true
				});

				typeof instance.created === 'function' && instance.created.call(element);
			},

			attached: function attached(element) {
				// Бывает что в некоторых браузерах attach происходит раньше create, поэтому
				// убеждаемся что пайплайн создания компонента не нарушен.
				if (element.modelNode == null) {
					this.created(element);
				}

				element._attached = true;
				element.renderModel();
				typeof instance.attached === 'function' && instance.attached.call(element);
			},

			detached: function detached(element) {
				element._attached = false;
				typeof instance.detached === 'function' && instance.detached.call(element);
			}
		});

		typeof instance.registered === 'function' && instance.registered(HTMLCustomElement);
	})['catch'](function (error) {
		return console.error(error);
	});
};

function onModelChange(instance, event) {
	var _this2 = this;

	this._attached && this.renderModel();

	if (typeof instance.modelChanged === 'function') {
		var _event$detail = event.detail;
		var prevSnapshot = _event$detail.prevSnapshot;
		var newSnapshot = _event$detail.newSnapshot;
		var stringify = JSON.stringify;

		Object.keys(newSnapshot).map(function (propName) {
			if (stringify(prevSnapshot[propName]) != stringify(newSnapshot[propName])) {
				return propName;
			}
		}).filter(Boolean).map(function (propName) {
			var prevValue = (0, _libUtils.ModelAttrToHTML)(prevSnapshot, propName);
			var value = _this2.modelNode.querySelector('content[name="' + propName + '"]');

			return {
				propName: propName,
				prevValue: prevValue,
				value: value
			};
		}).forEach(function (payload) {
			var propName = payload.propName;
			var prevValue = payload.prevValue;
			var value = payload.value;

			instance.modelChanged.call(_this2, propName, prevValue, value);
		});
	}
}

function gatherUserContract(instance, defaults) {
	var userContract = {};

	Object.keys(instance).forEach(function (key) {
		if (!(key in defaults)) {
			userContract[key] = instance[key];
		}
	});

	return userContract;
}

function clearContent(node) {
	(0, _uvdoomLibUtils.nodesToArray)(node.childNodes).forEach(function (child) {
		return node.removeChild(child);
	});
}

function moveChildAwayFromNode(child) {
	var parent = child.parentNode;

	if (parent.nextSibling) {
		parent.parentNode.insertBefore(child, parent.nextSibling);
	} else {
		parent.parentNode.appendChild(child);
	}
}
module.exports = exports['default'];

},{"./component/specification":141,"./dependencyResolver":142,"./lib/utils":144,"./model":145,"./renderer":146,"./template":148,"skatejs/src/mutation-observer":109,"skatejs/src/skate":111,"uvdoom/lib/utils":134}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.merge = merge;

var _libUtils = require('../lib/utils');

var defaults = {
	name: null,
	'extends': null,
	events: {},
	hostAttributes: [],
	model: null,
	template: null,
	prepare: null,
	created: null,
	attached: null,
	rendered: null,
	ready: null,
	detached: null,
	modelChanged: null,

	_addEvent: function _addEvent(event, selector, handler) {
		this.events || (this.events = {});
		this.events[[event, selector].join(' ')] = handler;
	},

	_addFeature: function _addFeature(feature) {
		(0, _libUtils.assign)(this, feature);
	}
};

exports.defaults = defaults;
var inactiveComponentPostfix = '-definition';
exports.inactiveComponentPostfix = inactiveComponentPostfix;
var inactiveComponentNameRegexp = new RegExp(inactiveComponentPostfix + '$');
exports.inactiveComponentNameRegexp = inactiveComponentNameRegexp;
var inactiveComponentRefDataAttr = 'data-reference-name';

exports.inactiveComponentRefDataAttr = inactiveComponentRefDataAttr;

function merge(base, target) {
	var events = batchHandlers(base.events, target.events, Object.keys((0, _libUtils.assign)({}, base.events, target.events)));
	var lifecycleMethods = batchHandlers(base, target, ['prepare', 'created', 'attached', 'rendered', 'ready', 'detached', 'modelChanged']);
	var duplicates = [];
	var hostAttributes = [].concat(base.hostAttributes, target.hostAttributes).filter(Boolean).filter(function (attrName) {
		if (! ~duplicates.indexOf(attrName)) {
			duplicates.push(attrName);
			return true;
		}
	});

	return (0, _libUtils.assign)({}, base, target, {
		events: events,
		hostAttributes: hostAttributes,
		model: (0, _libUtils.assign)({}, base.model, target.model),
		template: base.template
	}, lifecycleMethods);
}

function batchHandlers(base, target, propList) {
	var result = {};

	propList.forEach(function (prop) {
		if (base[prop] && target[prop]) {
			result[prop] = function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				base[prop].apply(this, args);
				target[prop].apply(this, args);
			};
		} else {
			result[prop] = base[prop] || target[prop];
		}
	});

	return result;
}

},{"../lib/utils":144}],142:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.resolve = resolve;
exports.get = get;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libPromise = require('./lib/promise');

var _libPromise2 = _interopRequireDefault(_libPromise);

var _componentSpecification = require('./component/specification');

var _libUtils = require('./lib/utils');

var registry = {};
var listeners = {};

function resolve(instance) {
	return new _libPromise2['default'](function (resolve) {
		if (instance['extends']) {
			return waitFor(instance['extends']).then(function (instanceToExtend) {
				resolve((0, _componentSpecification.merge)(instanceToExtend, instance));
			});
		}
		resolve(instance);
	}).then(function (resolvedInstance) {
		return set(resolvedInstance);
	});
}

function get(id) {
	return registry[id];
}

function set(instance) {
	var id = instance.name;

	if (registry[id] == null) {
		registry[id] = instance;
		listeners[id] && listeners[id].resolve(instance);
		return instance;
	}
	throw new Error('Instance of ' + instance.name + ' already exists.');
}

function waitFor(id) {
	var isFirstListener = false;

	if (!listeners[id]) {
		listeners[id] = (0, _libUtils.defer)();
		isFirstListener = true;
	}
	return new _libPromise2['default'](function (resolve) {
		var targetInstance = get(id);

		listeners[id].chain(resolve);

		if (targetInstance && isFirstListener) {
			listeners[id].resolve(targetInstance);
		}
	});
}

},{"./component/specification":141,"./lib/promise":143,"./lib/utils":144}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _es6PromiseLibEs6PromisePromise = require('es6-promise/lib/es6-promise/promise');

var _es6PromiseLibEs6PromisePromise2 = _interopRequireDefault(_es6PromiseLibEs6PromisePromise);

exports['default'] = typeof Promise !== 'undefined' ? Promise : _es6PromiseLibEs6PromisePromise2['default'];
module.exports = exports['default'];

},{"es6-promise/lib/es6-promise/promise":98}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.assign = assign;
exports.warning = warning;
exports.deepCopy = deepCopy;
exports.HTMLtoModel = HTMLtoModel;
exports.ModelAttrToHTML = ModelAttrToHTML;
exports.ModelToHTML = ModelToHTML;
exports.findRootPropertyNode = findRootPropertyNode;
exports.resolveModelRefs = resolveModelRefs;
exports.defer = defer;
exports.createEvent = createEvent;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _uvdoomParser = require('uvdoom/parser');

var _uvdoomParser2 = _interopRequireDefault(_uvdoomParser);

var _skatejsSrcRegistry = require('skatejs/src/registry');

var _skatejsSrcRegistry2 = _interopRequireDefault(_skatejsSrcRegistry);

var _uvdoomLibUtils = require('uvdoom/lib/utils');

var _componentSpecification = require('../component/specification');

var _promise = require('./promise');

var _promise2 = _interopRequireDefault(_promise);

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function assign(target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			try {
				to[keys[i]] = from[keys[i]];
			} catch (e) {}
		}
	}

	return to;
}

function warning(format) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		args[_key - 1] = arguments[_key];
	}

	var argIndex = 0;

	console.warn('Warning: ' + format.replace(/%s/g, function () {
		return args[argIndex++];
	}));
}

// Быстрая реализация глубокого клонирования с поддержкой многих типов.
// Код взят из http://stackoverflow.com/a/1042676/896280

function deepCopy(target) {
	if (target == null || typeof target != 'object') {
		return target;
	}

	if (target.constructor != Object && target.constructor != Array) {
		return target;
	}

	if (~[Date, RegExp, Function, String, Number, Boolean].indexOf(target.constructor)) {
		return new target.constructor(target);
	}

	var result = new target.constructor();

	for (var name in target) {
		result[name] = typeof result[name] === 'undefined' ? deepCopy(target[name]) : result[name];
	}

	return result;
}

function HTMLtoModel(node) {
	var model = {};

	(0, _uvdoomLibUtils.nodesToArray)(node.childNodes).forEach(function (child) {
		if (child.nodeType === Node.ELEMENT_NODE) {
			var property = (0, _uvdoomParser2['default'])(child, {
				onTagNameResolve: function onTagNameResolve(node) {
					node.removeAttribute('data-reactid');
					return node.tagName.toLowerCase();
				}
			});

			var _ref = property.attrs || {};

			var name = _ref.name;

			if (property.component === 'content' && name) {
				model[name] = property.children;
			}
		}
	});

	return model;
}

function ModelAttrToHTML(model, attrName) {
	return ModelToHTML(model).querySelector('content[name="' + attrName + '"]');
}

function uvdomNodeToRef(node, name) {
	node.attrs || (node.attrs = {});
	node.attrs[_componentSpecification.inactiveComponentRefDataAttr] = name;
	return name + _componentSpecification.inactiveComponentPostfix;
}

function ModelToHTML(model) {
	var fragment = document.createDocumentFragment();

	Object.keys(model).forEach(function (name) {
		var uvdomNode = {
			component: 'content',
			attrs: {
				name: name
			},
			children: model[name]
		};

		fragment.appendChild(_uvdoomParser2['default'].uvdomToHTML(uvdomNode, {
			onTypeNameResolve: function onTypeNameResolve(uvdomNode) {
				var tag = uvdomNode.tag;

				// Обрабатываем кастомные элементы модели. Они не должны инициализироваться
				// и должны быть максимально инертны.
				// [TODO] Добавить обработку тегов, которые загружают внешние ресурсы (img и т.д.).
				// Их тоже необходимо сделать инертными в модели.
				var component = uvdomNode.component;
				if (component != null && _skatejsSrcRegistry2['default'].get(component)) {
					return uvdomNodeToRef(uvdomNode, component);
				} else if (tag != null && ~['style', 'script'].indexOf(tag)) {
					return uvdomNodeToRef(uvdomNode, tag);
				}

				return tag || component;
			}
		}));
	});

	return fragment;
}

function findRootPropertyNode(_x) {
	var _again = true;

	_function: while (_again) {
		var node = _x;
		tagName = undefined;
		_again = false;

		if (node == null || node.nodeType == null) {
			return node;
		}

		var tagName = node.tagName;

		if (tagName && tagName.toLowerCase() === 'content' && node.hasAttribute('name')) {
			return node;
		}

		if (node.parentNode != null) {
			_x = node.parentNode;
			_again = true;
			continue _function;
		}
	}
}

function resolveModelRefs(model) {
	var modelFragment = ModelToHTML(model);
	var selectNodes = (0, _uvdoomLibUtils.nodesToArray)(modelFragment.querySelectorAll('content[select]'));

	for (var i = 0; i < selectNodes.length; i++) {
		var element = selectNodes[i];
		var target = modelFragment.querySelector('content[name="' + element.getAttribute('select') + '"]');

		if (target) {
			var targetClone = target.cloneNode(true);
			var targetPlaceholders = targetClone.querySelectorAll('content:not([select]):not([ref]):not([name])');
			var children = (0, _uvdoomLibUtils.nodesToArray)(element.cloneNode(true).childNodes);

			if (children.length && targetPlaceholders.length) {
				(0, _uvdoomLibUtils.nodesToArray)(targetPlaceholders).forEach(function (node) {
					children.forEach(function (child) {
						node.parentNode.insertBefore(child, node);
					});
					node.parentNode.removeChild(node);
				});
			}

			var innerSelectNodes = (0, _uvdoomLibUtils.nodesToArray)(targetClone.querySelectorAll('content[select]'));

			if (innerSelectNodes) {
				selectNodes = selectNodes.concat(innerSelectNodes);
			}

			(0, _uvdoomLibUtils.nodesToArray)(targetClone.childNodes).forEach(function (child) {
				element.parentNode.insertBefore(child, element);
			});
			element.parentNode.removeChild(element);
		}
	}

	(0, _uvdoomLibUtils.nodesToArray)(modelFragment.querySelectorAll('content[select]')).forEach(function (element) {
		var target = modelFragment.querySelector('content[name="' + element.getAttribute('select') + '"]');

		if (target) {
			var targetClone = target.cloneNode(true);
			var targetPlaceholders = targetClone.querySelectorAll('content:not([select]):not([ref]):not([name])');
			var children = (0, _uvdoomLibUtils.nodesToArray)(element.cloneNode(true).childNodes);

			if (children.length && targetPlaceholders.length) {
				(0, _uvdoomLibUtils.nodesToArray)(targetPlaceholders).forEach(function (node) {
					children.forEach(function (child) {
						node.parentNode.insertBefore(child, node);
					});
					node.parentNode.removeChild(node);
				});
			}

			(0, _uvdoomLibUtils.nodesToArray)(targetClone.childNodes).forEach(function (child) {
				element.parentNode.insertBefore(child, element);
			});
			element.parentNode.removeChild(element);
		}
	});

	(0, _uvdoomLibUtils.nodesToArray)(modelFragment.querySelectorAll('content[ref]')).forEach(function (element) {
		var target = modelFragment.querySelector('content[name="' + element.getAttribute('ref') + '"]');

		if (target) {
			(0, _uvdoomLibUtils.nodesToArray)(target.cloneNode(true).childNodes).forEach(function (child) {
				element.appendChild(child);
			});
			element.removeAttribute('ref');
		}
	});

	return HTMLtoModel(modelFragment);
}

function defer() {
	var deferred = {};

	deferred.promise = new _promise2['default'](function (resolve, reject) {
		deferred.resolve = resolve;
		deferred.reject = reject;
	});

	deferred.chain = function (handler) {
		deferred.promise = deferred.promise.then(function (data) {
			handler(data);
			return data;
		});
	};

	return deferred;
}

// Шим для CustomEvent (IE > 9)

function createEvent(name, params) {
	var event;

	params = assign({
		bubbles: false,
		cancelable: false,
		detail: undefined
	}, params);

	try {
		event = new CustomEvent(name, params);
	} catch (e) {
		event = document.createEvent('CustomEvent');
		event.initCustomEvent(name, params.bubbles, params.cancelable, params.detail);
	}

	return event;
}

},{"../component/specification":141,"./promise":143,"skatejs/src/registry":110,"uvdoom/lib/utils":134,"uvdoom/parser":136}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _skatejsSrcSkate = require('skatejs/src/skate');

var _skatejsSrcSkate2 = _interopRequireDefault(_skatejsSrcSkate);

var _skatejsSrcMutationObserver = require('skatejs/src/mutation-observer');

var _skatejsSrcMutationObserver2 = _interopRequireDefault(_skatejsSrcMutationObserver);

var _uvdoomParser = require('uvdoom/parser');

var _uvdoomParser2 = _interopRequireDefault(_uvdoomParser);

var _libUtils = require('./lib/utils');

exports['default'] = function (instanceName) {
	var modelName = (instanceName || 'unknown') + '-model';

	return (0, _skatejsSrcSkate2['default'])(modelName, {
		prototype: {
			_dump: null,

			dispatcher: null,
			observer: null,

			get: function get(name, selector) {
				if (name === undefined) name = '';

				var result = this.querySelector('content[name="' + name + '"]');

				if (selector) {
					result = result.querySelector(selector);
				}
				return result;
			},

			getValue: function getValue(name) {
				var prop = this.get(name);

				if (prop == null) {
					return;
				}
				return prop.textContent;
			},

			dump: function dump() {
				this._dump || (this._dump = (0, _libUtils.HTMLtoModel)(this));
				return this._dump;
			},

			flushDump: function flushDump() {
				this._dump = null;
			},

			fill: function fill(model) {
				this.appendChild((0, _libUtils.ModelToHTML)(model));
			},

			suspend: function suspend() {
				this.observer != null && this.observer.disconnect();
				this.observer = null;
			},

			resume: function resume() {
				this.observer != null && this.suspend();
				this.observer = new _skatejsSrcMutationObserver2['default'](this.dispatcher);
				this.observer.observe(this, {
					childList: true,
					subtree: true
				});
			},

			batchUpdate: function batchUpdate(updater) {
				if (typeof updater === 'function') {
					this.suspend();
					updater.call(this);
					this.resume();
					this.dispatcher();
				}
			}
		},

		template: function template(element) {
			element.style.display = 'none';
		},

		created: function created(element) {
			element.dispatcher = dispatcher.bind(element);
		}
	});
};

function dispatcher() {
	var mutations = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

	var prevSnapshot = this.dump();
	var newSnapshot;

	this.flushDump();
	newSnapshot = this.dump();

	var event = (0, _libUtils.createEvent)('model-changed', {
		detail: {
			prevSnapshot: prevSnapshot,
			newSnapshot: newSnapshot,
			mutations: mutations
		}
	});

	this.dispatchEvent(event);
}
module.exports = exports['default'];

},{"./lib/utils":144,"skatejs/src/mutation-observer":109,"skatejs/src/skate":111,"uvdoom/parser":136}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _uvdoomParser = require('uvdoom/parser');

var _uvdoomParser2 = _interopRequireDefault(_uvdoomParser);

var _rendererDefault = require('./renderer/default');

var _rendererDefault2 = _interopRequireDefault(_rendererDefault);

var _libUtils = require('./lib/utils');

var renderer = _rendererDefault2['default'];

var render = function render(target) {
	return function (uvdom, done) {
		return renderer(target, uvdom, done, _uvdoomParser2['default']);
	};
};

exports['default'] = (0, _libUtils.assign)(render, {
	'default': _rendererDefault2['default'],

	register: function register(customRenderer) {
		if (typeof customRenderer === 'function') {
			renderer = customRenderer;
		}
		return this;
	}
});
module.exports = exports['default'];

},{"./lib/utils":144,"./renderer/default":147,"uvdoom/parser":136}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _uvdoomParser = require('uvdoom/parser');

var _uvdoomParser2 = _interopRequireDefault(_uvdoomParser);

exports['default'] = function (target, uvdom, done) {
	target.innerHTML = '';
	target.appendChild(_uvdoomParser2['default'].uvdomToHTML(uvdom));
	done();
};

module.exports = exports['default'];

},{"uvdoom/parser":136}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _templateProtoLibContextTemplate = require('template-proto/lib/context/template');

var _templateProtoLibContextTemplate2 = _interopRequireDefault(_templateProtoLibContextTemplate);

var _templateProtoLibDomDocument = require('template-proto/lib/dom/document');

var _templateProtoLibDomDocument2 = _interopRequireDefault(_templateProtoLibDomDocument);

var _templateProtoLibDomElement = require('template-proto/lib/dom/element');

var _templateProtoLibDomElement2 = _interopRequireDefault(_templateProtoLibDomElement);

var _templateProtoLibDomText = require('template-proto/lib/dom/text');

var _templateProtoLibDomText2 = _interopRequireDefault(_templateProtoLibDomText);

var _uvdoomLibUtils = require('uvdoom/lib/utils');

var _uvdoomParser = require('uvdoom/parser');

var _uvdoomParser2 = _interopRequireDefault(_uvdoomParser);

var _componentSpecification = require('./component/specification');

exports['default'] = function (templateUVDOM, modelUVDOM) {
	var templateXml = parseUVDOM(templateUVDOM);
	var modelXml = parseModel(modelUVDOM);

	var template = new _templateProtoLibContextTemplate2['default'](templateXml);
	var result = template.transform(modelXml);

	return (0, _uvdoomParser2['default'])(result.innerHTML, {
		onTagNameResolve: function onTagNameResolve(node) {
			var referenceName = node.getAttribute(_componentSpecification.inactiveComponentRefDataAttr);

			if (referenceName) {
				node.removeAttribute(_componentSpecification.inactiveComponentRefDataAttr);
				return referenceName;
			}
		}
	});
};

function convert(node, ctx) {
	if (node == null) {
		return;
	}

	if (typeof node === 'string') {
		var out = new _templateProtoLibDomText2['default'](node);

		ctx && ctx.appendChild(out);
		return out;
	}

	var out = new _templateProtoLibDomElement2['default'](node.tag || node.component);

	if (node.attrs) {
		Object.keys(node.attrs).forEach(function (name) {
			out.setAttribute((0, _uvdoomLibUtils.UvdomAttrToHtmlAttr)(name), node.attrs[name]);
		});
	}

	ctx && ctx.appendChild(out);

	[].concat(node.children || []).forEach(function (child) {
		convert(child, out);
	});

	return out;
}

function parseUVDOM(uvdom) {
	var document = new _templateProtoLibDomDocument2['default']();

	uvdom && convert(uvdom, document);

	return document;
}

function parseModel(model) {
	var document = new _templateProtoLibDomDocument2['default']();
	var modelNode = {
		component: 'model',
		children: []
	};

	Object.keys(model).forEach(function (name) {
		modelNode.children.push({
			component: 'content',
			attrs: {
				name: name
			},
			children: model[name]
		});
	});

	convert(modelNode, document);

	return document;
}
module.exports = exports['default'];

},{"./component/specification":141,"template-proto/lib/context/template":117,"template-proto/lib/dom/document":119,"template-proto/lib/dom/element":120,"template-proto/lib/dom/text":123,"uvdoom/lib/utils":134,"uvdoom/parser":136}],"WebComponents":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _babelPolyfill = require('babel/polyfill');

var _babelPolyfill2 = _interopRequireDefault(_babelPolyfill);

var _component = require('./component');

var _component2 = _interopRequireDefault(_component);

var _renderer = require('./renderer');

var _renderer2 = _interopRequireDefault(_renderer);

var _libUtils = require('./lib/utils');

exports['default'] = function (config) {
	var proxy = function proxy() {
		return _component2['default'].apply(undefined, arguments);
	};

	return (0, _libUtils.assign)(proxy, {
		render: _renderer2['default']
	});
};

module.exports = exports['default'];

},{"./component":140,"./lib/utils":144,"./renderer":146,"babel/polyfill":93}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbGliL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmNvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5jdHguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmRlZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmZ3LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5nZXQtbmFtZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLml0ZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQubWl4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQucGFydGlhbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQucmVkZWYuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnJlcGxhY2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnNoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctcGFkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC5zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC50YXNrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvJC50aHJvd3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy8kLnVpZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQudW5zY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzLyQud2tzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM1LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnN0YXRpY3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVnZXhwLmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmxwYWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnJwYWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9qcy5hcnJheS5zdGF0aWNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYmFiZWwtY29yZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9iYWJlbC1jb3JlL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2JhYmVsLWNvcmUvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvcG9seWZpbGwuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvbGliL2VzNi1wcm9taXNlLy1pbnRlcm5hbC5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvbGliL2VzNi1wcm9taXNlL2FzYXAuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2xpYi9lczYtcHJvbWlzZS9lbnVtZXJhdG9yLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9saWIvZXM2LXByb21pc2UvcHJvbWlzZS5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvbGliL2VzNi1wcm9taXNlL3Byb21pc2UvYWxsLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9saWIvZXM2LXByb21pc2UvcHJvbWlzZS9yYWNlLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9saWIvZXM2LXByb21pc2UvcHJvbWlzZS9yZWplY3QuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2xpYi9lczYtcHJvbWlzZS9wcm9taXNlL3Jlc29sdmUuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2xpYi9lczYtcHJvbWlzZS91dGlscy5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvc2thdGVqcy9zcmMvY29uc3RhbnRzLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9za2F0ZWpzL3NyYy9kYXRhLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9za2F0ZWpzL3NyYy9kb2N1bWVudC1vYnNlcnZlci5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvc2thdGVqcy9zcmMvZ2xvYmFscy5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvc2thdGVqcy9zcmMvbGlmZWN5Y2xlLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9za2F0ZWpzL3NyYy9tdXRhdGlvbi1vYnNlcnZlci5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvc2thdGVqcy9zcmMvcmVnaXN0cnkuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3NrYXRlanMvc3JjL3NrYXRlLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9za2F0ZWpzL3NyYy91dGlscy5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvc2thdGVqcy9zcmMvdmVyc2lvbi5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbGliL2F2dC5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbGliL2NvbnRleHQvYWJzdHJhY3QuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3RlbXBsYXRlLXByb3RvL2xpYi9jb250ZXh0L2RvbS5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbGliL2NvbnRleHQvdGVtcGxhdGUuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3RlbXBsYXRlLXByb3RvL2xpYi9kb20vYXR0cmlidXRlLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy90ZW1wbGF0ZS1wcm90by9saWIvZG9tL2RvY3VtZW50LmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy90ZW1wbGF0ZS1wcm90by9saWIvZG9tL2VsZW1lbnQuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3RlbXBsYXRlLXByb3RvL2xpYi9kb20vbm9kZS1saXN0LmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy90ZW1wbGF0ZS1wcm90by9saWIvZG9tL25vZGUuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3RlbXBsYXRlLXByb3RvL2xpYi9kb20vdGV4dC5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbGliL2hhbmRsZXJzLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy90ZW1wbGF0ZS1wcm90by9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbm9kZV9tb2R1bGVzL2RlYnVnL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL3RlbXBsYXRlLXByb3RvL25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbm9kZV9tb2R1bGVzL3N0cmluZy1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGVtcGxhdGUtcHJvdG8vbm9kZV9tb2R1bGVzL3hwYXRoL3hwYXRoLmpzIiwibm9kZV9tb2R1bGVzL3RlbXBsYXRlLXByb3RvL25vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3V2ZG9vbS9saWIvZW50aXRpZXMuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3V2ZG9vbS9saWIvcHJlZml4LXN0eWxlcy5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdXZkb29tL2xpYi91dGlscy5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdXZkb29tL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy91dmRvb20vcGFyc2VyLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy91dmRvb20vdHJhbnNmb3Jtcy9odG1sLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL25vZGVfbW9kdWxlcy91dmRvb20vdHJhbnNmb3Jtcy9yZWFjdC5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9ub2RlX21vZHVsZXMvdXZkb29tL3RyYW5zZm9ybXMvcmVhY3QvZXZlbnRzLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL3NyYy9jb21wb25lbnQuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvc3JjL2NvbXBvbmVudC9zcGVjaWZpY2F0aW9uLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL3NyYy9kZXBlbmRlbmN5UmVzb2x2ZXIuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvc3JjL2xpYi9wcm9taXNlLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL3NyYy9saWIvdXRpbHMuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvc3JjL21vZGVsLmpzIiwiL2hvbWUvYXphdmlydWhhL3dvcmsvc3JjL3dlYi1jb21wb25lbnRzL3NyYy9yZW5kZXJlci5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9zcmMvcmVuZGVyZXIvZGVmYXVsdC5qcyIsIi9ob21lL2F6YXZpcnVoYS93b3JrL3NyYy93ZWItY29tcG9uZW50cy9zcmMvdGVtcGxhdGUuanMiLCIvaG9tZS9hemF2aXJ1aGEvd29yay9zcmMvd2ViLWNvbXBvbmVudHMvc3JjL3dpZGdldHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Qzs7QUFFNUMsUUFBTyxjQUxBLE1BQU0sRUFLQyxLQUFLLEVBQUU7QUFDcEIsUUFBTSx1QkFBVTtFQUNoQixDQUFDLENBQUM7Q0FDSCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yL3J1bnRpbWVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwvcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7IiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gJC50b09iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gJC50b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gJC50b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXg7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgJCAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjdHggPSByZXF1aXJlKCcuLyQuY3R4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKCR0aGlzKSlcbiAgICAgICwgc2VsZiAgID0gJC5FUzVPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9ICQudG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gQXJyYXkobGVuZ3RoKSA6IElTX0ZJTFRFUiA/IFtdIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZzEsIG1zZzIpe1xuICBpZighY29uZGl0aW9uKXRocm93IFR5cGVFcnJvcihtc2cyID8gbXNnMSArIG1zZzIgOiBtc2cxKTtcbn1cbmFzc2VydC5kZWYgPSAkLmFzc2VydERlZmluZWQ7XG5hc3NlcnQuZm4gPSBmdW5jdGlvbihpdCl7XG4gIGlmKCEkLmlzRnVuY3Rpb24oaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5hc3NlcnQub2JqID0gZnVuY3Rpb24oaXQpe1xuICBpZighJC5pc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuYXNzZXJ0Lmluc3QgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IFR5cGVFcnJvcihuYW1lICsgXCI6IHVzZSB0aGUgJ25ldycgb3BlcmF0b3IhXCIpO1xuICByZXR1cm4gaXQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7IiwidmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKTtcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIFQgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKHRhcmdldCkpXG4gICAgLCBsID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaSA9IDE7XG4gIHdoaWxlKGwgPiBpKXtcbiAgICB2YXIgUyAgICAgID0gJC5FUzVPYmplY3QoYXJndW1lbnRzW2krK10pXG4gICAgICAsIGtleXMgICA9IGVudW1LZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xuICB9XG4gIHJldHVybiBUO1xufTsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIFRBRyAgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpXG4gICwgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbmZ1bmN0aW9uIGNvZihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59XG5jb2YuY2xhc3NvZiA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQ7XG4gIHJldHVybiBpdCA9PSB1bmRlZmluZWQgPyBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiAnTnVsbCdcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbVEFHXSkgPT0gJ3N0cmluZycgPyBUIDogY29mKE8pO1xufTtcbmNvZi5zZXQgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgISQuaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSQuaGlkZShpdCwgVEFHLCB0YWcpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gY29mOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBzYWZlICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlXG4gICwgYXNzZXJ0ICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBmb3JPZiAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHN0ZXAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXInKS5zdGVwXG4gICwgJGhhcyAgICAgPSAkLmhhc1xuICAsIHNldCAgICAgID0gJC5zZXRcbiAgLCBpc09iamVjdCA9ICQuaXNPYmplY3RcbiAgLCBoaWRlICAgICA9ICQuaGlkZVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBJRCAgICAgICA9IHNhZmUoJ2lkJylcbiAgLCBPMSAgICAgICA9IHNhZmUoJ08xJylcbiAgLCBMQVNUICAgICA9IHNhZmUoJ2xhc3QnKVxuICAsIEZJUlNUICAgID0gc2FmZSgnZmlyc3QnKVxuICAsIElURVIgICAgID0gc2FmZSgnaXRlcicpXG4gICwgU0laRSAgICAgPSAkLkRFU0MgPyBzYWZlKCdzaXplJykgOiAnc2l6ZSdcbiAgLCBpZCAgICAgICA9IDA7XG5cbmZ1bmN0aW9uIGZhc3RLZXkoaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighJGhhcyhpdCwgSUQpKXtcbiAgICAvLyBjYW4ndCBzZXQgaWQgdG8gZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgaWRcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXG4gICAgaGlkZShpdCwgSUQsICsraWQpO1xuICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XG4gIH0gcmV0dXJuICdPJyArIGl0W0lEXTtcbn1cblxuZnVuY3Rpb24gZ2V0RW50cnkodGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXRbTzFdW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYXNzZXJ0Lmluc3QodGhhdCwgQywgTkFNRSk7XG4gICAgICBzZXQodGhhdCwgTzEsICQuY3JlYXRlKG51bGwpKTtcbiAgICAgIHNldCh0aGF0LCBTSVpFLCAwKTtcbiAgICAgIHNldCh0aGF0LCBMQVNULCB1bmRlZmluZWQpO1xuICAgICAgc2V0KHRoYXQsIEZJUlNULCB1bmRlZmluZWQpO1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXRbTzFdLCBlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdFtGSVJTVF0gPSB0aGF0W0xBU1RdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXRbTzFdW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdFtGSVJTVF0gPT0gZW50cnkpdGhhdFtGSVJTVF0gPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXRbTEFTVF0gPT0gZW50cnkpdGhhdFtMQVNUXSA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0sIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzW0ZJUlNUXSl7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZigkLkRFU0MpJC5zZXREZXNjKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5kZWYodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0W0xBU1RdID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdFtMQVNUXSwgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdFtGSVJTVF0pdGhhdFtGSVJTVF0gPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdFtPMV1baW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICBzZXRJdGVyOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHNldCh0aGlzLCBJVEVSLCB7bzogaXRlcmF0ZWQsIGs6IGtpbmR9KTtcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxuICAgICAgICAsIGtpbmQgID0gaXRlci5rXG4gICAgICAgICwgZW50cnkgPSBpdGVyLmw7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCFpdGVyLm8gfHwgIShpdGVyLmwgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IGl0ZXIub1tGSVJTVF0pKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGZvck9mID0gcmVxdWlyZSgnLi8kLmZvci1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FKXtcbiAgJGRlZigkZGVmLlAsIE5BTUUsIHtcbiAgICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpe1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yT2YodGhpcywgZmFsc2UsIGFyci5wdXNoLCBhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH0pO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBzYWZlICAgICAgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZVxuICAsIGFzc2VydCAgICA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKVxuICAsIGZvck9mICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsICRoYXMgICAgICA9ICQuaGFzXG4gICwgaXNPYmplY3QgID0gJC5pc09iamVjdFxuICAsIGhpZGUgICAgICA9ICQuaGlkZVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBpZCAgICAgICAgPSAwXG4gICwgSUQgICAgICAgID0gc2FmZSgnaWQnKVxuICAsIFdFQUsgICAgICA9IHNhZmUoJ3dlYWsnKVxuICAsIExFQUsgICAgICA9IHNhZmUoJ2xlYWsnKVxuICAsIG1ldGhvZCAgICA9IHJlcXVpcmUoJy4vJC5hcnJheS1tZXRob2RzJylcbiAgLCBmaW5kICAgICAgPSBtZXRob2QoNSlcbiAgLCBmaW5kSW5kZXggPSBtZXRob2QoNik7XG5mdW5jdGlvbiBmaW5kRnJvemVuKHN0b3JlLCBrZXkpe1xuICByZXR1cm4gZmluZChzdG9yZS5hcnJheSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn1cbi8vIGZhbGxiYWNrIGZvciBmcm96ZW4ga2V5c1xuZnVuY3Rpb24gbGVha1N0b3JlKHRoYXQpe1xuICByZXR1cm4gdGhhdFtMRUFLXSB8fCBoaWRlKHRoYXQsIExFQUssIHtcbiAgICBhcnJheTogW10sXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgICAgdmFyIGVudHJ5ID0gZmluZEZyb3plbih0aGlzLCBrZXkpO1xuICAgICAgaWYoZW50cnkpcmV0dXJuIGVudHJ5WzFdO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgICAgcmV0dXJuICEhZmluZEZyb3plbih0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIHZhciBlbnRyeSA9IGZpbmRGcm96ZW4odGhpcywga2V5KTtcbiAgICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgICBlbHNlIHRoaXMuYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0sXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5hcnJheSwgZnVuY3Rpb24oaXQpe1xuICAgICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICAgIH0pO1xuICAgICAgaWYofmluZGV4KXRoaXMuYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiAhIX5pbmRleDtcbiAgICB9XG4gIH0pW0xFQUtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICAkLnNldChhc3NlcnQuaW5zdCh0aGF0LCBDLCBOQU1FKSwgSUQsIGlkKyspO1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighaXNFeHRlbnNpYmxlKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuICRoYXMoa2V5LCBXRUFLKSAmJiAkaGFzKGtleVtXRUFLXSwgdGhpc1tJRF0pICYmIGRlbGV0ZSBrZXlbV0VBS11bdGhpc1tJRF1dO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFpc0V4dGVuc2libGUoa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gJGhhcyhrZXksIFdFQUspICYmICRoYXMoa2V5W1dFQUtdLCB0aGlzW0lEXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShhc3NlcnQub2JqKGtleSkpKXtcbiAgICAgIGxlYWtTdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRoYXMoa2V5LCBXRUFLKSB8fCBoaWRlKGtleSwgV0VBSywge30pO1xuICAgICAga2V5W1dFQUtdW3RoYXRbSURdXSA9IHZhbHVlO1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGxlYWtTdG9yZTogbGVha1N0b3JlLFxuICBXRUFLOiBXRUFLLFxuICBJRDogSURcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIEJVR0dZID0gcmVxdWlyZSgnLi8kLml0ZXInKS5CVUdHWVxuICAsIGZvck9mID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3BlY2llcyA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzJylcbiAgLCBhc3NlcnRJbnN0YW5jZSA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5pbnN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gJC5nW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBmdW5jdGlvbiBmaXhNZXRob2QoS0VZKXtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlcXVpcmUoJy4vJC5yZWRlZicpKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbihhKXsgcmV0dXJuIGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgfVxuICAgICAgOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSl7IHJldHVybiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IH1cbiAgICAgIDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpeyByZXR1cm4gZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyB9XG4gICAgICA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYil7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9XG4gIGlmKCEkLmlzRnVuY3Rpb24oQykgfHwgIShJU19XRUFLIHx8ICFCVUdHWSAmJiBwcm90by5mb3JFYWNoICYmIHByb3RvLmVudHJpZXMpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVxdWlyZSgnLi8kLm1peCcpKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdCAgPSBuZXcgQ1xuICAgICAgLCBjaGFpbiA9IGluc3RbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKVxuICAgICAgLCBidWdneVplcm87XG4gICAgLy8gd3JhcCBmb3IgaW5pdCBjb2xsZWN0aW9ucyBmcm9tIGl0ZXJhYmxlXG4gICAgaWYoIXJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICAgIGFzc2VydEluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gbmV3IEJhc2U7XG4gICAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBJU19XRUFLIHx8IGluc3QuZm9yRWFjaChmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICBidWdneVplcm8gPSAxIC8ga2V5ID09PSAtSW5maW5pdHk7XG4gICAgfSk7XG4gICAgLy8gZml4IGNvbnZlcnRpbmcgLTAga2V5IHRvICswXG4gICAgaWYoYnVnZ3laZXJvKXtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIC8vICsgZml4IC5hZGQgJiAuc2V0IGZvciBjaGFpbmluZ1xuICAgIGlmKGJ1Z2d5WmVybyB8fCBjaGFpbiAhPT0gaW5zdClmaXhNZXRob2QoQURERVIpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi8kLmNvZicpLnNldChDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGRlZigkZGVmLkcgKyAkZGVmLlcgKyAkZGVmLkYgKiAoQyAhPSBCYXNlKSwgTyk7XG4gIHNwZWNpZXMoQyk7XG4gIHNwZWNpZXMoJC5jb3JlW05BTUVdKTsgLy8gZm9yIHdyYXBwZXJcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0SXRlcihDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTsiLCIvLyBPcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhc3NlcnRGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5mbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFzc2VydEZ1bmN0aW9uKGZuKTtcbiAgaWYofmxlbmd0aCAmJiB0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfSByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICB9O1xufTsiLCJ2YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICA9ICQuZ1xuICAsIGNvcmUgICAgICAgPSAkLmNvcmVcbiAgLCBpc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uXG4gICwgJHJlZGVmICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpO1xuZnVuY3Rpb24gY3R4KGZuLCB0aGF0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGRlZi5GID0gMTsgIC8vIGZvcmNlZFxuJGRlZi5HID0gMjsgIC8vIGdsb2JhbFxuJGRlZi5TID0gNDsgIC8vIHN0YXRpY1xuJGRlZi5QID0gODsgIC8vIHByb3RvXG4kZGVmLkIgPSAxNjsgLy8gYmluZFxuJGRlZi5XID0gMzI7IC8vIHdyYXBcbmZ1bmN0aW9uICRkZWYodHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cFxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgJGRlZi5HXG4gICAgLCBpc1Byb3RvICA9IHR5cGUgJiAkZGVmLlBcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiB0eXBlICYgJGRlZi5TXG4gICAgICAgID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSkucHJvdG90eXBlXG4gICAgLCBleHBvcnRzICA9IGlzR2xvYmFsID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhKHR5cGUgJiAkZGVmLkYpICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGlmKHR5cGUgJiAkZGVmLkIgJiYgb3duKWV4cCA9IGN0eChvdXQsIGdsb2JhbCk7XG4gICAgZWxzZSBleHAgPSBpc1Byb3RvICYmIGlzRnVuY3Rpb24ob3V0KSA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQgJiYgIW93bikkcmVkZWYodGFyZ2V0LCBrZXksIG91dCk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCkkLmhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKGlzUHJvdG8pKGV4cG9ydHMucHJvdG90eXBlIHx8IChleHBvcnRzLnByb3RvdHlwZSA9IHt9KSlba2V5XSA9IG91dDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSAkZGVmOyIsInZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZG9jdW1lbnQgPSAkLmcuZG9jdW1lbnRcbiAgLCBpc09iamVjdCA9ICQuaXNPYmplY3RcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIga2V5cyAgICAgICA9ICQuZ2V0S2V5cyhpdClcbiAgICAsIGdldERlc2MgICAgPSAkLmdldERlc2NcbiAgICAsIGdldFN5bWJvbHMgPSAkLmdldFN5bWJvbHM7XG4gIGlmKGdldFN5bWJvbHMpJC5lYWNoLmNhbGwoZ2V0U3ltYm9scyhpdCksIGZ1bmN0aW9uKGtleSl7XG4gICAgaWYoZ2V0RGVzYyhpdCwga2V5KS5lbnVtZXJhYmxlKWtleXMucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIGtleXM7XG59OyIsInZhciBjdHggID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgZ2V0ICA9IHJlcXVpcmUoJy4vJC5pdGVyJykuZ2V0XG4gICwgY2FsbCA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0KXtcbiAgdmFyIGl0ZXJhdG9yID0gZ2V0KGl0ZXJhYmxlKVxuICAgICwgZiAgICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIHN0ZXA7XG4gIHdoaWxlKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSl7XG4gICAgaWYoY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcykgPT09IGZhbHNlKXtcbiAgICAgIHJldHVybiBjYWxsLmNsb3NlKGl0ZXJhdG9yKTtcbiAgICB9XG4gIH1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKXtcbiAgJC5GVyAgID0gdHJ1ZTtcbiAgJC5wYXRoID0gJC5nO1xuICByZXR1cm4gJDtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xyXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpXHJcbiAgLCB0b1N0cmluZyA9IHt9LnRvU3RyaW5nXHJcbiAgLCBnZXROYW1lcyA9ICQuZ2V0TmFtZXM7XHJcblxyXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XHJcblxyXG5mdW5jdGlvbiBnZXRXaW5kb3dOYW1lcyhpdCl7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBnZXROYW1lcyhpdCk7XHJcbiAgfSBjYXRjaChlKXtcclxuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XHJcbiAgaWYod2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScpcmV0dXJuIGdldFdpbmRvd05hbWVzKGl0KTtcclxuICByZXR1cm4gZ2V0TmFtZXMoJC50b09iamVjdChpdCkpO1xyXG59OyIsIi8vIEZhc3QgYXBwbHlcbi8vIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICBjYXNlIDU6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsInZhciBhc3NlcnRPYmplY3QgPSByZXF1aXJlKCcuLyQuYXNzZXJ0Jykub2JqO1xuZnVuY3Rpb24gY2xvc2UoaXRlcmF0b3Ipe1xuICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICBpZihyZXQgIT09IHVuZGVmaW5lZClhc3NlcnRPYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIGNhbGwoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhc3NlcnRPYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2goZSl7XG4gICAgY2xvc2UoaXRlcmF0b3IpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cbmNhbGwuY2xvc2UgPSBjbG9zZTtcbm1vZHVsZS5leHBvcnRzID0gY2FsbDsiLCJ2YXIgJGRlZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHJlZGVmICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmJylcbiAgLCAkICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRpdGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyJylcbiAgLCBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBGRl9JVEVSQVRPUiAgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICAgPSAndmFsdWVzJ1xuICAsIEl0ZXJhdG9ycyAgICAgICA9ICRpdGVyLkl0ZXJhdG9ycztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0Upe1xuICAkaXRlci5jcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICBmdW5jdGlvbiBjcmVhdGVNZXRob2Qoa2luZCl7XG4gICAgZnVuY3Rpb24gJCQodGhhdCl7XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoYXQsIGtpbmQpO1xuICAgIH1cbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiAkJCh0aGlzKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkJCh0aGlzKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiAkJCh0aGlzKTsgfTtcbiAgfVxuICB2YXIgVEFHICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIHByb3RvICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsIF9uYXRpdmUgID0gcHJvdG9bU1lNQk9MX0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgX2RlZmF1bHQgPSBfbmF0aXZlIHx8IGNyZWF0ZU1ldGhvZChERUZBVUxUKVxuICAgICwgbWV0aG9kcywga2V5O1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKF9uYXRpdmUpe1xuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9ICQuZ2V0UHJvdG8oX2RlZmF1bHQuY2FsbChuZXcgQmFzZSkpO1xuICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICBjb2Yuc2V0KEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCQuRlcgJiYgJC5oYXMocHJvdG8sIEZGX0lURVJBVE9SKSkkaXRlci5zZXQoSXRlcmF0b3JQcm90b3R5cGUsICQudGhhdCk7XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCQuRlcgfHwgRk9SQ0UpJGl0ZXIuc2V0KHByb3RvLCBfZGVmYXVsdCk7XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gX2RlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9ICQudGhhdDtcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgICAgICAgID8gX2RlZmF1bHQgOiBjcmVhdGVNZXRob2QoS0VZUyksXG4gICAgICB2YWx1ZXM6ICBERUZBVUxUID09IFZBTFVFUyA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKFZBTFVFUyksXG4gICAgICBlbnRyaWVzOiBERUZBVUxUICE9IFZBTFVFUyA/IF9kZWZhdWx0IDogY3JlYXRlTWV0aG9kKCdlbnRyaWVzJylcbiAgICB9O1xuICAgIGlmKEZPUkNFKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpJHJlZGVmKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRkZWYoJGRlZi5QICsgJGRlZi5GICogJGl0ZXIuQlVHR1ksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG59OyIsInZhciBTWU1CT0xfSVRFUkFUT1IgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgICAgPSBmYWxzZTtcbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtTWU1CT0xfSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgaWYoIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltTWU1CT0xfSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgc2FmZSA9IHRydWU7IH07XG4gICAgYXJyW1NZTUJPTF9JVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBjbGFzc29mICAgICAgICAgICA9IGNvZi5jbGFzc29mXG4gICwgYXNzZXJ0ICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBhc3NlcnRPYmplY3QgICAgICA9IGFzc2VydC5vYmpcbiAgLCBTWU1CT0xfSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEZGX0lURVJBVE9SICAgICAgID0gJ0BAaXRlcmF0b3InXG4gICwgSXRlcmF0b3JzICAgICAgICAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJykoJ2l0ZXJhdG9ycycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5zZXRJdGVyYXRvcihJdGVyYXRvclByb3RvdHlwZSwgJC50aGF0KTtcbmZ1bmN0aW9uIHNldEl0ZXJhdG9yKE8sIHZhbHVlKXtcbiAgJC5oaWRlKE8sIFNZTUJPTF9JVEVSQVRPUiwgdmFsdWUpO1xuICAvLyBBZGQgaXRlcmF0b3IgZm9yIEZGIGl0ZXJhdG9yIHByb3RvY29sXG4gIGlmKEZGX0lURVJBVE9SIGluIFtdKSQuaGlkZShPLCBGRl9JVEVSQVRPUiwgdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBCVUdHWTogJ2tleXMnIGluIFtdICYmICEoJ25leHQnIGluIFtdLmtleXMoKSksXG4gIEl0ZXJhdG9yczogSXRlcmF0b3JzLFxuICBzdGVwOiBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gICAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG4gIH0sXG4gIGlzOiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIE8gICAgICA9IE9iamVjdChpdClcbiAgICAgICwgU3ltYm9sID0gJC5nLlN5bWJvbDtcbiAgICByZXR1cm4gKFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgRkZfSVRFUkFUT1IpIGluIE9cbiAgICAgIHx8IFNZTUJPTF9JVEVSQVRPUiBpbiBPXG4gICAgICB8fCAkLmhhcyhJdGVyYXRvcnMsIGNsYXNzb2YoTykpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgU3ltYm9sID0gJC5nLlN5bWJvbFxuICAgICAgLCBnZXRJdGVyO1xuICAgIGlmKGl0ICE9IHVuZGVmaW5lZCl7XG4gICAgICBnZXRJdGVyID0gaXRbU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvciB8fCBGRl9JVEVSQVRPUl1cbiAgICAgICAgfHwgaXRbU1lNQk9MX0lURVJBVE9SXVxuICAgICAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xuICAgIH1cbiAgICBhc3NlcnQoJC5pc0Z1bmN0aW9uKGdldEl0ZXIpLCBpdCwgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gICAgcmV0dXJuIGFzc2VydE9iamVjdChnZXRJdGVyLmNhbGwoaXQpKTtcbiAgfSxcbiAgc2V0OiBzZXRJdGVyYXRvcixcbiAgY3JlYXRlOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgcHJvdG8pe1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQuY3JlYXRlKHByb3RvIHx8IEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogJC5kZXNjKDEsIG5leHQpfSk7XG4gICAgY29mLnNldChDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICAsIGNvcmUgICA9IHt9XG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5XG4gICwgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3JcbiAgLCBtYXggICA9IE1hdGgubWF4XG4gICwgbWluICAgPSBNYXRoLm1pbjtcbi8vIFRoZSBlbmdpbmUgd29ya3MgZmluZSB3aXRoIGRlc2NyaXB0b3JzPyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5LlxudmFyIERFU0MgPSAhIWZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiAyOyB9fSkuYSA9PSAyO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG52YXIgaGlkZSA9IGNyZWF0ZURlZmluZXIoMSk7XG4vLyA3LjEuNCBUb0ludGVnZXJcbmZ1bmN0aW9uIHRvSW50ZWdlcihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufVxuZnVuY3Rpb24gZGVzYyhiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBzaW1wbGVTZXQob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmluZXIoYml0bWFwKXtcbiAgcmV0dXJuIERFU0MgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICAgIHJldHVybiAkLnNldERlc2Mob2JqZWN0LCBrZXksIGRlc2MoYml0bWFwLCB2YWx1ZSkpO1xuICB9IDogc2ltcGxlU2V0O1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpdCl7XG4gIHJldHVybiBpdCAhPT0gbnVsbCAmJiAodHlwZW9mIGl0ID09ICdvYmplY3QnIHx8IHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhc3NlcnREZWZpbmVkKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufVxuXG52YXIgJCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmZ3Jykoe1xuICBnOiBnbG9iYWwsXG4gIGNvcmU6IGNvcmUsXG4gIGh0bWw6IGdsb2JhbC5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcmUtanMtaXNvYmplY3RcbiAgaXNPYmplY3Q6ICAgaXNPYmplY3QsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIHRoYXQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIDcuMS40IFRvSW50ZWdlclxuICB0b0ludGVnZXI6IHRvSW50ZWdlcixcbiAgLy8gNy4xLjE1IFRvTGVuZ3RoXG4gIHRvTGVuZ3RoOiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbiAgfSxcbiAgdG9JbmRleDogZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gICAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xuICB9LFxuICBjcmVhdGU6ICAgICBPYmplY3QuY3JlYXRlLFxuICBnZXRQcm90bzogICBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIERFU0M6ICAgICAgIERFU0MsXG4gIGRlc2M6ICAgICAgIGRlc2MsXG4gIGdldERlc2M6ICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIHNldERlc2M6ICAgIGRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyxcbiAgZ2V0S2V5czogICAgT2JqZWN0LmtleXMsXG4gIGdldE5hbWVzOiAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICBhc3NlcnREZWZpbmVkOiBhc3NlcnREZWZpbmVkLFxuICAvLyBEdW1teSwgZml4IGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5nIGluIGVzNSBtb2R1bGVcbiAgRVM1T2JqZWN0OiBPYmplY3QsXG4gIHRvT2JqZWN0OiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuICQuRVM1T2JqZWN0KGFzc2VydERlZmluZWQoaXQpKTtcbiAgfSxcbiAgaGlkZTogaGlkZSxcbiAgZGVmOiBjcmVhdGVEZWZpbmVyKDApLFxuICBzZXQ6IGdsb2JhbC5TeW1ib2wgPyBzaW1wbGVTZXQgOiBoaWRlLFxuICBlYWNoOiBbXS5mb3JFYWNoXG59KTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5pZih0eXBlb2YgX19lICE9ICd1bmRlZmluZWQnKV9fZSA9IGNvcmU7XG5pZih0eXBlb2YgX19nICE9ICd1bmRlZmluZWQnKV9fZyA9IGdsb2JhbDsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9ICQudG9PYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJ2YXIgJHJlZGVmID0gcmVxdWlyZSgnLi8kLnJlZGVmJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMpe1xyXG4gIGZvcih2YXIga2V5IGluIHNyYykkcmVkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcclxuICByZXR1cm4gdGFyZ2V0O1xyXG59OyIsInZhciAkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGFzc2VydE9iamVjdCA9IHJlcXVpcmUoJy4vJC5hc3NlcnQnKS5vYmo7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICBhc3NlcnRPYmplY3QoaXQpO1xuICB2YXIga2V5cyAgICAgICA9ICQuZ2V0TmFtZXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGludm9rZSA9IHJlcXVpcmUoJy4vJC5pbnZva2UnKVxuICAsIGFzc2VydEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLmZuO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigvKiAuLi5wYXJncyAqLyl7XG4gIHZhciBmbiAgICAgPSBhc3NlcnRGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gJC5wYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgICAgPSB0aGlzXG4gICAgICAsIF9sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFfbGVuZ3RoKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoX2xlbmd0aCA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07IiwidmFyICQgICA9IHJlcXVpcmUoJy4vJCcpXHJcbiAgLCB0cGwgPSBTdHJpbmcoe30uaGFzT3duUHJvcGVydHkpXHJcbiAgLCBTUkMgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZSgnc3JjJylcclxuICAsIF90b1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xyXG5cclxuZnVuY3Rpb24gJHJlZGVmKE8sIGtleSwgdmFsLCBzYWZlKXtcclxuICBpZigkLmlzRnVuY3Rpb24odmFsKSl7XHJcbiAgICB2YXIgYmFzZSA9IE9ba2V5XTtcclxuICAgICQuaGlkZSh2YWwsIFNSQywgYmFzZSA/IFN0cmluZyhiYXNlKSA6IHRwbC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eS8sIFN0cmluZyhrZXkpKSk7XHJcbiAgICBpZighKCduYW1lJyBpbiB2YWwpKXZhbC5uYW1lID0ga2V5O1xyXG4gIH1cclxuICBpZihPID09PSAkLmcpe1xyXG4gICAgT1trZXldID0gdmFsO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZighc2FmZSlkZWxldGUgT1trZXldO1xyXG4gICAgJC5oaWRlKE8sIGtleSwgdmFsKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzXHJcbi8vIHdpdGggbWV0aG9kcyBzaW1pbGFyIHRvIExvRGFzaCBpc05hdGl2ZVxyXG4kcmVkZWYoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xyXG4gIHJldHVybiAkLmhhcyh0aGlzLCBTUkMpID8gdGhpc1tTUkNdIDogX3RvU3RyaW5nLmNhbGwodGhpcyk7XHJcbn0pO1xyXG5cclxuJC5jb3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XHJcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKGl0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gJHJlZGVmOyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnRXhwLCByZXBsYWNlLCBpc1N0YXRpYyl7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uKHBhcnQpe1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gU3RyaW5nKGlzU3RhdGljID8gaXQgOiB0aGlzKS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcclxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcclxufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgJCAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBhc3NlcnQgPSByZXF1aXJlKCcuLyQuYXNzZXJ0Jyk7XG5mdW5jdGlvbiBjaGVjayhPLCBwcm90byl7XG4gIGFzc2VydC5vYmooTyk7XG4gIGFzc2VydChwcm90byA9PT0gbnVsbCB8fCAkLmlzT2JqZWN0KHByb3RvKSwgcHJvdG8sIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgID8gZnVuY3Rpb24oYnVnZ3ksIHNldCl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi8kLmN0eCcpKEZ1bmN0aW9uLmNhbGwsICQuZ2V0RGVzYyhPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgICBzZXQoe30sIFtdKTtcbiAgICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICAgIHJldHVybiBPO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwidmFyICQgICAgICA9IHJlcXVpcmUoJy4vJCcpXHJcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xyXG4gICwgc3RvcmUgID0gJC5nW1NIQVJFRF0gfHwgKCQuZ1tTSEFSRURdID0ge30pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XHJcbn07IiwidmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIFNQRUNJRVMgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQyl7XG4gIGlmKCQuREVTQyAmJiAhKFNQRUNJRVMgaW4gQykpJC5zZXREZXNjKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiAkLnRoYXRcbiAgfSk7XG59OyIsIi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZygkLmFzc2VydERlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSAkLnRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsXG4gICAgICB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOnN0cmluZ19wYWRkaW5nXG52YXIgJCAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCByZXBlYXQgPSByZXF1aXJlKCcuLyQuc3RyaW5nLXJlcGVhdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1pbkxlbmd0aCwgZmlsbENoYXIsIGxlZnQpe1xuICAvLyAxLiBMZXQgTyBiZSBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzIHZhbHVlKS5cbiAgLy8gMi4gTGV0IFMgYmUgVG9TdHJpbmcoTykuXG4gIHZhciBTID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGF0KSk7XG4gIC8vIDQuIElmIGludE1pbkxlbmd0aCBpcyB1bmRlZmluZWQsIHJldHVybiBTLlxuICBpZihtaW5MZW5ndGggPT09IHVuZGVmaW5lZClyZXR1cm4gUztcbiAgLy8gNC4gTGV0IGludE1pbkxlbmd0aCBiZSBUb0ludGVnZXIobWluTGVuZ3RoKS5cbiAgdmFyIGludE1pbkxlbmd0aCA9ICQudG9JbnRlZ2VyKG1pbkxlbmd0aCk7XG4gIC8vIDUuIExldCBmaWxsTGVuIGJlIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBTIG1pbnVzIGludE1pbkxlbmd0aC5cbiAgdmFyIGZpbGxMZW4gPSBpbnRNaW5MZW5ndGggLSBTLmxlbmd0aDtcbiAgLy8gNi4gSWYgZmlsbExlbiA8IDAsIHRoZW4gdGhyb3cgYSBSYW5nZUVycm9yIGV4Y2VwdGlvbi5cbiAgLy8gNy4gSWYgZmlsbExlbiBpcyAr4oieLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvciBleGNlcHRpb24uXG4gIGlmKGZpbGxMZW4gPCAwIHx8IGZpbGxMZW4gPT09IEluZmluaXR5KXtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IHNhdGlzZnkgc3RyaW5nIGxlbmd0aCAnICsgbWluTGVuZ3RoICsgJyBmb3Igc3RyaW5nOiAnICsgUyk7XG4gIH1cbiAgLy8gOC4gTGV0IHNGaWxsU3RyIGJlIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgZmlsbFN0ci5cbiAgLy8gOS4gSWYgc0ZpbGxTdHIgaXMgdW5kZWZpbmVkLCBsZXQgc0ZpbGxTdHIgYmUgYSBzcGFjZSBjaGFyYWN0ZXIuXG4gIHZhciBzRmlsbFN0ciA9IGZpbGxDaGFyID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbENoYXIpO1xuICAvLyAxMC4gTGV0IHNGaWxsVmFsIGJlIGEgU3RyaW5nIG1hZGUgb2Ygc0ZpbGxTdHIsIHJlcGVhdGVkIHVudGlsIGZpbGxMZW4gaXMgbWV0LlxuICB2YXIgc0ZpbGxWYWwgPSByZXBlYXQuY2FsbChzRmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBzRmlsbFN0ci5sZW5ndGgpKTtcbiAgLy8gdHJ1bmNhdGUgaWYgd2Ugb3ZlcmZsb3dlZFxuICBpZihzRmlsbFZhbC5sZW5ndGggPiBmaWxsTGVuKXNGaWxsVmFsID0gbGVmdFxuICAgID8gc0ZpbGxWYWwuc2xpY2Uoc0ZpbGxWYWwubGVuZ3RoIC0gZmlsbExlbilcbiAgICA6IHNGaWxsVmFsLnNsaWNlKDAsIGZpbGxMZW4pO1xuICAvLyAxMS4gUmV0dXJuIGEgc3RyaW5nIG1hZGUgZnJvbSBzRmlsbFZhbCwgZm9sbG93ZWQgYnkgUy5cbiAgLy8gMTEuIFJldHVybiBhIFN0cmluZyBtYWRlIGZyb20gUywgZm9sbG93ZWQgYnkgc0ZpbGxWYWwuXG4gIHJldHVybiBsZWZ0ID8gc0ZpbGxWYWwuY29uY2F0KFMpIDogUy5jb25jYXQoc0ZpbGxWYWwpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9ICQudG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYobiA8IDAgfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGN0eCAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGNvZiAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIGludm9rZSA9IHJlcXVpcmUoJy4vJC5pbnZva2UnKVxuICAsIGNlbCAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSAkLmdcbiAgLCBpc0Z1bmN0aW9uICAgICAgICAgPSAkLmlzRnVuY3Rpb25cbiAgLCBodG1sICAgICAgICAgICAgICAgPSAkLmh0bWxcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuZnVuY3Rpb24gcnVuKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZigkLmhhcyhxdWV1ZSwgaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59XG5mdW5jdGlvbiBsaXN0bmVyKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighaXNGdW5jdGlvbihzZXRUYXNrKSB8fCAhaXNGdW5jdGlvbihjbGVhclRhc2spKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKGlzRnVuY3Rpb24oZm4pID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYoY29mKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gTW9kZXJuIGJyb3dzZXJzLCBza2lwIGltcGxlbWVudGF0aW9uIGZvciBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzIG9iamVjdFxuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgaXNGdW5jdGlvbihnbG9iYWwucG9zdE1lc3NhZ2UpICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcbiAgLy8gV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoaXNGdW5jdGlvbihNZXNzYWdlQ2hhbm5lbCkpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0bmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCJ2YXIgc2lkID0gMDtcbmZ1bmN0aW9uIHVpZChrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytzaWQgKyBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikpO1xufVxudWlkLnNhZmUgPSByZXF1aXJlKCcuLyQnKS5nLlN5bWJvbCB8fCB1aWQ7XG5tb2R1bGUuZXhwb3J0cyA9IHVpZDsiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuLyQud2tzJykoJ3Vuc2NvcGFibGVzJyk7XG5pZighKFVOU0NPUEFCTEVTIGluIFtdKSlyZXF1aXJlKCcuLyQnKS5oaWRlKEFycmF5LnByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgW11bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi8kJykuZ1xuICAsIHN0b3JlICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKSgnd2tzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBnbG9iYWwuU3ltYm9sICYmIGdsb2JhbC5TeW1ib2xbbmFtZV0gfHwgcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTsiLCJ2YXIgJCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY2VsICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBjb2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGludm9rZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBhcnJheU1ldGhvZCAgICAgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKVxuICAsIElFX1BST1RPICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJykuc2FmZSgnX19wcm90b19fJylcbiAgLCBhc3NlcnQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpXG4gICwgYXNzZXJ0T2JqZWN0ICAgICA9IGFzc2VydC5vYmpcbiAgLCBPYmplY3RQcm90byAgICAgID0gT2JqZWN0LnByb3RvdHlwZVxuICAsIGh0bWwgICAgICAgICAgICAgPSAkLmh0bWxcbiAgLCBBICAgICAgICAgICAgICAgID0gW11cbiAgLCBfc2xpY2UgICAgICAgICAgID0gQS5zbGljZVxuICAsIF9qb2luICAgICAgICAgICAgPSBBLmpvaW5cbiAgLCBjbGFzc29mICAgICAgICAgID0gY29mLmNsYXNzb2ZcbiAgLCBoYXMgICAgICAgICAgICAgID0gJC5oYXNcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgID0gJC5zZXREZXNjXG4gICwgZ2V0T3duRGVzY3JpcHRvciA9ICQuZ2V0RGVzY1xuICAsIGRlZmluZVByb3BlcnRpZXMgPSAkLnNldERlc2NzXG4gICwgaXNGdW5jdGlvbiAgICAgICA9ICQuaXNGdW5jdGlvblxuICAsIGlzT2JqZWN0ICAgICAgICAgPSAkLmlzT2JqZWN0XG4gICwgdG9PYmplY3QgICAgICAgICA9ICQudG9PYmplY3RcbiAgLCB0b0xlbmd0aCAgICAgICAgID0gJC50b0xlbmd0aFxuICAsIHRvSW5kZXggICAgICAgICAgPSAkLnRvSW5kZXhcbiAgLCBJRThfRE9NX0RFRklORSAgID0gZmFsc2VcbiAgLCAkaW5kZXhPZiAgICAgICAgID0gcmVxdWlyZSgnLi8kLmFycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgJGZvckVhY2ggICAgICAgICA9IGFycmF5TWV0aG9kKDApXG4gICwgJG1hcCAgICAgICAgICAgICA9IGFycmF5TWV0aG9kKDEpXG4gICwgJGZpbHRlciAgICAgICAgICA9IGFycmF5TWV0aG9kKDIpXG4gICwgJHNvbWUgICAgICAgICAgICA9IGFycmF5TWV0aG9kKDMpXG4gICwgJGV2ZXJ5ICAgICAgICAgICA9IGFycmF5TWV0aG9kKDQpO1xuXG5pZighJC5ERVNDKXtcbiAgdHJ5IHtcbiAgICBJRThfRE9NX0RFRklORSA9IGRlZmluZVByb3BlcnR5KGNlbCgnZGl2JyksICd4JyxcbiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA4OyB9fVxuICAgICkueCA9PSA4O1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gICQuc2V0RGVzYyA9IGZ1bmN0aW9uKE8sIFAsIEF0dHJpYnV0ZXMpe1xuICAgIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICAgIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICAgIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylhc3NlcnRPYmplY3QoTylbUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgIHJldHVybiBPO1xuICB9O1xuICAkLmdldERlc2MgPSBmdW5jdGlvbihPLCBQKXtcbiAgICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgICAgcmV0dXJuIGdldE93bkRlc2NyaXB0b3IoTywgUCk7XG4gICAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICAgIGlmKGhhcyhPLCBQKSlyZXR1cm4gJC5kZXNjKCFPYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE8sIFApLCBPW1BdKTtcbiAgfTtcbiAgJC5zZXREZXNjcyA9IGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbihPLCBQcm9wZXJ0aWVzKXtcbiAgICBhc3NlcnRPYmplY3QoTyk7XG4gICAgdmFyIGtleXMgICA9ICQuZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpID0gMFxuICAgICAgLCBQO1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpJC5zZXREZXNjKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICAgIHJldHVybiBPO1xuICB9O1xufVxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhJC5ERVNDLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuNiAvIDE1LjIuMy4zIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkLmdldERlc2MsXG4gIC8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkLnNldERlc2MsXG4gIC8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllc1xufSk7XG5cbiAgLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGtleXMxID0gKCdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLCcgK1xuICAgICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnKS5zcGxpdCgnLCcpXG4gIC8vIEFkZGl0aW9uYWwga2V5cyBmb3IgZ2V0T3duUHJvcGVydHlOYW1lc1xuICAsIGtleXMyID0ga2V5czEuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJylcbiAgLCBrZXlzTGVuMSA9IGtleXMxLmxlbmd0aDtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGNlbCgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGtleXNMZW4xXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdC5wcm90b3R5cGVba2V5czFbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUdldEtleXMobmFtZXMsIGxlbmd0aCl7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3Qpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdChvYmplY3QpXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgICAgfiRpbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gRW1wdHkoKXt9XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbiAgZ2V0UHJvdG90eXBlT2Y6ICQuZ2V0UHJvdG8gPSAkLmdldFByb3RvIHx8IGZ1bmN0aW9uKE8pe1xuICAgIE8gPSBPYmplY3QoYXNzZXJ0LmRlZihPKSk7XG4gICAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gICAgaWYoaXNGdW5jdGlvbihPLmNvbnN0cnVjdG9yKSAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbiAgfSxcbiAgLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkLmdldE5hbWVzID0gJC5nZXROYW1lcyB8fCBjcmVhdGVHZXRLZXlzKGtleXMyLCBrZXlzMi5sZW5ndGgsIHRydWUpLFxuICAvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkLmNyZWF0ZSA9ICQuY3JlYXRlIHx8IGZ1bmN0aW9uKE8sIC8qPyovUHJvcGVydGllcyl7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZihPICE9PSBudWxsKXtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IGFzc2VydE9iamVjdChPKTtcbiAgICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2Ygc2hpbVxuICAgICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gICAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xuICB9LFxuICAvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbiAga2V5czogJC5nZXRLZXlzID0gJC5nZXRLZXlzIHx8IGNyZWF0ZUdldEtleXMoa2V5czEsIGtleXNMZW4xLCBmYWxzZSksXG4gIC8vIDE5LjEuMi4xNyAvIDE1LjIuMy44IE9iamVjdC5zZWFsKE8pXG4gIHNlYWw6IGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiBpdDsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi41IC8gMTUuMi4zLjkgT2JqZWN0LmZyZWV6ZShPKVxuICBmcmVlemU6IGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuIGl0OyAvLyA8LSBjYXBcbiAgfSxcbiAgLy8gMTkuMS4yLjE1IC8gMTUuMi4zLjEwIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiBpdDsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xMyAvIDE1LjIuMy4xMSBPYmplY3QuaXNTZWFsZWQoTylcbiAgaXNTZWFsZWQ6IGZ1bmN0aW9uIGlzU2VhbGVkKGl0KXtcbiAgICByZXR1cm4gIWlzT2JqZWN0KGl0KTsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xMiAvIDE1LjIuMy4xMiBPYmplY3QuaXNGcm96ZW4oTylcbiAgaXNGcm96ZW46IGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gIWlzT2JqZWN0KGl0KTsgLy8gPC0gY2FwXG4gIH0sXG4gIC8vIDE5LjEuMi4xMSAvIDE1LjIuMy4xMyBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpOyAvLyA8LSBjYXBcbiAgfVxufSk7XG5cbi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbiRkZWYoJGRlZi5QLCAnRnVuY3Rpb24nLCB7XG4gIGJpbmQ6IGZ1bmN0aW9uKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBmbiAgICAgICA9IGFzc2VydC5mbih0aGlzKVxuICAgICAgLCBwYXJ0QXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLyl7XG4gICAgICB2YXIgYXJncyAgID0gcGFydEFyZ3MuY29uY2F0KF9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICwgY29uc3RyID0gdGhpcyBpbnN0YW5jZW9mIGJvdW5kXG4gICAgICAgICwgY3R4ICAgID0gY29uc3RyID8gJC5jcmVhdGUoZm4ucHJvdG90eXBlKSA6IHRoYXRcbiAgICAgICAgLCByZXN1bHQgPSBpbnZva2UoZm4sIGFyZ3MsIGN0eCk7XG4gICAgICByZXR1cm4gY29uc3RyID8gY3R4IDogcmVzdWx0O1xuICAgIH1cbiAgICBpZihmbi5wcm90b3R5cGUpYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICAgIHJldHVybiBib3VuZDtcbiAgfVxufSk7XG5cbi8vIEZpeCBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZyBhbmQgRE9NIG9iamVjdHNcbmlmKCEoMCBpbiBPYmplY3QoJ3onKSAmJiAneidbMF0gPT0gJ3onKSl7XG4gICQuRVM1T2JqZWN0ID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbiAgfTtcbn1cblxudmFyIGJ1Z2d5U2xpY2UgPSB0cnVlO1xudHJ5IHtcbiAgaWYoaHRtbClfc2xpY2UuY2FsbChodG1sKTtcbiAgYnVnZ3lTbGljZSA9IGZhbHNlO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGJ1Z2d5U2xpY2UsICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpe1xuICAgIHZhciBsZW4gICA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKVxuICAgICAgLCBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZihrbGFzcyA9PSAnQXJyYXknKXJldHVybiBfc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgID0gdG9JbmRleChiZWdpbiwgbGVuKVxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBzaXplICAgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpXG4gICAgICAsIGNsb25lZCA9IEFycmF5KHNpemUpXG4gICAgICAsIGkgICAgICA9IDA7XG4gICAgZm9yKDsgaSA8IHNpemU7IGkrKyljbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcblxuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiAoJC5FUzVPYmplY3QgIT0gT2JqZWN0KSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKCl7XG4gICAgcmV0dXJuIF9qb2luLmFwcGx5KCQuRVM1T2JqZWN0KHRoaXMpLCBhcmd1bWVudHMpO1xuICB9XG59KTtcblxuLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCB7XG4gIGlzQXJyYXk6IGZ1bmN0aW9uKGFyZyl7XG4gICAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlSZWR1Y2UoaXNSaWdodCl7XG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFja2ZuLCBtZW1vKXtcbiAgICBhc3NlcnQuZm4oY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAgICwgaSAgICAgID0gaXNSaWdodCA/IC0xIDogMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMilmb3IoOzspe1xuICAgICAgaWYoaW5kZXggaW4gTyl7XG4gICAgICAgIG1lbW8gPSBPW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYXNzZXJ0KGlzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXgsICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICAgIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBPKXtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIE9baW5kZXhdLCBpbmRleCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufVxuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6ICQuZWFjaCA9ICQuZWFjaCB8fCBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfSxcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH0sXG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBjcmVhdGVBcnJheVJlZHVjZShmYWxzZSksXG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogY3JlYXRlQXJyYXlSZWR1Y2UodHJ1ZSksXG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2YoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5kZXhPZih0aGlzLCBlbCwgYXJndW1lbnRzWzFdKTtcbiAgfSxcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbihlbCwgZnJvbUluZGV4IC8qID0gQFsqLTFdICovKXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IGxlbmd0aCAtIDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpaW5kZXggPSBNYXRoLm1pbihpbmRleCwgJC50b0ludGVnZXIoZnJvbUluZGV4KSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gdG9MZW5ndGgobGVuZ3RoICsgaW5kZXgpO1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gaW5kZXg7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuLy8gMjEuMS4zLjI1IC8gMTUuNS40LjIwIFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHt0cmltOiByZXF1aXJlKCcuLyQucmVwbGFjZXInKSgvXlxccyooW1xcc1xcU10qXFxTKT9cXHMqJC8sICckMScpfSk7XG5cbi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxuJGRlZigkZGVmLlMsICdEYXRlJywge25vdzogZnVuY3Rpb24oKXtcbiAgcmV0dXJuICtuZXcgRGF0ZTtcbn19KTtcblxuZnVuY3Rpb24gbHoobnVtKXtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59XG5cbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG4vLyBQaGFudG9tSlMgYW5kIG9sZCB3ZWJraXQgaGFkIGEgYnJva2VuIERhdGUgaW1wbGVtZW50YXRpb24uXG52YXIgZGF0ZSAgICAgICA9IG5ldyBEYXRlKC01ZTEzIC0gMSlcbiAgLCBicm9rZW5EYXRlID0gIShkYXRlLnRvSVNPU3RyaW5nICYmIGRhdGUudG9JU09TdHJpbmcoKSA9PSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJ1xuICAgICAgJiYgcmVxdWlyZSgnLi8kLnRocm93cycpKGZ1bmN0aW9uKCl7IG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTsgfSkpO1xuJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBicm9rZW5EYXRlLCAnRGF0ZScsIHt0b0lTT1N0cmluZzogZnVuY3Rpb24oKXtcbiAgaWYoIWlzRmluaXRlKHRoaXMpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXNcbiAgICAsIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufX0pO1xuXG5pZihjbGFzc29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ09iamVjdCcpY29mLmNsYXNzb2YgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0YWcgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIHRhZyA9PSAnT2JqZWN0JyAmJiBpc0Z1bmN0aW9uKGl0LmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHRhZztcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsICRkZWYgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCB0b0luZGV4ID0gJC50b0luZGV4O1xuJGRlZigkZGVmLlAsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4gIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xuICAgIHZhciBPICAgICA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGhpcykpXG4gICAgICAsIGxlbiAgID0gJC50b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZW5kICAgPSBhcmd1bWVudHNbMl1cbiAgICAgICwgZmluICAgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIGNvdW50ID0gTWF0aC5taW4oZmluIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgICAsIGluYyAgID0gMTtcbiAgICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgICAgaW5jICA9IC0xO1xuICAgICAgZnJvbSA9IGZyb20gKyBjb3VudCAtIDE7XG4gICAgICB0byAgID0gdG8gICArIGNvdW50IC0gMTtcbiAgICB9XG4gICAgd2hpbGUoY291bnQtLSA+IDApe1xuICAgICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgdG8gICArPSBpbmM7XG4gICAgICBmcm9tICs9IGluYztcbiAgICB9IHJldHVybiBPO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2NvcHlXaXRoaW4nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvSW5kZXggPSAkLnRvSW5kZXg7XG4kZGVmKCRkZWYuUCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbiAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAgICwgbGVuZ3RoID0gJC50b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChhcmd1bWVudHNbMV0sIGxlbmd0aClcbiAgICAgICwgZW5kICAgID0gYXJndW1lbnRzWzJdXG4gICAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XG4gICAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICAgIHJldHVybiBPO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2ZpbGwnKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciBLRVkgICAgPSAnZmluZEluZGV4J1xuICAsICRkZWYgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIGZvcmNlZCA9IHRydWVcbiAgLCAkZmluZCAgPSByZXF1aXJlKCcuLyQuYXJyYXktbWV0aG9kcycpKDYpO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi8kLnVuc2NvcGUnKShLRVkpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciBLRVkgICAgPSAnZmluZCdcbiAgLCAkZGVmICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBmb3JjZWQgPSB0cnVlXG4gICwgJGZpbmQgID0gcmVxdWlyZSgnLi8kLmFycmF5LW1ldGhvZHMnKSg1KTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi8kLnVuc2NvcGUnKShLRVkpOyIsInZhciAkICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRpdGVyID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIGNhbGwgID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpO1xuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKGFycmF5TGlrZSkpXG4gICAgICAsIG1hcGZuICAgPSBhcmd1bWVudHNbMV1cbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgZiAgICAgICA9IG1hcHBpbmcgPyBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMikgOiB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKCRpdGVyLmlzKE8pKXtcbiAgICAgIGl0ZXJhdG9yID0gJGl0ZXIuZ2V0KE8pO1xuICAgICAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiBpbnN0ZWFkIG9mIGlzRnVuY3Rpb25cbiAgICAgIHJlc3VsdCAgID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KTtcbiAgICAgIGZvcig7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgZiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdHJhbmdlIElFIHF1aXJrcyBtb2RlIGJ1ZyAtPiB1c2UgdHlwZW9mIGluc3RlYWQgb2YgaXNGdW5jdGlvblxuICAgICAgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShsZW5ndGggPSAkLnRvTGVuZ3RoKE8ubGVuZ3RoKSk7XG4gICAgICBmb3IoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCJ2YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgc2V0VW5zY29wZSA9IHJlcXVpcmUoJy4vJC51bnNjb3BlJylcbiAgLCBJVEVSICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsICRpdGVyICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpXG4gICwgc3RlcCAgICAgICA9ICRpdGVyLnN0ZXBcbiAgLCBJdGVyYXRvcnMgID0gJGl0ZXIuSXRlcmF0b3JzO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAkLnNldCh0aGlzLCBJVEVSLCB7bzogJC50b09iamVjdChpdGVyYXRlZCksIGk6IDAsIGs6IGtpbmR9KTtcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxuICAgICwgTyAgICAgPSBpdGVyLm9cbiAgICAsIGtpbmQgID0gaXRlci5rXG4gICAgLCBpbmRleCA9IGl0ZXIuaSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgaXRlci5vID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5zZXRVbnNjb3BlKCdrZXlzJyk7XG5zZXRVbnNjb3BlKCd2YWx1ZXMnKTtcbnNldFVuc2NvcGUoJ2VudHJpZXMnKTsiLCJ2YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgIC8vIHN0cmFuZ2UgSUUgcXVpcmtzIG1vZGUgYnVnIC0+IHVzZSB0eXBlb2YgaW5zdGVhZCBvZiBpc0Z1bmN0aW9uXG4gICAgICAsIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkobGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwicmVxdWlyZSgnLi8kLnNwZWNpZXMnKShBcnJheSk7IiwidmFyICQgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIEhBU19JTlNUQU5DRSAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZighKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkkLnNldERlc2MoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZighJC5pc0Z1bmN0aW9uKHRoaXMpIHx8ICEkLmlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoISQuaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKXJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUoTyA9ICQuZ2V0UHJvdG8oTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgTkFNRSA9ICduYW1lJ1xuICAsIHNldERlc2MgPSAkLnNldERlc2NcbiAgLCBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGdW5jdGlvblByb3RvIHx8ICQuRlcgJiYgJC5ERVNDICYmIHNldERlc2MoRnVuY3Rpb25Qcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKXtcbiAgICB2YXIgbWF0Y2ggPSBTdHJpbmcodGhpcykubWF0Y2goL15cXHMqZnVuY3Rpb24gKFteIChdKikvKVxuICAgICAgLCBuYW1lICA9IG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICAkLmhhcyh0aGlzLCBOQU1FKSB8fCBzZXREZXNjKHRoaXMsIE5BTUUsICQuZGVzYyg1LCBuYW1lKSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICQuaGFzKHRoaXMsIE5BTUUpIHx8IHNldERlc2ModGhpcywgTkFNRSwgJC5kZXNjKDAsIHZhbHVlKSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpOyIsInZhciBJbmZpbml0eSA9IDEgLyAwXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBFICAgICA9IE1hdGguRVxuICAsIHBvdyAgID0gTWF0aC5wb3dcbiAgLCBhYnMgICA9IE1hdGguYWJzXG4gICwgZXhwICAgPSBNYXRoLmV4cFxuICAsIGxvZyAgID0gTWF0aC5sb2dcbiAgLCBzcXJ0ICA9IE1hdGguc3FydFxuICAsIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuZnVuY3Rpb24gcm91bmRUaWVzVG9FdmVuKG4pe1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59XG5cbi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbmZ1bmN0aW9uIHNpZ24oeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn1cbi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbn1cbi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG5mdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IGV4cCh4KSAtIDE7XG59XG5cbiRkZWYoJGRlZi5TLCAnTWF0aCcsIHtcbiAgLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IGlzRmluaXRlKHgpID8gbG9nKHggLyBFICsgc3FydCh4ICsgMSkgKiBzcXJ0KHggLSAxKSAvIEUpICsgMSA6IHg7XG4gIH0sXG4gIC8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbiAgYXNpbmg6IGFzaW5oLFxuICAvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBsb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCl7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIHBvdyhhYnMoeCksIDEgLyAzKTtcbiAgfSxcbiAgLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBmbG9vcihsb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9LFxuICAvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfSxcbiAgLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbiAgZXhwbTE6IGV4cG0xLFxuICAvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbiAgZnJvdW5kOiBmdW5jdGlvbiBmcm91bmQoeCl7XG4gICAgdmFyICRhYnMgID0gYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9LFxuICAvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBsZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgbGVuKXtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZihsYXJnIDwgYXJnKXtcbiAgICAgICAgZGl2ICA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSAgPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmKGFyZyA+IDApe1xuICAgICAgICBkaXYgID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBzcXJ0KHN1bSk7XG4gIH0sXG4gIC8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUludDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJbnQxNiAmIHhuXG4gICAgICAsIHlsID0gVUludDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSW50MTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSW50MTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfSxcbiAgLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbiAgbG9nMXA6IGZ1bmN0aW9uIGxvZzFwKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IGxvZygxICsgeCk7XG4gIH0sXG4gIC8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gbG9nKHgpIC8gTWF0aC5MTjEwO1xuICB9LFxuICAvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4yO1xuICB9LFxuICAvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG4gIHNpZ246IHNpZ24sXG4gIC8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KXtcbiAgICByZXR1cm4gYWJzKHggPSAreCkgPCAxID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDIgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChFIC8gMik7XG4gIH0sXG4gIC8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9LFxuICAvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBpc09iamVjdCAgID0gJC5pc09iamVjdFxuICAsIGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb25cbiAgLCBOVU1CRVIgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgID0gJC5nW05VTUJFUl1cbiAgLCBCYXNlICAgICAgID0gJE51bWJlclxuICAsIHByb3RvICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKGl0KXtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBudW1iZXJcIik7XG59XG5mdW5jdGlvbiB0b051bWJlcihpdCl7XG4gIGlmKGlzT2JqZWN0KGl0KSlpdCA9IHRvUHJpbWl0aXZlKGl0KTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIgJiYgaXQuY2hhckNvZGVBdCgwKSA9PSA0OCl7XG4gICAgdmFyIGJpbmFyeSA9IGZhbHNlO1xuICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IGJpbmFyeSA9IHRydWU7XG4gICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByZXR1cm4gcGFyc2VJbnQoaXQuc2xpY2UoMiksIGJpbmFyeSA/IDIgOiA4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn1cbmlmKCQuRlcgJiYgISgkTnVtYmVyKCcwbzEnKSAmJiAkTnVtYmVyKCcwYjEnKSkpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKGl0KXtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mICROdW1iZXIgPyBuZXcgQmFzZSh0b051bWJlcihpdCkpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICAkLmVhY2guY2FsbCgkLkRFU0MgPyAkLmdldE5hbWVzKEJhc2UpIDogKFxuICAgICAgLy8gRVMzOlxuICAgICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICAgKS5zcGxpdCgnLCcpLCBmdW5jdGlvbihrZXkpe1xuICAgICAgaWYoJC5oYXMoQmFzZSwga2V5KSAmJiAhJC5oYXMoJE51bWJlciwga2V5KSl7XG4gICAgICAgICQuc2V0RGVzYygkTnVtYmVyLCBrZXksICQuZ2V0RGVzYyhCYXNlLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi8kLnJlZGVmJykoJC5nLCBOVU1CRVIsICROdW1iZXIpO1xufSIsInZhciAkICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBhYnMgICA9IE1hdGguYWJzXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gICwgX2lzRmluaXRlID0gJC5nLmlzRmluaXRlXG4gICwgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTE7XG5mdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gISQuaXNPYmplY3QoaXQpICYmIF9pc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn1cbiRkZWYoJGRlZi5TLCAnTnVtYmVyJywge1xuICAvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxuICBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpLFxuICAvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfSxcbiAgLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG4gIGlzSW50ZWdlcjogaXNJbnRlZ2VyLFxuICAvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfSxcbiAgLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gIH0sXG4gIC8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIE1BWF9TQUZFX0lOVEVHRVI6IE1BWF9TQUZFX0lOVEVHRVIsXG4gIC8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuICBNSU5fU0FGRV9JTlRFR0VSOiAtTUFYX1NBRkVfSU5URUdFUixcbiAgLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdCxcbiAgLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuICBwYXJzZUludDogcGFyc2VJbnRcbn0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLmFzc2lnbicpfSk7IiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIGlzOiByZXF1aXJlKCcuLyQuc2FtZScpXG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsInZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBpc09iamVjdCA9ICQuaXNPYmplY3RcbiAgLCB0b09iamVjdCA9ICQudG9PYmplY3Q7XG4kLmVhY2guY2FsbCgoJ2ZyZWV6ZSxzZWFsLHByZXZlbnRFeHRlbnNpb25zLGlzRnJvemVuLGlzU2VhbGVkLGlzRXh0ZW5zaWJsZSwnICtcbiAgJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcixnZXRQcm90b3R5cGVPZixrZXlzLGdldE93blByb3BlcnR5TmFtZXMnKS5zcGxpdCgnLCcpXG4sIGZ1bmN0aW9uKEtFWSwgSUQpe1xuICB2YXIgZm4gICAgID0gKCQuY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGZvcmNlZCA9IDBcbiAgICAsIG1ldGhvZCA9IHt9O1xuICBtZXRob2RbS0VZXSA9IElEID09IDAgPyBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcbiAgfSA6IElEID09IDEgPyBmdW5jdGlvbiBzZWFsKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogaXQ7XG4gIH0gOiBJRCA9PSAyID8gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcbiAgfSA6IElEID09IDMgPyBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IHRydWU7XG4gIH0gOiBJRCA9PSA0ID8gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiB0cnVlO1xuICB9IDogSUQgPT0gNSA/IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGZhbHNlO1xuICB9IDogSUQgPT0gNiA/IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpLCBrZXkpO1xuICB9IDogSUQgPT0gNyA/IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gZm4oT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZChpdCkpKTtcbiAgfSA6IElEID09IDggPyBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpKTtcbiAgfSA6IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKS5nZXQ7XG4gIHRyeSB7XG4gICAgZm4oJ3onKTtcbiAgfSBjYXRjaChlKXtcbiAgICBmb3JjZWQgPSAxO1xuICB9XG4gICRkZWYoJGRlZi5TICsgJGRlZi5GICogZm9yY2VkLCAnT2JqZWN0JywgbWV0aG9kKTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIHRtcCA9IHt9O1xudG1wW3JlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZihyZXF1aXJlKCcuLyQnKS5GVyAmJiBjb2YodG1wKSAhPSAneicpe1xuICByZXF1aXJlKCcuLyQucmVkZWYnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY29mLmNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgY3R4ICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgYXNzZXJ0ICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBmb3JPZiAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvID0gcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldFxuICAsIHNhbWUgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUnKVxuICAsIHNwZWNpZXMgID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMnKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJylcbiAgLCBSRUNPUkQgICA9IHJlcXVpcmUoJy4vJC51aWQnKS5zYWZlKCdyZWNvcmQnKVxuICAsIFBST01JU0UgID0gJ1Byb21pc2UnXG4gICwgZ2xvYmFsICAgPSAkLmdcbiAgLCBwcm9jZXNzICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgPSBjb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgYXNhcCAgICAgPSBwcm9jZXNzICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBQICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIGlzRnVuY3Rpb24gICAgID0gJC5pc0Z1bmN0aW9uXG4gICwgaXNPYmplY3QgICAgICAgPSAkLmlzT2JqZWN0XG4gICwgYXNzZXJ0RnVuY3Rpb24gPSBhc3NlcnQuZm5cbiAgLCBhc3NlcnRPYmplY3QgICA9IGFzc2VydC5vYmpcbiAgLCBXcmFwcGVyO1xuXG5mdW5jdGlvbiB0ZXN0UmVzb2x2ZShzdWIpe1xuICB2YXIgdGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSk7XG4gIGlmKHN1Yil0ZXN0LmNvbnN0cnVjdG9yID0gT2JqZWN0O1xuICByZXR1cm4gUC5yZXNvbHZlKHRlc3QpID09PSB0ZXN0O1xufVxuXG52YXIgdXNlTmF0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gaXNGdW5jdGlvbihQKSAmJiBpc0Z1bmN0aW9uKFAucmVzb2x2ZSkgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYWN0dWFsIFY4IGJ1ZywgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxNjJcbiAgICBpZih3b3JrcyAmJiAkLkRFU0Mpe1xuICAgICAgdmFyIHRoZW5hYmxlVGhlbkdvdHRlbiA9IGZhbHNlO1xuICAgICAgUC5yZXNvbHZlKCQuc2V0RGVzYyh7fSwgJ3RoZW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgdGhlbmFibGVUaGVuR290dGVuID0gdHJ1ZTsgfVxuICAgICAgfSkpO1xuICAgICAgd29ya3MgPSB0aGVuYWJsZVRoZW5Hb3R0ZW47XG4gICAgfVxuICB9IGNhdGNoKGUpeyB3b3JrcyA9IGZhbHNlOyB9XG4gIHJldHVybiB3b3Jrcztcbn0oKTtcblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gaXNQcm9taXNlKGl0KXtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAodXNlTmF0aXZlID8gY29mLmNsYXNzb2YoaXQpID09ICdQcm9taXNlJyA6IFJFQ09SRCBpbiBpdCk7XG59XG5mdW5jdGlvbiBzYW1lQ29uc3RydWN0b3IoYSwgYil7XG4gIC8vIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgaWYoISQuRlcgJiYgYSA9PT0gUCAmJiBiID09PSBXcmFwcGVyKXJldHVybiB0cnVlO1xuICByZXR1cm4gc2FtZShhLCBiKTtcbn1cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yKEMpe1xuICB2YXIgUyA9IGFzc2VydE9iamVjdChDKVtTUEVDSUVTXTtcbiAgcmV0dXJuIFMgIT0gdW5kZWZpbmVkID8gUyA6IEM7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKGl0KXtcbiAgdmFyIHRoZW47XG4gIGlmKGlzT2JqZWN0KGl0KSl0aGVuID0gaXQudGhlbjtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhlbikgPyB0aGVuIDogZmFsc2U7XG59XG5mdW5jdGlvbiBub3RpZnkocmVjb3JkKXtcbiAgdmFyIGNoYWluID0gcmVjb3JkLmM7XG4gIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgaWYoY2hhaW4ubGVuZ3RoKWFzYXAuY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcmVjb3JkLnZcbiAgICAgICwgb2sgICAgPSByZWNvcmQucyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICBmdW5jdGlvbiBydW4ocmVhY3Qpe1xuICAgICAgdmFyIGNiID0gb2sgPyByZWFjdC5vayA6IHJlYWN0LmZhaWxcbiAgICAgICAgLCByZXQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihjYil7XG4gICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcbiAgICAgICAgICByZXQgPSBjYiA9PT0gdHJ1ZSA/IHZhbHVlIDogY2IodmFsdWUpO1xuICAgICAgICAgIGlmKHJldCA9PT0gcmVhY3QuUCl7XG4gICAgICAgICAgICByZWFjdC5yZWooVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXQsIHJlYWN0LnJlcywgcmVhY3QucmVqKTtcbiAgICAgICAgICB9IGVsc2UgcmVhY3QucmVzKHJldCk7XG4gICAgICAgIH0gZWxzZSByZWFjdC5yZWoodmFsdWUpO1xuICAgICAgfSBjYXRjaChlcnIpe1xuICAgICAgICByZWFjdC5yZWooZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgY2hhaW4ubGVuZ3RoID0gMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1VuaGFuZGxlZChwcm9taXNlKXtcbiAgdmFyIHJlY29yZCA9IHByb21pc2VbUkVDT1JEXVxuICAgICwgY2hhaW4gID0gcmVjb3JkLmEgfHwgcmVjb3JkLmNcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlYWN0O1xuICBpZihyZWNvcmQuaClyZXR1cm4gZmFsc2U7XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0ID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdC5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdC5QKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkcmVqZWN0KHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXNcbiAgICAsIHByb21pc2U7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICByZWNvcmQudiA9IHZhbHVlO1xuICByZWNvcmQucyA9IDI7XG4gIHJlY29yZC5hID0gcmVjb3JkLmMuc2xpY2UoKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICBhc2FwLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSA9IHJlY29yZC5wKSl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihnbG9iYWwuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29yZC5hID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICB9LCAxKTtcbiAgbm90aWZ5KHJlY29yZCk7XG59XG5mdW5jdGlvbiAkcmVzb2x2ZSh2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgYXNhcC5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe3I6IHJlY29yZCwgZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighdXNlTmF0aXZlKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFzc2VydEZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgcDogYXNzZXJ0Lmluc3QodGhpcywgUCwgUFJPTUlTRSksICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICB9O1xuICAgICQuaGlkZSh0aGlzLCBSRUNPUkQsIHJlY29yZCk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQubWl4JykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoYXNzZXJ0T2JqZWN0KHRoaXMpLmNvbnN0cnVjdG9yKVtTUEVDSUVTXTtcbiAgICAgIHZhciByZWFjdCA9IHtcbiAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXG4gICAgICAgIGZhaWw6IGlzRnVuY3Rpb24ob25SZWplY3RlZCkgID8gb25SZWplY3RlZCAgOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBwcm9taXNlID0gcmVhY3QuUCA9IG5ldyAoUyAhPSB1bmRlZmluZWQgPyBTIDogUCkoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXMpO1xuICAgICAgICByZWFjdC5yZWogPSBhc3NlcnRGdW5jdGlvbihyZWopO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVjb3JkID0gdGhpc1tSRUNPUkRdO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdCk7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0KTtcbiAgICAgIGlmKHJlY29yZC5zKW5vdGlmeShyZWNvcmQpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGV4cG9ydFxuJGRlZigkZGVmLkcgKyAkZGVmLlcgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCB7UHJvbWlzZTogUH0pO1xuY29mLnNldChQLCBQUk9NSVNFKTtcbnNwZWNpZXMoUCk7XG5zcGVjaWVzKFdyYXBwZXIgPSAkLmNvcmVbUFJPTUlTRV0pO1xuXG4vLyBzdGF0aWNzXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICF1c2VOYXRpdmUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgcmV0dXJuIG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlcywgcmVqKXsgcmVqKHIpOyB9KTtcbiAgfVxufSk7XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICghdXNlTmF0aXZlIHx8IHRlc3RSZXNvbHZlKHRydWUpKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICByZXR1cm4gaXNQcm9taXNlKHgpICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKVxuICAgICAgPyB4IDogbmV3IHRoaXMoZnVuY3Rpb24ocmVzKXsgcmVzKHgpOyB9KTtcbiAgfVxufSk7XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICEodXNlTmF0aXZlICYmIHJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICBQLmFsbChpdGVyKVsnY2F0Y2gnXShmdW5jdGlvbigpe30pO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIHZhbHVlcyA9IFtdO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihyZXMsIHJlail7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHZhbHVlcy5wdXNoLCB2YWx1ZXMpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xuICAgICAgaWYocmVtYWluaW5nKSQuZWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXMocmVzdWx0cyk7XG4gICAgICAgIH0sIHJlaik7XG4gICAgICB9KTtcbiAgICAgIGVsc2UgcmVzKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDID0gZ2V0Q29uc3RydWN0b3IodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKHJlcywgcmVqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCBzZXRQcm90byAgPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJylcbiAgLCAkaXRlciAgICAgPSByZXF1aXJlKCcuLyQuaXRlcicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSVRFUiAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsIHN0ZXAgICAgICA9ICRpdGVyLnN0ZXBcbiAgLCBhc3NlcnQgICAgPSByZXF1aXJlKCcuLyQuYXNzZXJ0JylcbiAgLCBpc09iamVjdCAgPSAkLmlzT2JqZWN0XG4gICwgZ2V0UHJvdG8gID0gJC5nZXRQcm90b1xuICAsICRSZWZsZWN0ICA9ICQuZy5SZWZsZWN0XG4gICwgX2FwcGx5ICAgID0gRnVuY3Rpb24uYXBwbHlcbiAgLCBhc3NlcnRPYmplY3QgPSBhc3NlcnQub2JqXG4gICwgX2lzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBfcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnNcbiAgLy8gSUUgVFAgaGFzIGJyb2tlbiBSZWZsZWN0LmVudW1lcmF0ZVxuICAsIGJ1Z2d5RW51bWVyYXRlID0gISgkUmVmbGVjdCAmJiAkUmVmbGVjdC5lbnVtZXJhdGUgJiYgSVRFUkFUT1IgaW4gJFJlZmxlY3QuZW51bWVyYXRlKHt9KSk7XG5cbmZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XG4gICQuc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgazogdW5kZWZpbmVkLCBpOiAwfSk7XG59XG4kaXRlci5jcmVhdGUoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIGl0ZXIgPSB0aGlzW0lURVJdXG4gICAgLCBrZXlzID0gaXRlci5rXG4gICAgLCBrZXk7XG4gIGlmKGtleXMgPT0gdW5kZWZpbmVkKXtcbiAgICBpdGVyLmsgPSBrZXlzID0gW107XG4gICAgZm9yKGtleSBpbiBpdGVyLm8pa2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgZG8ge1xuICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gc3RlcCgxKTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW2l0ZXIuaSsrXSkgaW4gaXRlci5vKSk7XG4gIHJldHVybiBzdGVwKDAsIGtleSk7XG59KTtcblxudmFyIHJlZmxlY3QgPSB7XG4gIC8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHJldHVybiBfYXBwbHkuY2FsbCh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCk7XG4gIH0sXG4gIC8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgdmFyIHByb3RvICAgID0gYXNzZXJ0LmZuKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdKS5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSAkLmNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAsIHJlc3VsdCAgID0gX2FwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfSxcbiAgLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFzc2VydE9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICAkLnNldERlc2ModGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gJC5nZXREZXNjKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfSxcbiAgLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICAgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgICAsIGRlc2MgPSAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KSwgcHJvdG87XG4gICAgaWYoZGVzYylyZXR1cm4gJC5oYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KSlcbiAgICAgID8gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfSxcbiAgLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9LFxuICAvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfSxcbiAgLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgcmV0dXJuIF9pc0V4dGVuc2libGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xuICB9LFxuICAvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gIG93bktleXM6IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpLFxuICAvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhc3NlcnRPYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYoX3ByZXZlbnRFeHRlbnNpb25zKV9wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIC8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cbiAgICAgICwgb3duRGVzYyAgPSAkLmdldERlc2MoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxuICAgICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICAgIGlmKCFvd25EZXNjKXtcbiAgICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KSkpe1xuICAgICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgb3duRGVzYyA9ICQuZGVzYygwKTtcbiAgICB9XG4gICAgaWYoJC5oYXMob3duRGVzYywgJ3ZhbHVlJykpe1xuICAgICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSAkLmdldERlc2MocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCAkLmRlc2MoMCk7XG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgICAgJC5zZXREZXNjKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbiAgfVxufTtcbi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxuaWYoc2V0UHJvdG8pcmVmbGVjdC5zZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pe1xuICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgdHJ5IHtcbiAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4kZGVmKCRkZWYuRywge1JlZmxlY3Q6IHt9fSk7XG5cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogYnVnZ3lFbnVtZXJhdGUsICdSZWZsZWN0Jywge1xuICAvLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG5cbiRkZWYoJGRlZi5TLCAnUmVmbGVjdCcsIHJlZmxlY3QpOyIsInZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJFJlZ0V4cCA9ICQuZy5SZWdFeHBcbiAgLCBCYXNlICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlICAgICAgPSAvYS9nXG4gIC8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3RcbiAgLCBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlKSAhPT0gcmVcbiAgLy8gUmVnRXhwIGFsbG93cyBhIHJlZ2V4IHdpdGggZmxhZ3MgYXMgdGhlIHBhdHRlcm5cbiAgLCBBTExPV1NfUkVfV0lUSF9GTEFHUyA9IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAkUmVnRXhwKHJlLCAnaScpID09ICcvYS9pJztcbiAgICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIH0oKTtcbmlmKCQuRlcgJiYgJC5ERVNDKXtcbiAgaWYoIUNPUlJFQ1RfTkVXIHx8ICFBTExPV1NfUkVfV0lUSF9GTEFHUyl7XG4gICAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyl7XG4gICAgICB2YXIgcGF0dGVybklzUmVnRXhwICA9IGNvZihwYXR0ZXJuKSA9PSAnUmVnRXhwJ1xuICAgICAgICAsIGZsYWdzSXNVbmRlZmluZWQgPSBmbGFncyA9PT0gdW5kZWZpbmVkO1xuICAgICAgaWYoISh0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cCkgJiYgcGF0dGVybklzUmVnRXhwICYmIGZsYWdzSXNVbmRlZmluZWQpcmV0dXJuIHBhdHRlcm47XG4gICAgICByZXR1cm4gQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwYXR0ZXJuSXNSZWdFeHAgJiYgIWZsYWdzSXNVbmRlZmluZWQgPyBwYXR0ZXJuLnNvdXJjZSA6IHBhdHRlcm4sIGZsYWdzKVxuICAgICAgICA6IG5ldyBCYXNlKHBhdHRlcm5Jc1JlZ0V4cCA/IHBhdHRlcm4uc291cmNlIDogcGF0dGVyblxuICAgICAgICAgICwgcGF0dGVybklzUmVnRXhwICYmIGZsYWdzSXNVbmRlZmluZWQgPyBwYXR0ZXJuLmZsYWdzIDogZmxhZ3MpO1xuICAgIH07XG4gICAgJC5lYWNoLmNhbGwoJC5nZXROYW1lcyhCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgIGtleSBpbiAkUmVnRXhwIHx8ICQuc2V0RGVzYygkUmVnRXhwLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAgICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gICAgcmVxdWlyZSgnLi8kLnJlZGVmJykoJC5nLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG4gIH1cbiAgLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuICBpZigvLi9nLmZsYWdzICE9ICdnJykkLnNldERlc2MocHJvdG8sICdmbGFncycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiByZXF1aXJlKCcuLyQucmVwbGFjZXInKSgvXi4qXFwvKFxcdyopJC8sICckMScpXG4gIH0pO1xufVxucmVxdWlyZSgnLi8kLnNwZWNpZXMnKSgkUmVnRXhwKTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHNbMF0pOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykoZmFsc2UpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvTGVuZ3RoID0gJC50b0xlbmd0aDtcblxuLy8gc2hvdWxkIHRocm93IGVycm9yIG9uIHJlZ2V4XG4kZGVmKCRkZWYuUCArICRkZWYuRiAqICFyZXF1aXJlKCcuLyQudGhyb3dzJykoZnVuY3Rpb24oKXsgJ3EnLmVuZHNXaXRoKC8uLyk7IH0pLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgdmFyIHRoYXQgPSBTdHJpbmcoJC5hc3NlcnREZWZpbmVkKHRoaXMpKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50c1sxXVxuICAgICAgLCBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XG4gICAgcmV0dXJuIHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoU3RyaW5nLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9XG59KTsiLCJ2YXIgJGRlZiAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsIHRvSW5kZXggPSByZXF1aXJlKCcuLyQnKS50b0luZGV4XG4gICwgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRkZWYoJGRlZi5TICsgJGRlZi5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdXG4gICAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjb2YgID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgcmV0dXJuICEhflN0cmluZygkLmFzc2VydERlZmluZWQodGhpcykpLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCJ2YXIgc2V0ICAgPSByZXF1aXJlKCcuLyQnKS5zZXRcbiAgLCAkYXQgICA9IHJlcXVpcmUoJy4vJC5zdHJpbmctYXQnKSh0cnVlKVxuICAsIElURVIgID0gcmVxdWlyZSgnLi8kLnVpZCcpLnNhZmUoJ2l0ZXInKVxuICAsICRpdGVyID0gcmVxdWlyZSgnLi8kLml0ZXInKVxuICAsIHN0ZXAgID0gJGl0ZXIuc3RlcDtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICBzZXQodGhpcywgSVRFUiwge286IFN0cmluZyhpdGVyYXRlZCksIGk6IDB9KTtcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cbiAgICAsIE8gICAgID0gaXRlci5vXG4gICAgLCBpbmRleCA9IGl0ZXIuaVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiBzdGVwKDEpO1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIGl0ZXIuaSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiBzdGVwKDAsIHBvaW50KTtcbn0pOyIsInZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgPSAkLnRvT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuID0gJC50b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBzbG4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyA9IFtdXG4gICAgICAsIGkgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBzbG4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwidmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi8kLnN0cmluZy1yZXBlYXQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNvZiAgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4vLyBzaG91bGQgdGhyb3cgZXJyb3Igb24gcmVnZXhcbiRkZWYoJGRlZi5QICsgJGRlZi5GICogIXJlcXVpcmUoJy4vJC50aHJvd3MnKShmdW5jdGlvbigpeyAncScuc3RhcnRzV2l0aCgvLi8pOyB9KSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgaWYoY29mKHNlYXJjaFN0cmluZykgPT0gJ1JlZ0V4cCcpdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgdmFyIHRoYXQgID0gU3RyaW5nKCQuYXNzZXJ0RGVmaW5lZCh0aGlzKSlcbiAgICAgICwgaW5kZXggPSAkLnRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKTtcbiAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XG4gICAgcmV0dXJuIHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBzZXRUYWcgICA9IHJlcXVpcmUoJy4vJC5jb2YnKS5zZXRcbiAgLCB1aWQgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIHNoYXJlZCAgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpXG4gICwgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcmVkZWYgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpXG4gICwga2V5T2YgICAgPSByZXF1aXJlKCcuLyQua2V5b2YnKVxuICAsIGVudW1LZXlzID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpXG4gICwgYXNzZXJ0T2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFzc2VydCcpLm9ialxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZVxuICAsIERFU0MgICAgID0gJC5ERVNDXG4gICwgaGFzICAgICAgPSAkLmhhc1xuICAsICRjcmVhdGUgID0gJC5jcmVhdGVcbiAgLCBnZXREZXNjICA9ICQuZ2V0RGVzY1xuICAsIHNldERlc2MgID0gJC5zZXREZXNjXG4gICwgZGVzYyAgICAgPSAkLmRlc2NcbiAgLCAkbmFtZXMgICA9IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKVxuICAsIGdldE5hbWVzID0gJG5hbWVzLmdldFxuICAsIHRvT2JqZWN0ID0gJC50b09iamVjdFxuICAsICRTeW1ib2wgID0gJC5nLlN5bWJvbFxuICAsIHNldHRlciAgID0gZmFsc2VcbiAgLCBUQUcgICAgICA9IHVpZCgndGFnJylcbiAgLCBISURERU4gICA9IHVpZCgnaGlkZGVuJylcbiAgLCBfcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIHVzZU5hdGl2ZSA9ICQuaXNGdW5jdGlvbigkU3ltYm9sKTtcblxudmFyIHNldFN5bWJvbERlc2MgPSBERVNDID8gZnVuY3Rpb24oKXsgLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkXG4gIHRyeSB7XG4gICAgcmV0dXJuICRjcmVhdGUoc2V0RGVzYyh7fSwgSElEREVOLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzZXREZXNjKHRoaXMsIEhJRERFTiwge3ZhbHVlOiBmYWxzZX0pW0hJRERFTl07XG4gICAgICB9XG4gICAgfSkpW0hJRERFTl0gfHwgc2V0RGVzYztcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gICAgICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcbiAgICAgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgICAgIHNldERlc2MoaXQsIGtleSwgRCk7XG4gICAgICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbiAgICB9O1xuICB9XG59KCkgOiBzZXREZXNjO1xuXG5mdW5jdGlvbiB3cmFwKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSAkLnNldCgkY3JlYXRlKCRTeW1ib2wucHJvdG90eXBlKSwgVEFHLCB0YWcpO1xuICBERVNDICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgZGVzYygxLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzeW07XG59XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBkZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9ICRjcmVhdGUoRCwge2VudW1lcmFibGU6IGRlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcbn1cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhc3NlcnRPYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b09iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufVxuZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/ICRjcmVhdGUoaXQpIDogZGVmaW5lUHJvcGVydGllcygkY3JlYXRlKGl0KSwgUCk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IF9wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRoaXMsIGtleSk7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cbiAgICA/IEUgOiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b09iamVjdChpdCksIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn1cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b09iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCF1c2VOYXRpdmUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzWzBdKSk7XG4gIH07XG4gICRyZWRlZigkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpc1tUQUddO1xuICB9KTtcblxuICAkLmNyZWF0ZSAgICAgPSBjcmVhdGU7XG4gICQuc2V0RGVzYyAgICA9IGRlZmluZVByb3BlcnR5O1xuICAkLmdldERlc2MgICAgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICQuc2V0RGVzY3MgICA9IGRlZmluZVByb3BlcnRpZXM7XG4gICQuZ2V0TmFtZXMgICA9ICRuYW1lcy5nZXQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAkLmdldFN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoJC5ERVNDICYmICQuRlcpJHJlZGVmKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCBwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXG4gICAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4gICkuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICAgIHZhciBzeW0gPSByZXF1aXJlKCcuLyQud2tzJykoaXQpO1xuICAgIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xuICB9XG4pO1xuXG5zZXR0ZXIgPSB0cnVlO1xuXG4kZGVmKCRkZWYuRyArICRkZWYuVywge1N5bWJvbDogJFN5bWJvbH0pO1xuXG4kZGVmKCRkZWYuUywgJ1N5bWJvbCcsIHN5bWJvbFN0YXRpY3MpO1xuXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICF1c2VOYXRpdmUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKCQuZy5KU09OLCAnSlNPTicsIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHdlYWsgICAgICA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGxlYWtTdG9yZSA9IHdlYWsubGVha1N0b3JlXG4gICwgSUQgICAgICAgID0gd2Vhay5JRFxuICAsIFdFQUsgICAgICA9IHdlYWsuV0VBS1xuICAsIGhhcyAgICAgICA9ICQuaGFzXG4gICwgaXNPYmplY3QgID0gJC5pc09iamVjdFxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCB0bXAgICAgICAgPSB7fTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1dlYWtNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgaWYoaXNPYmplY3Qoa2V5KSl7XG4gICAgICBpZighaXNFeHRlbnNpYmxlKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIGlmKGhhcyhrZXksIFdFQUspKXJldHVybiBrZXlbV0VBS11bdGhpc1tJRF1dO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufSwgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICAkLmVhY2guY2FsbChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZXF1aXJlKCcuLyQucmVkZWYnKShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIHZhciByZXN1bHQgPSBsZWFrU3RvcmUodGhpcylba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1dlYWtTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50c1swXSk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZiAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi8kLmFycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG4kZGVmKCRkZWYuUCwgJ0FycmF5Jywge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9tZW5pYy9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vJC51bnNjb3BlJykoJ2luY2x1ZGVzJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uLzkzNTM3ODFcbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgb3duS2V5cyA9IHJlcXVpcmUoJy4vJC5vd24ta2V5cycpO1xuXG4kZGVmKCRkZWYuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgPSAkLnRvT2JqZWN0KG9iamVjdClcbiAgICAgICwgcmVzdWx0ID0ge307XG4gICAgJC5lYWNoLmNhbGwob3duS2V5cyhPKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICQuc2V0RGVzYyhyZXN1bHQsIGtleSwgJC5kZXNjKDAsICQuZ2V0RGVzYyhPLCBrZXkpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiLy8gaHR0cDovL2dvby5nbC9Ya0JyakRcbnZhciAkICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuZnVuY3Rpb24gY3JlYXRlT2JqZWN0VG9BcnJheShpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgID0gJC50b09iamVjdChvYmplY3QpXG4gICAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhPKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IEFycmF5KGxlbmd0aClcbiAgICAgICwga2V5O1xuICAgIGlmKGlzRW50cmllcyl3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IFtrZXkgPSBrZXlzW2krK10sIE9ba2V5XV07XG4gICAgZWxzZSB3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IE9ba2V5c1tpKytdXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogIGNyZWF0ZU9iamVjdFRvQXJyYXkoZmFsc2UpLFxuICBlbnRyaWVzOiBjcmVhdGVPYmplY3RUb0FycmF5KHRydWUpXG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcbiRkZWYoJGRlZi5TLCAnUmVnRXhwJywge1xuICBlc2NhcGU6IHJlcXVpcmUoJy4vJC5yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicsIHRydWUpXG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuJGRlZigkZGVmLlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJylcbiAgLCAkcGFkID0gcmVxdWlyZSgnLi8kLnN0cmluZy1wYWQnKTtcbiRkZWYoJGRlZi5QLCAnU3RyaW5nJywge1xuICBscGFkOiBmdW5jdGlvbiBscGFkKG4pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG4sIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHBhZCA9IHJlcXVpcmUoJy4vJC5zdHJpbmctcGFkJyk7XG4kZGVmKCRkZWYuUCwgJ1N0cmluZycsIHtcbiAgcnBhZDogZnVuY3Rpb24gcnBhZChuKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBuLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiLy8gSmF2YVNjcmlwdCAxLjYgLyBTdHJhd21hbiBhcnJheSBzdGF0aWNzIHNoaW1cbnZhciAkICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJEFycmF5ICA9ICQuY29yZS5BcnJheSB8fCBBcnJheVxuICAsIHN0YXRpY3MgPSB7fTtcbmZ1bmN0aW9uIHNldFN0YXRpY3Moa2V5cywgbGVuZ3RoKXtcbiAgJC5lYWNoLmNhbGwoa2V5cy5zcGxpdCgnLCcpLCBmdW5jdGlvbihrZXkpe1xuICAgIGlmKGxlbmd0aCA9PSB1bmRlZmluZWQgJiYga2V5IGluICRBcnJheSlzdGF0aWNzW2tleV0gPSAkQXJyYXlba2V5XTtcbiAgICBlbHNlIGlmKGtleSBpbiBbXSlzdGF0aWNzW2tleV0gPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgW11ba2V5XSwgbGVuZ3RoKTtcbiAgfSk7XG59XG5zZXRTdGF0aWNzKCdwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzJywgMSk7XG5zZXRTdGF0aWNzKCdpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzJywgMyk7XG5zZXRTdGF0aWNzKCdqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YsJyArXG4gICAgICAgICAgICdyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsLHR1cm4nKTtcbiRkZWYoJGRlZi5TLCAnQXJyYXknLCBzdGF0aWNzKTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyICQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBJdGVyYXRvcnMgICA9IHJlcXVpcmUoJy4vJC5pdGVyJykuSXRlcmF0b3JzXG4gICwgSVRFUkFUT1IgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheVxuICAsIE5MICAgICAgICAgID0gJC5nLk5vZGVMaXN0XG4gICwgSFRDICAgICAgICAgPSAkLmcuSFRNTENvbGxlY3Rpb25cbiAgLCBOTFByb3RvICAgICA9IE5MICYmIE5MLnByb3RvdHlwZVxuICAsIEhUQ1Byb3RvICAgID0gSFRDICYmIEhUQy5wcm90b3R5cGU7XG5pZigkLkZXKXtcbiAgaWYoTkwgJiYgIShJVEVSQVRPUiBpbiBOTFByb3RvKSkkLmhpZGUoTkxQcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgaWYoSFRDICYmICEoSVRFUkFUT1IgaW4gSFRDUHJvdG8pKSQuaGlkZShIVENQcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbn1cbkl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEFycmF5VmFsdWVzOyIsInZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICR0YXNrID0gcmVxdWlyZSgnLi8kLnRhc2snKTtcbiRkZWYoJGRlZi5HICsgJGRlZi5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgJGRlZiAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgcGFydGlhbCAgID0gcmVxdWlyZSgnLi8kLnBhcnRpYWwnKVxuICAsIG5hdmlnYXRvciA9ICQuZy5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG5mdW5jdGlvbiB3cmFwKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICQuaXNGdW5jdGlvbihmbikgPyBmbiA6IEZ1bmN0aW9uKGZuKVxuICAgICksIHRpbWUpO1xuICB9IDogc2V0O1xufVxuJGRlZigkZGVmLkcgKyAkZGVmLkIgKyAkZGVmLkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKCQuZy5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoJC5nLnNldEludGVydmFsKVxufSk7IiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnN0YXRpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5scGFkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5ycGFkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZ2V4cC5lc2NhcGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnRvLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvanMuYXJyYXkuc3RhdGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvJCcpLmNvcmU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9XG4gICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcblxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChcbiAgICAgIGlubmVyRm4sIHNlbGYgfHwgbnVsbCxcbiAgICAgIG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKVxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIC8vIFRoaXMgaW52b2tlIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gaW4gYSBzdHlsZSB0aGF0IGFzc3VtZXMgc29tZVxuICAgIC8vIGNhbGxpbmcgZnVuY3Rpb24gKG9yIFByb21pc2UpIHdpbGwgaGFuZGxlIGV4Y2VwdGlvbnMuXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2VuZXJhdG9yW21ldGhvZF0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgaW52b2tlTmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIHZhciBpbnZva2VUaHJvdyA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJ0aHJvd1wiKTtcbiAgICB2YXIgaW52b2tlUmV0dXJuID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInJldHVyblwiKTtcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgdmFyIGVucXVldWVSZXN1bHQgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgIH0pIDogbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoaW52b2tlKG1ldGhvZCwgYXJnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBlbnF1ZXVlUmVzdWx0IGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5XG4gICAgICAvLyBsYXRlciBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPSBlbnF1ZXVlUmVzdWx0W1wiY2F0Y2hcIl0oZnVuY3Rpb24oaWdub3JlZCl7fSk7XG5cbiAgICAgIHJldHVybiBlbnF1ZXVlUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvcG9seWZpbGxcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1jb3JlL3BvbHlmaWxsXCIpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJpbXBvcnQge1xuICBvYmplY3RPckZ1bmN0aW9uLFxuICBpc0Z1bmN0aW9uXG59IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQge1xuICBhc2FwXG59IGZyb20gJy4vYXNhcCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyAgID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgID0gMjtcblxudmFyIEdFVF9USEVOX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHNlbGZGdWxsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoKGVycm9yKSB7XG4gICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gR0VUX1RIRU5fRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgIGFzYXAoZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3Rvcikge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0aGVuID0gZ2V0VGhlbihtYXliZVRoZW5hYmxlKTtcblxuICAgIGlmICh0aGVuID09PSBHRVRfVEhFTl9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHRoZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykgeyByZXR1cm47IH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBzdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBFcnJvck9iamVjdCgpIHtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG59XG5cbnZhciBUUllfQ0FUQ0hfRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIG5vb3AsXG4gIHJlc29sdmUsXG4gIHJlamVjdCxcbiAgZnVsZmlsbCxcbiAgc3Vic2NyaWJlLFxuICBwdWJsaXNoLFxuICBwdWJsaXNoUmVqZWN0aW9uLFxuICBpbml0aWFsaXplUHJvbWlzZSxcbiAgaW52b2tlQ2FsbGJhY2ssXG4gIEZVTEZJTExFRCxcbiAgUkVKRUNURUQsXG4gIFBFTkRJTkdcbn07XG4iLCJ2YXIgbGVuID0gMDtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xudmFyIHZlcnR4TmV4dDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbjtcblxuZXhwb3J0IHZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgdmFyIG5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIGluc3RlYWRcbiAgdmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUubWF0Y2goL14oPzooXFxkKylcXC4pPyg/OihcXGQrKVxcLik/KFxcKnxcXGQrKSQvKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmVyc2lvbikgJiYgdmVyc2lvblsxXSA9PT0gJzAnICYmIHZlcnNpb25bMl0gPT09ICcxMCcpIHtcbiAgICBuZXh0VGljayA9IHNldEltbWVkaWF0ZTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9Mikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpKzFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2krMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydGV4KCkge1xuICB0cnkge1xuICAgIHZhciByID0gcmVxdWlyZTtcbiAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydGV4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNBcnJheSxcbiAgaXNNYXliZVRoZW5hYmxlXG59IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQge1xuICBub29wLFxuICByZWplY3QsXG4gIGZ1bGZpbGwsXG4gIHN1YnNjcmliZSxcbiAgRlVMRklMTEVELFxuICBSRUpFQ1RFRCxcbiAgUEVORElOR1xufSBmcm9tICcuLy1pbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gIGVudW1lcmF0b3IucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoZW51bWVyYXRvci5fdmFsaWRhdGVJbnB1dChpbnB1dCkpIHtcbiAgICBlbnVtZXJhdG9yLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICBlbnVtZXJhdG9yLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgZW51bWVyYXRvci5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgZW51bWVyYXRvci5faW5pdCgpO1xuXG4gICAgaWYgKGVudW1lcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICBmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW51bWVyYXRvci5sZW5ndGggPSBlbnVtZXJhdG9yLmxlbmd0aCB8fCAwO1xuICAgICAgZW51bWVyYXRvci5fZW51bWVyYXRlKCk7XG4gICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWplY3QoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl92YWxpZGF0aW9uRXJyb3IoKSk7XG4gIH1cbn1cblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gaXNBcnJheShpbnB1dCk7XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVudW1lcmF0b3I7XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gIHZhciBsZW5ndGggID0gZW51bWVyYXRvci5sZW5ndGg7XG4gIHZhciBwcm9taXNlID0gZW51bWVyYXRvci5wcm9taXNlO1xuICB2YXIgaW5wdXQgICA9IGVudW1lcmF0b3IuX2lucHV0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBlbnVtZXJhdG9yLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuICB2YXIgYyA9IGVudW1lcmF0b3IuX2luc3RhbmNlQ29uc3RydWN0b3I7XG5cbiAgaWYgKGlzTWF5YmVUaGVuYWJsZShlbnRyeSkpIHtcbiAgICBpZiAoZW50cnkuY29uc3RydWN0b3IgPT09IGMgJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICBlbnRyeS5fb25lcnJvciA9IG51bGw7XG4gICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW51bWVyYXRvci5fd2lsbFNldHRsZUF0KGMucmVzb2x2ZShlbnRyeSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcbiAgICBlbnVtZXJhdG9yLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gZW51bWVyYXRvci5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVudW1lcmF0b3IuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcbiIsImltcG9ydCB7XG4gIGlzRnVuY3Rpb25cbn0gZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCB7XG4gIG5vb3AsXG4gIHN1YnNjcmliZSxcbiAgaW5pdGlhbGl6ZVByb21pc2UsXG4gIGludm9rZUNhbGxiYWNrLFxuICBGVUxGSUxMRUQsXG4gIFJFSkVDVEVEXG59IGZyb20gJy4vLWludGVybmFsJztcblxuaW1wb3J0IHtcbiAgYXNhcCxcbiAgc2V0QXNhcCxcbiAgc2V0U2NoZWR1bGVyXG59IGZyb20gJy4vYXNhcCc7XG5cbmltcG9ydCBhbGwgZnJvbSAnLi9wcm9taXNlL2FsbCc7XG5pbXBvcnQgcmFjZSBmcm9tICcuL3Byb21pc2UvcmFjZSc7XG5pbXBvcnQgUmVzb2x2ZSBmcm9tICcuL3Byb21pc2UvcmVzb2x2ZSc7XG5pbXBvcnQgUmVqZWN0IGZyb20gJy4vcHJvbWlzZS9yZWplY3QnO1xuXG52YXIgY291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb21pc2U7XG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgdGhpcy5faWQgPSBjb3VudGVyKys7XG4gIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgbmVlZHNSZXNvbHZlcigpO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgbmVlZHNOZXcoKTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuUHJvbWlzZS5yZXNvbHZlID0gUmVzb2x2ZTtcblByb21pc2UucmVqZWN0ID0gUmVqZWN0O1xuUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlLl9hc2FwID0gYXNhcDtcblxuUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXG4vKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG5cbiAgQ2hhaW5pbmdcbiAgLS0tLS0tLS1cblxuICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcblxuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICB9KTtcbiAgYGBgXG4gIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuXG4gIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cblxuICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuXG4gIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcblxuICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblxuICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICB9KTtcbiAgYGBgXG5cbiAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cblxuICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcmVzdWx0O1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG5cbiAgRXJyYmFjayBFeGFtcGxlXG5cbiAgYGBganNcbiAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG5cbiAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuXG4gIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICBgYGBqYXZhc2NyaXB0XG4gIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gIHRyeSB7XG4gICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcblxuICBFcnJiYWNrIEV4YW1wbGVcblxuICBgYGBqc1xuXG4gIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICB9XG5cbiAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcblxuICB9XG5cbiAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG5cbiAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gIGBgYGphdmFzY3JpcHRcbiAgZmluZEF1dGhvcigpLlxuICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgLy8gZm91bmQgYm9va3NcbiAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuKi9cbiAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgaWYgKHN0YXRlID09PSBGVUxGSUxMRUQgJiYgIW9uRnVsZmlsbG1lbnQgfHwgc3RhdGUgPT09IFJFSkVDVEVEICYmICFvblJlamVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG4gICAgdmFyIHJlc3VsdCA9IHBhcmVudC5fcmVzdWx0O1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfSxcblxuLyoqXG4gIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cblxuICAvLyBzeW5jaHJvbm91c1xuICB0cnkge1xuICAgIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG5cbiAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4qL1xuICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9XG59O1xuIiwiaW1wb3J0IEVudW1lcmF0b3IgZnJvbSAnLi4vZW51bWVyYXRvcic7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICB2YXIgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICB2YXIgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICB2YXIgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIHZhciBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgdmFyIHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNBcnJheVxufSBmcm9tIFwiLi4vdXRpbHNcIjtcblxuaW1wb3J0IHtcbiAgbm9vcCxcbiAgcmVzb2x2ZSxcbiAgcmVqZWN0LFxuICBzdWJzY3JpYmUsXG4gIFBFTkRJTkdcbn0gZnJvbSAnLi4vLWludGVybmFsJztcblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIHZhciBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIG9uRnVsZmlsbG1lbnQodmFsdWUpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHN1YnNjcmliZShDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLCB1bmRlZmluZWQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufVxuIiwiaW1wb3J0IHtcbiAgbm9vcCxcbiAgcmVqZWN0IGFzIF9yZWplY3Rcbn0gZnJvbSAnLi4vLWludGVybmFsJztcblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuIiwiaW1wb3J0IHtcbiAgbm9vcCxcbiAgcmVzb2x2ZSBhcyBfcmVzb2x2ZVxufSBmcm9tICcuLi8taW50ZXJuYWwnO1xuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIF9yZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01heWJlVGhlbmFibGUoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG59XG5cbnZhciBfaXNBcnJheTtcbmlmICghQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn1cblxuZXhwb3J0IHZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBjb25zdCBBVFRSX0lHTk9SRSA9ICdkYXRhLXNrYXRlLWlnbm9yZSc7XG5leHBvcnQgY29uc3QgVFlQRV9BVFRSSUJVVEUgPSAnYSc7XG5leHBvcnQgY29uc3QgVFlQRV9DTEFTU05BTUUgPSAnYyc7XG5leHBvcnQgY29uc3QgVFlQRV9FTEVNRU5UID0gJ3QnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZXNwYWNlID0gJycpIHtcbiAgdmFyIGRhdGEgPSBlbGVtZW50Ll9fU0tBVEVfREFUQSB8fCAoZWxlbWVudC5fX1NLQVRFX0RBVEEgPSB7fSk7XG4gIHJldHVybiBuYW1lc3BhY2UgJiYgKGRhdGFbbmFtZXNwYWNlXSB8fCAoZGF0YVtuYW1lc3BhY2VdID0ge30pKSB8fCBkYXRhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuL2dsb2JhbHMnO1xuaW1wb3J0IHtcbiAgaW5pdEVsZW1lbnRzLFxuICByZW1vdmVFbGVtZW50c1xufSBmcm9tICcuL2xpZmVjeWNsZSc7XG5pbXBvcnQgTXV0YXRpb25PYnNlcnZlciBmcm9tICcuL211dGF0aW9uLW9ic2VydmVyJztcbmltcG9ydCB7XG4gIGdldENsb3Nlc3RJZ25vcmVkRWxlbWVudFxufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBUaGUgZG9jdW1lbnQgb2JzZXJ2ZXIgaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBtdXRhdGlvbnMgVGhlIG11dGF0aW9ucyB0byBoYW5kbGUuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRPYnNlcnZlckhhbmRsZXIgKG11dGF0aW9ucykge1xuICB2YXIgbXV0YXRpb25zTGVuID0gbXV0YXRpb25zLmxlbmd0aDtcblxuICBmb3IgKHZhciBhID0gMDsgYSA8IG11dGF0aW9uc0xlbjsgYSsrKSB7XG4gICAgdmFyIG11dGF0aW9uID0gbXV0YXRpb25zW2FdO1xuICAgIHZhciBhZGRlZE5vZGVzID0gbXV0YXRpb24uYWRkZWROb2RlcztcbiAgICB2YXIgcmVtb3ZlZE5vZGVzID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzO1xuXG4gICAgLy8gU2luY2Ugc2libGluZ3MgYXJlIGJhdGNoZWQgdG9nZXRoZXIsIHdlIGNoZWNrIHRoZSBmaXJzdCBub2RlJ3MgcGFyZW50XG4gICAgLy8gbm9kZSB0byBzZWUgaWYgaXQgaXMgaWdub3JlZC4gSWYgaXQgaXMgdGhlbiB3ZSBkb24ndCBwcm9jZXNzIGFueSBhZGRlZFxuICAgIC8vIG5vZGVzLiBUaGlzIHByZXZlbnRzIGhhdmluZyB0byBjaGVjayBldmVyeSBub2RlLlxuICAgIGlmIChhZGRlZE5vZGVzICYmIGFkZGVkTm9kZXMubGVuZ3RoICYmICFnZXRDbG9zZXN0SWdub3JlZEVsZW1lbnQoYWRkZWROb2Rlc1swXS5wYXJlbnROb2RlKSkge1xuICAgICAgaW5pdEVsZW1lbnRzKGFkZGVkTm9kZXMpO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGNoZWNrIGJhdGNoZWQgbm9kZXMgaGVyZSBiZWNhdXNlIHRoZXkgd29uJ3QgaGF2ZSBhIHBhcmVudCBub2RlLlxuICAgIGlmIChyZW1vdmVkTm9kZXMgJiYgcmVtb3ZlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgcmVtb3ZlRWxlbWVudHMocmVtb3ZlZE5vZGVzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG11dGF0aW9uIG9ic2VydmVyIGZvciBsaXN0ZW5pbmcgdG8gU2thdGUgZGVmaW5pdGlvbnMgZm9yIHRoZVxuICogZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSByb290IFRoZSBlbGVtZW50IHRvIG9ic2VydmUuXG4gKlxuICogQHJldHVybnMge011dGF0aW9uT2JzZXJ2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50T2JzZXJ2ZXIgKCkge1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihkb2N1bWVudE9ic2VydmVySGFuZGxlcik7XG5cbiAgLy8gT2JzZXJ2ZSBhZnRlciB0aGUgRE9NIGNvbnRlbnQgaGFzIGxvYWRlZC5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICByZWdpc3RlcjogZnVuY3Rpb24gKGZpeEllKSB7XG4gICAgLy8gSUUgaGFzIGlzc3VlcyB3aXRoIHJlcG9ydGluZyByZW1vdmVkTm9kZXMgY29ycmVjdGx5LiBTZWUgdGhlIHBvbHlmaWxsIGZvclxuICAgIC8vIGRldGFpbHMuIElmIHdlIGZpeCBJRSwgd2UgbXVzdCBhbHNvIHJlLWRlZmluZSB0aGUgZG9jdW1lbnQgb2JzZXJ2ZXIuXG4gICAgaWYgKGZpeEllKSB7XG4gICAgICBNdXRhdGlvbk9ic2VydmVyLmZpeEllKCk7XG4gICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIWdsb2JhbHMub2JzZXJ2ZXIpIHtcbiAgICAgIGdsb2JhbHMub2JzZXJ2ZXIgPSBjcmVhdGVEb2N1bWVudE9ic2VydmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChnbG9iYWxzLm9ic2VydmVyKSB7XG4gICAgICBnbG9iYWxzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGdsb2JhbHMub2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghd2luZG93Ll9fc2thdGUpIHtcbiAgd2luZG93Ll9fc2thdGUgPSB7XG4gICAgb2JzZXJ2ZXI6IHVuZGVmaW5lZCxcbiAgICByZWdpc3RyeToge31cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2luZG93Ll9fc2thdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7XG4gIEFUVFJfSUdOT1JFXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBkYXRhIGZyb20gJy4vZGF0YSc7XG5pbXBvcnQgTXV0YXRpb25PYnNlcnZlciBmcm9tICcuL211dGF0aW9uLW9ic2VydmVyJztcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL3JlZ2lzdHJ5JztcbmltcG9ydCB7XG4gIGNhbWVsQ2FzZSxcbiAgZWxlbWVudENvbnRhaW5zLFxuICBoYXNPd24sXG4gIGluaGVyaXQsXG4gIG9iakVhY2hcbn0gZnJvbSAnLi91dGlscyc7XG5cbnZhciBlbFByb3RvID0gd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZTtcbnZhciBuYXRpdmVNYXRjaGVzU2VsZWN0b3IgPSAoXG4gIGVsUHJvdG8ubWF0Y2hlcyB8fFxuICBlbFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsUHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsUHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsUHJvdG8ub01hdGNoZXNTZWxlY3RvclxuKTtcbi8vIE9ubHkgSUU5IGhhcyB0aGlzIG1zTWF0Y2hlc1NlbGVjdG9yIGJ1ZywgYnV0IGJlc3QgdG8gZGV0ZWN0IGl0LlxudmFyIGhhc05hdGl2ZU1hdGNoZXNTZWxlY3RvckRldGF0dGFjaGVkQnVnID0gIW5hdGl2ZU1hdGNoZXNTZWxlY3Rvci5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnZGl2Jyk7XG52YXIgbWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGlmIChoYXNOYXRpdmVNYXRjaGVzU2VsZWN0b3JEZXRhdHRhY2hlZEJ1Zykge1xuICAgIHZhciBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKCk7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIHJldHVybiBuYXRpdmVNYXRjaGVzU2VsZWN0b3IuY2FsbChjbG9uZSwgc2VsZWN0b3IpO1xuICB9XG4gIHJldHVybiBuYXRpdmVNYXRjaGVzU2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBldmVudCBkZWZpbml0aW9uIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGl0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlIFRoZSBldmVudCB0byBwYXJzZS5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0XX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudCAoZSkge1xuICB2YXIgcGFydHMgPSBlLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogcGFydHMuc2hpZnQoKSxcbiAgICBkZWxlZ2F0ZTogcGFydHMuam9pbignICcpXG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgZGVmaW5lZCBhdHRyaWJ1dGVzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHdlYiBjb21wb25lbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgVGhlIHdlYiBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBpbml0QXR0cmlidXRlcyAodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgdmFyIGNvbXBvbmVudEF0dHJpYnV0ZXMgPSBjb21wb25lbnQuYXR0cmlidXRlcztcblxuICBpZiAodHlwZW9mIGNvbXBvbmVudEF0dHJpYnV0ZXMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgYXR0cmlidXRlIGluIGNvbXBvbmVudEF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoaGFzT3duKGNvbXBvbmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgJiYgaGFzT3duKGNvbXBvbmVudEF0dHJpYnV0ZXNbYXR0cmlidXRlXSwgJ3ZhbHVlJykgJiYgIXRhcmdldC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgdmFyIHZhbHVlID0gY29tcG9uZW50QXR0cmlidXRlc1thdHRyaWJ1dGVdLnZhbHVlO1xuICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSh0YXJnZXQpIDogdmFsdWU7XG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERlZmluZXMgYSBwcm9wZXJ0eSB0aGF0IHByb3hpZXMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHdlYiBjb21wb25lbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHByb3h5LlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGRlZmluZUF0dHJpYnV0ZVByb3BlcnR5ICh0YXJnZXQsIGF0dHJpYnV0ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjYW1lbENhc2UoYXR0cmlidXRlKSwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQWRkcyBsaW5rcyBmcm9tIGF0dHJpYnV0ZXMgdG8gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgd2ViIGNvbXBvbmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCBUaGUgd2ViIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGFkZEF0dHJpYnV0ZVRvUHJvcGVydHlMaW5rcyAodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgdmFyIGNvbXBvbmVudEF0dHJpYnV0ZXMgPSBjb21wb25lbnQuYXR0cmlidXRlcztcblxuICBpZiAodHlwZW9mIGNvbXBvbmVudEF0dHJpYnV0ZXMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgYXR0cmlidXRlIGluIGNvbXBvbmVudEF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoaGFzT3duKGNvbXBvbmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgJiYgIWhhc093bih0YXJnZXQsIGF0dHJpYnV0ZSkpIHtcbiAgICAgIGRlZmluZUF0dHJpYnV0ZVByb3BlcnR5KHRhcmdldCwgYXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlckF0dHJpYnV0ZUNoYW5nZWQodGFyZ2V0LCBjb21wb25lbnQsIGRhdGEpIHtcbiAgdmFyIGNhbGxiYWNrO1xuICB2YXIgdHlwZTtcbiAgdmFyIG5hbWUgPSBkYXRhLm5hbWU7XG4gIHZhciBuZXdWYWx1ZSA9IGRhdGEubmV3VmFsdWU7XG4gIHZhciBvbGRWYWx1ZSA9IGRhdGEub2xkVmFsdWU7XG4gIHZhciBuZXdWYWx1ZUlzU3RyaW5nID0gdHlwZW9mIG5ld1ZhbHVlID09PSAnc3RyaW5nJztcbiAgdmFyIG9sZFZhbHVlSXNTdHJpbmcgPSB0eXBlb2Ygb2xkVmFsdWUgPT09ICdzdHJpbmcnO1xuICB2YXIgYXR0cnMgPSBjb21wb25lbnQuYXR0cmlidXRlcztcbiAgdmFyIHNwZWNpZmljID0gYXR0cnMgJiYgYXR0cnNbbmFtZV07XG5cbiAgaWYgKCFvbGRWYWx1ZUlzU3RyaW5nICYmIG5ld1ZhbHVlSXNTdHJpbmcpIHtcbiAgICB0eXBlID0gJ2NyZWF0ZWQnO1xuICB9IGVsc2UgaWYgKG9sZFZhbHVlSXNTdHJpbmcgJiYgbmV3VmFsdWVJc1N0cmluZykge1xuICAgIHR5cGUgPSAndXBkYXRlZCc7XG4gIH0gZWxzZSBpZiAob2xkVmFsdWVJc1N0cmluZyAmJiAhbmV3VmFsdWVJc1N0cmluZykge1xuICAgIHR5cGUgPSAncmVtb3ZlZCc7XG4gIH1cblxuICBpZiAoc3BlY2lmaWMgJiYgdHlwZW9mIHNwZWNpZmljW3R5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzcGVjaWZpY1t0eXBlXTtcbiAgfSBlbHNlIGlmIChzcGVjaWZpYyAmJiB0eXBlb2Ygc3BlY2lmaWMuZmFsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHNwZWNpZmljLmZhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjaWZpYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3BlY2lmaWM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBhdHRycztcbiAgfVxuXG4gIC8vIEVuc3VyZSB2YWx1ZXMgYXJlIG51bGwgaWYgdW5kZWZpbmVkLlxuICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogbmV3VmFsdWU7XG4gIG9sZFZhbHVlID0gb2xkVmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvbGRWYWx1ZTtcblxuICAvLyBUaGVyZSBtYXkgc3RpbGwgbm90IGJlIGEgY2FsbGJhY2suXG4gIGlmIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRhcmdldCwge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlnZ2VyQXR0cmlidXRlc0NyZWF0ZWQgKHRhcmdldCwgY29tcG9uZW50KSB7XG4gIHZhciBhO1xuICB2YXIgYXR0cnMgPSB0YXJnZXQuYXR0cmlidXRlcztcbiAgdmFyIGF0dHJzQ29weSA9IFtdO1xuICB2YXIgYXR0cnNMZW4gPSBhdHRycy5sZW5ndGg7XG5cbiAgZm9yIChhID0gMDsgYSA8IGF0dHJzTGVuOyBhKyspIHtcbiAgICBhdHRyc0NvcHkucHVzaChhdHRyc1thXSk7XG4gIH1cblxuICAvLyBJbiBkZWZhdWx0IHdlYiBjb21wb25lbnRzLCBhdHRyaWJ1dGUgY2hhbmdlcyBhcmVuJ3QgdHJpZ2dlcmVkIGZvclxuICAvLyBhdHRyaWJ1dGVzIHRoYXQgYWxyZWFkeSBleGlzdCBvbiBhbiBlbGVtZW50IHdoZW4gaXQgaXMgYm91bmQuIFRoaXMgc3Vja3NcbiAgLy8gd2hlbiB5b3Ugd2FudCB0byByZXVzZSBhbmQgc2VwYXJhdGUgY29kZSBmb3IgYXR0cmlidXRlcyBhd2F5IGZyb20geW91clxuICAvLyBsaWZlY3ljbGUgY2FsbGJhY2tzLiBTa2F0ZSB3aWxsIGluaXRpYWxpc2UgZWFjaCBhdHRyaWJ1dGUgYnkgY2FsbGluZyB0aGVcbiAgLy8gY3JlYXRlZCBjYWxsYmFjayBmb3IgdGhlIGF0dHJpYnV0ZXMgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBlbGVtZW50LlxuICBmb3IgKGEgPSAwOyBhIDwgYXR0cnNMZW47IGErKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNDb3B5W2FdO1xuICAgIHRyaWdnZXJBdHRyaWJ1dGVDaGFuZ2VkKHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgICBuYW1lOiBhdHRyLm5vZGVOYW1lLFxuICAgICAgbmV3VmFsdWU6IGF0dHIudmFsdWUgfHwgYXR0ci5ub2RlVmFsdWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRBdHRyaWJ1dGVMaXN0ZW5lcnMgKHRhcmdldCwgY29tcG9uZW50KSB7XG4gIHZhciBhdHRycyA9IHRhcmdldC5hdHRyaWJ1dGVzO1xuXG4gIGlmICghY29tcG9uZW50LmF0dHJpYnV0ZXMgfHwgcmVnaXN0cnkuaXNOYXRpdmVDdXN0b21FbGVtZW50KGNvbXBvbmVudC5pZCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICB2YXIgbmFtZSA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgYXR0ciA9IGF0dHJzW25hbWVdO1xuXG4gICAgICB0cmlnZ2VyQXR0cmlidXRlQ2hhbmdlZCh0YXJnZXQsIGNvbXBvbmVudCwge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBuZXdWYWx1ZTogYXR0ciAmJiAoYXR0ci52YWx1ZSB8fCBhdHRyLm5vZGVWYWx1ZSksXG4gICAgICAgIG9sZFZhbHVlOiBtdXRhdGlvbi5vbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kcyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIGNvbXBvbmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IGRhdGEuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMgKHRhcmdldCwgY29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50LmV2ZW50cyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlSGFuZGxlciAoaGFuZGxlciwgZGVsZWdhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBkZWxlZ2F0aW5nLCB0cmlnZ2VyIGRpcmVjdGx5IG9uIHRoZSBjb21wb25lbnQgZWxlbWVudC5cbiAgICAgIGlmICghZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodGFyZ2V0LCBlLCB0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBkZWxlZ2F0aW5nLCBidXQgdGhlIHRhcmdldCBkb2Vzbid0IG1hdGNoLCB0aGVuIHdlJ3ZlIGhhdmVcbiAgICAgIC8vIHRvIGdvIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBtYXRjaGluZyBhbmNlc3RvciBvciBzdG9wIGF0IHRoZVxuICAgICAgLy8gY29tcG9uZW50IGVsZW1lbnQsIG9yIGRvY3VtZW50LiBJZiBhIG1hdGNoaW5nIGFuY2VzdG9yIGlzIGZvdW5kLCB0aGVcbiAgICAgIC8vIGhhbmRsZXIgaXMgdHJpZ2dlcmVkIG9uIGl0LlxuICAgICAgdmFyIGN1cnJlbnQgPSBlLnRhcmdldDtcblxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQgJiYgY3VycmVudCAhPT0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3RvcihjdXJyZW50LCBkZWxlZ2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlcih0YXJnZXQsIGUsIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgb2JqRWFjaChjb21wb25lbnQuZXZlbnRzLCBmdW5jdGlvbiAoaGFuZGxlciwgbmFtZSkge1xuICAgIHZhciBldnQgPSBwYXJzZUV2ZW50KG5hbWUpO1xuICAgIHZhciB1c2VDYXB0dXJlID0gISFldnQuZGVsZWdhdGUgJiYgKGV2dC5uYW1lID09PSAnYmx1cicgfHwgZXZ0Lm5hbWUgPT09ICdmb2N1cycpO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2dC5uYW1lLCBtYWtlSGFuZGxlcihoYW5kbGVyLCBldnQuZGVsZWdhdGUpLCB1c2VDYXB0dXJlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlIGNyZWF0ZWQgbGlmZWN5Y2xlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSBjb21wb25lbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCBkYXRhLlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJDcmVhdGVkICh0YXJnZXQsIGNvbXBvbmVudCkge1xuICB2YXIgdGFyZ2V0RGF0YSA9IGRhdGEodGFyZ2V0LCBjb21wb25lbnQuaWQpO1xuXG4gIGlmICh0YXJnZXREYXRhLmNyZWF0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0YXJnZXREYXRhLmNyZWF0ZWQgPSB0cnVlO1xuXG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBuZWVkIHRvIGhhcHBlbiBpZiB1c2luZyBuYXRpdmUuXG4gIGluaGVyaXQodGFyZ2V0LCBjb21wb25lbnQucHJvdG90eXBlLCB0cnVlKTtcblxuICAvLyBXZSB1c2UgdGhlIHVucmVzb2x2ZWQgLyByZXNvbHZlZCBhdHRyaWJ1dGVzIHRvIGZsYWcgd2hldGhlciBvciBub3QgdGhlXG4gIC8vIGVsZW1lbnQgaGFzIGJlZW4gdGVtcGxhdGVkIG9yIG5vdC5cbiAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZSAmJiAhdGFyZ2V0Lmhhc0F0dHJpYnV0ZShjb21wb25lbnQucmVzb2x2ZWRBdHRyaWJ1dGUpKSB7XG4gICAgY29tcG9uZW50LnRlbXBsYXRlKHRhcmdldCk7XG4gIH1cblxuICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKGNvbXBvbmVudC51bnJlc29sdmVkQXR0cmlidXRlKTtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShjb21wb25lbnQucmVzb2x2ZWRBdHRyaWJ1dGUsICcnKTtcbiAgYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCBjb21wb25lbnQpO1xuICBhZGRBdHRyaWJ1dGVMaXN0ZW5lcnModGFyZ2V0LCBjb21wb25lbnQpO1xuICBhZGRBdHRyaWJ1dGVUb1Byb3BlcnR5TGlua3ModGFyZ2V0LCBjb21wb25lbnQpO1xuICBpbml0QXR0cmlidXRlcyh0YXJnZXQsIGNvbXBvbmVudCk7XG4gIHRyaWdnZXJBdHRyaWJ1dGVzQ3JlYXRlZCh0YXJnZXQsIGNvbXBvbmVudCk7XG5cbiAgaWYgKGNvbXBvbmVudC5jcmVhdGVkKSB7XG4gICAgY29tcG9uZW50LmNyZWF0ZWQodGFyZ2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIFRyaWdnZXJzIHRoZSBhdHRhY2hlZCBsaWZlY3ljbGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIGNvbXBvbmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IGRhdGEuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckF0dGFjaGVkICh0YXJnZXQsIGNvbXBvbmVudCkge1xuICB2YXIgdGFyZ2V0RGF0YSA9IGRhdGEodGFyZ2V0LCBjb21wb25lbnQuaWQpO1xuXG4gIGlmICh0YXJnZXREYXRhLmF0dGFjaGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFlbGVtZW50Q29udGFpbnMoZG9jdW1lbnQsIHRhcmdldCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0YXJnZXREYXRhLmF0dGFjaGVkID0gdHJ1ZTtcblxuICBpZiAoY29tcG9uZW50LmF0dGFjaGVkKSB7XG4gICAgY29tcG9uZW50LmF0dGFjaGVkKHRhcmdldCk7XG4gIH1cblxuICB0YXJnZXREYXRhLmRldGFjaGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlIGRldGFjaGVkIGxpZmVjeWNsZSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgY29tcG9uZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgZGF0YS5cbiAqXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRGV0YWNoZWQgKHRhcmdldCwgY29tcG9uZW50KSB7XG4gIHZhciB0YXJnZXREYXRhID0gZGF0YSh0YXJnZXQsIGNvbXBvbmVudC5pZCk7XG5cbiAgaWYgKHRhcmdldERhdGEuZGV0YWNoZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0YXJnZXREYXRhLmRldGFjaGVkID0gdHJ1ZTtcblxuICBpZiAoY29tcG9uZW50LmRldGFjaGVkKSB7XG4gICAgY29tcG9uZW50LmRldGFjaGVkKHRhcmdldCk7XG4gIH1cblxuICB0YXJnZXREYXRhLmF0dGFjaGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlIGVudGlyZSBlbGVtZW50IGxpZmVjeWNsZSBpZiBpdCdzIG5vdCBiZWluZyBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSBjb21wb25lbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCBkYXRhLlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJMaWZlY3ljbGUgKHRhcmdldCwgY29tcG9uZW50KSB7XG4gIHRyaWdnZXJDcmVhdGVkKHRhcmdldCwgY29tcG9uZW50KTtcbiAgdHJpZ2dlckF0dGFjaGVkKHRhcmdldCwgY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXNlcyBhIHNldCBvZiBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0RPTU5vZGVMaXN0IHwgQXJyYXl9IGVsZW1lbnRzIEEgdHJhdmVyc2FibGUgc2V0IG9mIGVsZW1lbnRzLlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRFbGVtZW50cyAoZWxlbWVudHMpIHtcbiAgdmFyIGVsZW1lbnRzTGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGEgPSAwOyBhIDwgZWxlbWVudHNMZW47IGErKykge1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbYV07XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSB8fCBlbGVtZW50LmF0dHJpYnV0ZXNbQVRUUl9JR05PUkVdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE5vZGVEZWZpbml0aW9ucyA9IHJlZ2lzdHJ5LmdldEZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgdmFyIGN1cnJlbnROb2RlRGVmaW5pdGlvbnNMZW5ndGggPSBjdXJyZW50Tm9kZURlZmluaXRpb25zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY3VycmVudE5vZGVEZWZpbml0aW9uc0xlbmd0aDsgYisrKSB7XG4gICAgICB0cmlnZ2VyTGlmZWN5Y2xlKGVsZW1lbnQsIGN1cnJlbnROb2RlRGVmaW5pdGlvbnNbYl0pO1xuICAgIH1cblxuICAgIC8vIFdoZW4gPG9iamVjdD4gdGFnIGlzIHVzZWQgdG8gZXhwb3NlIE5QQVBJIGFwaSB0byBqcyBtYXkgaGF2ZSBkaWZmZXJlbnQgYmVoYXZpb3VyIHRoZW4gb3RoZXJcbiAgICAvLyB0YWdzLiBPbmUgb2YgdGhvc2UgZGlmZmVyZW5jZXMgaXMgdGhhdCBpdCdzIGNoaWxkTm9kZXMgY2FuIGJlIHVuZGVmaW5lZC5cbiAgICB2YXIgZWxlbWVudENoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXMgfHwgW107XG4gICAgdmFyIGVsZW1lbnRDaGlsZE5vZGVzTGVuID0gZWxlbWVudENoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKGVsZW1lbnRDaGlsZE5vZGVzTGVuKSB7XG4gICAgICBpbml0RWxlbWVudHMoZWxlbWVudENoaWxkTm9kZXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRyaWdnZXJzIHRoZSByZW1vdmUgbGlmZWN5Y2xlIGNhbGxiYWNrIG9uIGFsbCBvZiB0aGUgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtET01Ob2RlTGlzdH0gZWxlbWVudHMgVGhlIGVsZW1lbnRzIHRvIHRyaWdnZXIgdGhlIHJlbW92ZSBsaWZlY3ljbGVcbiAqIGNhbGxiYWNrIG9uLlxuICpcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRzIChlbGVtZW50cykge1xuICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGEgPSAwOyBhIDwgbGVuOyBhKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2FdO1xuXG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlbW92ZUVsZW1lbnRzKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG5cbiAgICB2YXIgZGVmaW5pdGlvbnMgPSByZWdpc3RyeS5nZXRGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgIHZhciBkZWZpbml0aW9uc0xlbiA9IGRlZmluaXRpb25zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgZGVmaW5pdGlvbnNMZW47IGIrKykge1xuICAgICAgdHJpZ2dlckRldGFjaGVkKGVsZW1lbnQsIGRlZmluaXRpb25zW2JdKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgaW5pdEVsZW1lbnRzLFxuICByZW1vdmVFbGVtZW50cyxcbiAgdHJpZ2dlckF0dGFjaGVkLFxuICB0cmlnZ2VyQXR0cmlidXRlQ2hhbmdlZCxcbiAgdHJpZ2dlckNyZWF0ZWQsXG4gIHRyaWdnZXJEZXRhY2hlZFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtcbiAgZGVib3VuY2UsXG4gIGVsZW1lbnRDb250YWlucyxcbiAgZWxlbWVudFByb3RvdHlwZSxcbiAgb2JqRWFjaFxufSBmcm9tICcuL3V0aWxzJztcblxudmFyIEF0dHIgPSB3aW5kb3cuQXR0cjtcbnZhciBOYXRpdmVNdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNGaXhpbmdJZSA9IGZhbHNlO1xudmFyIGlzSWUgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPiAtMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG11dGF0aW9uIHJlY29yZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgSFRNTCBlbGVtZW50IHRoYXQgd2FzIGFmZmVjdGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgbXV0YXRpb24uXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbmV3TXV0YXRpb25SZWNvcmQgKHRhcmdldCwgdHlwZSkge1xuICByZXR1cm4ge1xuICAgIGFkZGVkTm9kZXM6IG51bGwsXG4gICAgYXR0cmlidXRlTmFtZTogbnVsbCxcbiAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgbmV4dFNpYmxpbmc6IG51bGwsXG4gICAgb2xkVmFsdWU6IG51bGwsXG4gICAgcHJldmlvdXNTaWJsaW5nOiBudWxsLFxuICAgIHJlbW92ZWROb2RlczogbnVsbCxcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0eXBlOiB0eXBlIHx8ICdjaGlsZExpc3QnXG4gIH07XG59XG5cbi8qKlxuICogVGFrZXMgYW4gZWxlbWVudCBhbmQgcmVjdXJzaXZlbHkgc2F2ZXMgaXQncyB0cmVlIHN0cnVjdHVyZSBvbiBlYWNoIGVsZW1lbnQgc29cbiAqIHRoYXQgdGhleSBjYW4gYmUgcmVzdG9yZWQgbGF0ZXIgYWZ0ZXIgSUUgc2NyZXdzIHRoaW5ncyB1cC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gc2F2ZSB0aGUgdHJlZSBmb3IuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gd2Fsa1RyZWUgKG5vZGUsIGNiKSB7XG4gIHZhciBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXG4gIGlmICghY2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZE5vZGVzTGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgYSA9IDA7IGEgPCBjaGlsZE5vZGVzTGVuOyBhKyspIHtcbiAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1thXTtcbiAgICBjYihjaGlsZE5vZGUpO1xuICAgIHdhbGtUcmVlKGNoaWxkTm9kZSwgY2IpO1xuICB9XG59XG5cbi8vIE11dGF0aW9uIE9ic2VydmVyIFwiUG9seWZpbGxcIlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRoaXMgXCJwb2x5ZmlsbFwiIG9ubHkgcG9seWZpbGxzIHdoYXQgd2UgbmVlZCBmb3IgU2thdGUgdG8gZnVuY3Rpb24uIEl0XG4gKiBiYXRjaGVzIHVwZGF0ZXMgYW5kIGRvZXMgdGhlIGJhcmUgbWluaW11bSBkdXJpbmcgc3luY2hyb25vdXMgb3BlcmF0aW9uXG4gKiB3aGljaCBtYWtlIG11dGF0aW9uIGV2ZW50IHBlcmZvcm1hbmNlIGJlYXJhYmxlLiBUaGUgcmVzdCBpcyBiYXRjaGVkIG9uIHRoZVxuICogbmV4dCB0aWNrLiBMaWtlIG11dGF0aW9uIG9ic2VydmVycywgZWFjaCBtdXRhdGlvbiBpcyBkaXZpZGVkIGludG8gc2libGluZ1xuICogZ3JvdXBzIGZvciBlYWNoIHBhcmVudCB0aGF0IGhhZCBtdXRhdGlvbnMuIEFsbCBhdHRyaWJ1dGUgbXV0YXRpb25zIGFyZVxuICogYmF0Y2hlZCBpbnRvIHNlcGFyYXRlIHJlY29yZHMgcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCB0aGV5IG9jY3VyZWQgb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2l0aCB0aGUgbXV0YXRpb24gaW5mby5cbiAqXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBNdXRhdGlvbk9ic2VydmVyIChjYWxsYmFjaykge1xuICBpZiAoTmF0aXZlTXV0YXRpb25PYnNlcnZlciAmJiAhaXNGaXhpbmdJZSkge1xuICAgIHJldHVybiBuZXcgTmF0aXZlTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gIH1cblxuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuZWxlbWVudHMgPSBbXTtcbn1cblxuLyoqXG4gKiBJRSAxMSBoYXMgYSBidWcgdGhhdCBwcmV2ZW50cyBkZXNjZW5kYW50IG5vZGVzIGZyb20gYmVpbmcgcmVwb3J0ZWQgYXMgcmVtb3ZlZFxuICogdG8gYSBtdXRhdGlvbiBvYnNlcnZlciBpbiBJRSAxMSBpZiBhbiBhbmNlc3RvciBub2RlJ3MgaW5uZXJIVE1MIGlzIHJlc2V0LlxuICogVGhpcyBzYW1lIGJ1ZyBhbHNvIGhhcHBlbnMgd2hlbiB1c2luZyBNdXRhdGlvbiBFdmVudHMgaW4gSUUgOSAvIDEwLiBCZWNhdXNlIG9mXG4gKiB0aGlzLCB3ZSBtdXN0IGVuc3VyZSB0aGF0IG9ic2VydmVycyBhbmQgZXZlbnRzIGdldCB0cmlnZ2VyZWQgcHJvcGVybHkgb25cbiAqIHRob3NlIGRlc2NlbmRhbnQgbm9kZXMuIEluIG9yZGVyIHRvIGRvIHRoaXMgd2UgaGF2ZSB0byBvdmVycmlkZSBgaW5uZXJIVE1MYFxuICogYW5kIHRoZW4gbWFudWFsbHkgdHJpZ2dlciBhbiBldmVudC5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODE3MTMyL2llLTExLWNoaWxkbm9kZXMtYXJlLW1pc3NpbmctZnJvbS1tdXRhdGlvbm9ic2VydmVyLW11dGF0aW9ucy1yZW1vdmVkbm9kZXMtYWZ0ZXItc2V0dGluZy1pbm5lcmh0bWxcbiAqXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5NdXRhdGlvbk9ic2VydmVyLmZpeEllID0gZnVuY3Rpb24gKCkge1xuICAvLyBGaXggb25jZSBvbmx5IGlmIHdlIG5lZWQgdG8uXG4gIGlmICghaXNJZSB8fCBpc0ZpeGluZ0llKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSB0byBjYWxsIHRoZSBvbGQgaW5uZXJIVE1MIGdldHRlciBhbmQgc2V0dGVyLlxuICB2YXIgb2xkSW5uZXJIVE1MID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50UHJvdG90eXBlLCAnaW5uZXJIVE1MJyk7XG5cbiAgLy8gVGhpcyByZWRlZmluZXMgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBlbnN1cmUgdGhhdCBldmVudHNcbiAgLy8gYXJlIHByb3Blcmx5IHRyaWdnZXJlZC5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRQcm90b3R5cGUsICdpbm5lckhUTUwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb2xkSW5uZXJIVE1MLmdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgd2Fsa1RyZWUodGhpcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG11dGF0aW9uRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTXV0YXRpb25FdmVudCcpO1xuICAgICAgICBtdXRhdGlvbkV2ZW50LmluaXRNdXRhdGlvbkV2ZW50KCdET01Ob2RlUmVtb3ZlZCcsIHRydWUsIGZhbHNlLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG11dGF0aW9uRXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIG9sZElubmVySFRNTC5zZXQuY2FsbCh0aGlzLCBodG1sKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZsYWcgc28gdGhlIHBvbHlmaWxsIGlzIHVzZWQgZm9yIGFsbCBzdWJzZXF1ZW50IE11dGF0aW9uIE9ic2VydmVyIG9iamVjdHMuXG4gIGlzRml4aW5nSWUgPSB0cnVlO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE11dGF0aW9uT2JzZXJ2ZXIsICdpc0ZpeGluZ0llJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNGaXhpbmdJZTtcbiAgfVxufSk7XG5cbk11dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBvYnNlcnZlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gYWRkRXZlbnRUb0JhdGNoIChlKSB7XG4gICAgICBiYXRjaGVkRXZlbnRzLnB1c2goZSk7XG4gICAgICBiYXRjaEV2ZW50cygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhdGNoRXZlbnQgKGUpIHtcbiAgICAgIHZhciBlVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgIC8vIEluIHNvbWUgdGVzdCBlbnZpcm9ubWVudHMsIGUudGFyZ2V0IGhhcyBiZWVuIG51bGxlZCBhZnRlciB0aGUgdGVzdHNcbiAgICAgIC8vIGFyZSBkb25lIGFuZCBhIGJhdGNoIGlzIHN0aWxsIHByb2Nlc3NpbmcuXG4gICAgICBpZiAoIWVUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZVR5cGUgPSBlLnR5cGU7XG4gICAgICB2YXIgZVRhcmdldFBhcmVudCA9IGVUYXJnZXQucGFyZW50Tm9kZTtcblxuICAgICAgaWYgKCFjYW5UcmlnZ2VySW5zZXJ0T3JSZW1vdmUoZVRhcmdldFBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgc2FtZSBidWcgdGhhdCBhZmZlY3RzIElFIDExIGFsc28gYWZmZWN0cyBJRSA5IC8gMTAgd2l0aCBNdXRhdGlvblxuICAgICAgLy8gRXZlbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIElFIDExIGJ1ZzogaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MTcxMzIvaWUtMTEtY2hpbGRub2Rlcy1hcmUtbWlzc2luZy1mcm9tLW11dGF0aW9ub2JzZXJ2ZXItbXV0YXRpb25zLXJlbW92ZWRub2Rlcy1hZnRlci1zZXR0aW5nLWlubmVyaHRtbFxuICAgICAgdmFyIHNob3VsZFdvcmtBcm91bmRJZVJlbW92ZUJ1ZyA9IGlzRml4aW5nSWUgJiYgZVR5cGUgPT09ICdET01Ob2RlUmVtb3ZlZCc7XG4gICAgICB2YXIgaXNEZXNjZW5kYW50ID0gbGFzdEJhdGNoZWRFbGVtZW50ICYmIGxhc3RCYXRjaGVkRWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtZW50Q29udGFpbnMobGFzdEJhdGNoZWRFbGVtZW50LCBlVGFyZ2V0KTtcblxuICAgICAgLy8gVGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiB0aGUgbGFzdCBiYXRjaGVkXG4gICAgICAvLyBlbGVtZW50LiBJZiBpdCBpcywgdGhlbiB3ZSBkb24ndCBiYXRjaCBpdCBiZWNhdXNlIGVsZW1lbnRzIGFyZVxuICAgICAgLy8gYmF0Y2hlZCBpbnRvIGZpcnN0LWNoaWxkcmVuIG9mIGEgZ2l2ZW4gcGFyZW50LiBIb3dldmVyLCBJRSBpcyAob2ZcbiAgICAgIC8vIGNvdXJzZSkgYW4gZXhjZXB0aW9uIHRvIHRoaXMgYW5kIGRlc3Ryb3lzIHRoZSBET00gdHJlZSBoZWlyYXJjaHlcbiAgICAgIC8vIGJlZm9yZSB0aGUgY2FsbGJhY2sgZ2V0cyBmaXJlZCBpZiB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZC4gQmVjYXVzZSBvZlxuICAgICAgLy8gdGhpcywgd2UgaGF2ZSB0byBsZXQgdGhyb3VnaCBhbGwgZGVzY2VuZGFudHMgdGhhdCBoYWQgdGhlIGV2ZW50XG4gICAgICAvLyB0cmlnZ2VyZWQgb24gaXQuXG4gICAgICBpZiAoIXNob3VsZFdvcmtBcm91bmRJZVJlbW92ZUJ1ZyAmJiBpc0Rlc2NlbmRhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxhc3RCYXRjaGVkUmVjb3JkIHx8IGxhc3RCYXRjaGVkUmVjb3JkLnRhcmdldCAhPT0gZVRhcmdldFBhcmVudCkge1xuICAgICAgICBiYXRjaGVkUmVjb3Jkcy5wdXNoKGxhc3RCYXRjaGVkUmVjb3JkID0gbmV3TXV0YXRpb25SZWNvcmQoZVRhcmdldFBhcmVudCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZVR5cGUgPT09ICdET01Ob2RlSW5zZXJ0ZWQnKSB7XG4gICAgICAgIGlmICghbGFzdEJhdGNoZWRSZWNvcmQuYWRkZWROb2Rlcykge1xuICAgICAgICAgIGxhc3RCYXRjaGVkUmVjb3JkLmFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RCYXRjaGVkUmVjb3JkLmFkZGVkTm9kZXMucHVzaChlVGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbGFzdEJhdGNoZWRSZWNvcmQucmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgbGFzdEJhdGNoZWRSZWNvcmQucmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0QmF0Y2hlZFJlY29yZC5yZW1vdmVkTm9kZXMucHVzaChlVGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgbGFzdEJhdGNoZWRFbGVtZW50ID0gZVRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5UcmlnZ2VyQXR0cmlidXRlTW9kaWZpY2F0aW9uIChlVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hdHRyaWJ1dGVzICYmIChvcHRpb25zLnN1YnRyZWUgfHwgZVRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5UcmlnZ2VySW5zZXJ0T3JSZW1vdmUgKGVUYXJnZXRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNoaWxkTGlzdCAmJiAob3B0aW9ucy5zdWJ0cmVlIHx8IGVUYXJnZXRQYXJlbnQgPT09IHRhcmdldCk7XG4gICAgfVxuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgLy8gQmF0Y2hpbmcgaW5zZXJ0IGFuZCByZW1vdmUuXG4gICAgdmFyIGxhc3RCYXRjaGVkRWxlbWVudDtcbiAgICB2YXIgbGFzdEJhdGNoZWRSZWNvcmQ7XG4gICAgdmFyIGJhdGNoZWRFdmVudHMgPSBbXTtcbiAgICB2YXIgYmF0Y2hlZFJlY29yZHMgPSBbXTtcbiAgICB2YXIgYmF0Y2hFdmVudHMgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXRjaGVkRXZlbnRzTGVuID0gYmF0Y2hlZEV2ZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBiYXRjaGVkRXZlbnRzTGVuOyBhKyspIHtcbiAgICAgICAgICBiYXRjaEV2ZW50KGJhdGNoZWRFdmVudHNbYV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5jYWxsYmFjayhiYXRjaGVkUmVjb3Jkcyk7XG4gICAgICAgIGJhdGNoZWRFdmVudHMgPSBbXTtcbiAgICAgICAgYmF0Y2hlZFJlY29yZHMgPSBbXTtcbiAgICAgICAgbGFzdEJhdGNoZWRFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0QmF0Y2hlZFJlY29yZCA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgLy8gQmF0Y2hpbmcgYXR0cmlidXRlcy5cbiAgICB2YXIgYXR0cmlidXRlT2xkVmFsdWVDYWNoZSA9IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVNdXRhdGlvbnMgPSBbXTtcbiAgICB2YXIgYmF0Y2hBdHRyaWJ1dGVNb2RzID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgb2xkIGxlbmd0aCBqdXN0IGluIGNhc2UgYXR0cmlidXRlcyBhcmVcbiAgICAgIC8vIG1vZGlmaWVkIHdpdGhpbiBhIGhhbmRsZXIuXG4gICAgICB2YXIgbGVuID0gYXR0cmlidXRlTXV0YXRpb25zLmxlbmd0aDtcblxuICAgICAgLy8gQ2FsbCB0aGUgaGFuZGxlciB3aXRoIHRoZSBjdXJyZW50IG1vZGlmaWNhdGlvbnMuXG4gICAgICB0aGF0LmNhbGxiYWNrKGF0dHJpYnV0ZU11dGF0aW9ucyk7XG5cbiAgICAgIC8vIFdlIHJlbW92ZSBvbmx5IHVwIHRvIHRoZSBjdXJyZW50IHBvaW50IGp1c3QgaW4gY2FzZSBtb3JlXG4gICAgICAvLyBtb2RpZmljYXRpb25zIHdlcmUgcXVldWVkLlxuICAgICAgYXR0cmlidXRlTXV0YXRpb25zLnNwbGljZSgwLCBsZW4pO1xuICAgIH0pO1xuXG4gICAgdmFyIG9ic2VydmVkID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgaW5zZXJ0SGFuZGxlcjogYWRkRXZlbnRUb0JhdGNoLFxuICAgICAgcmVtb3ZlSGFuZGxlcjogYWRkRXZlbnRUb0JhdGNoLFxuICAgICAgYXR0cmlidXRlSGFuZGxlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgICAgICBpZiAoIShlLnJlbGF0ZWROb2RlIGluc3RhbmNlb2YgQXR0cikpIHtcbiAgICAgICAgICAvLyBJRTEwIGZpcmVzIHR3byBtdXRhdGlvbiBldmVudHMgZm9yIGF0dHJpYnV0ZXMsIG9uZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIHRhcmdldCBhcyB0aGUgcmVsYXRlZE5vZGUsIGFuZCBvbmUgd2hlcmUgaXQncyB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gUmU6IHJlbGF0ZWROb2RlLCBcIkluIHRoZSBjYXNlIG9mIHRoZSBET01BdHRyTW9kaWZpZWQgZXZlbnRcbiAgICAgICAgICAvLyBpdCBpbmRpY2F0ZXMgdGhlIEF0dHIgbm9kZSB3aGljaCB3YXMgbW9kaWZpZWQsIGFkZGVkLCBvclxuICAgICAgICAgIC8vIHJlbW92ZWQuXCIgWzFdXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBbMV06IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZmY5NDM2MDYlMjh2PXZzLjg1JTI5LmFzcHhcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhblRyaWdnZXJBdHRyaWJ1dGVNb2RpZmljYXRpb24oZVRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZUF0dHJOYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIGVQcmV2VmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgdmFyIGVOZXdWYWx1ZSA9IGUubmV3VmFsdWU7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXdNdXRhdGlvblJlY29yZChlVGFyZ2V0LCAnYXR0cmlidXRlcycpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IGVBdHRyTmFtZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSkge1xuICAgICAgICAgIHJlY29yZC5vbGRWYWx1ZSA9IGF0dHJpYnV0ZU9sZFZhbHVlQ2FjaGVbZUF0dHJOYW1lXSB8fCBlUHJldlZhbHVlIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVNdXRhdGlvbnMucHVzaChyZWNvcmQpO1xuXG4gICAgICAgIC8vIFdlIGtlZXAgdHJhY2sgb2Ygb2xkIHZhbHVlcyBzbyB0aGF0IHdoZW4gSUUgaW5jb3JyZWN0bHkgcmVwb3J0c1xuICAgICAgICAvLyB0aGUgb2xkIHZhbHVlIHdlIGNhbiBlbnN1cmUgaXQgaXMgYWN0dWFsbHkgY29ycmVjdC5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZUNhY2hlW2VBdHRyTmFtZV0gPSBlTmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXRjaEF0dHJpYnV0ZU1vZHMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5lbGVtZW50cy5wdXNoKG9ic2VydmVkKTtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIG9ic2VydmVkLmluc2VydEhhbmRsZXIpO1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgb2JzZXJ2ZWQucmVtb3ZlSGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUF0dHJNb2RpZmllZCcsIG9ic2VydmVkLmF0dHJpYnV0ZUhhbmRsZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBvYmpFYWNoKHRoaXMuZWxlbWVudHMsIGZ1bmN0aW9uIChvYnNlcnZlZCkge1xuICAgICAgb2JzZXJ2ZWQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIG9ic2VydmVkLmluc2VydEhhbmRsZXIpO1xuICAgICAgb2JzZXJ2ZWQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgb2JzZXJ2ZWQucmVtb3ZlSGFuZGxlcik7XG4gICAgICBvYnNlcnZlZC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQXR0ck1vZGlmaWVkJywgb2JzZXJ2ZWQuYXR0cmlidXRlSGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTXV0YXRpb25PYnNlcnZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtcbiAgVFlQRV9BVFRSSUJVVEUsXG4gIFRZUEVfQ0xBU1NOQU1FLFxuICBUWVBFX0VMRU1FTlRcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi9nbG9iYWxzJztcbmltcG9ydCB7XG4gIGhhc093bixcbiAgaXNWYWxpZE5hdGl2ZUN1c3RvbUVsZW1lbnROYW1lLFxuICBzdXBwb3J0c05hdGl2ZUN1c3RvbUVsZW1lbnRzXG59IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNsYXNzIGxpc3QgZm9yIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBjbGFzcyBsaXN0IGZvci5cbiAqXG4gKiBAcmV0dXJucyB7Q2xhc3NMaXN0IHwgQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldENsYXNzTGlzdCAoZWxlbWVudCkge1xuICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIHJldHVybiBjbGFzc0xpc3Q7XG4gIH1cblxuICB2YXIgYXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgcmV0dXJuIChhdHRyc1snY2xhc3MnXSAmJiBhdHRyc1snY2xhc3MnXS5ub2RlVmFsdWUuc3BsaXQoL1xccysvKSkgfHwgW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBnbG9iYWxzLnJlZ2lzdHJ5ID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaGFzT3duKGdsb2JhbHMucmVnaXN0cnksIGlkKSAmJiBnbG9iYWxzLnJlZ2lzdHJ5W2lkXTtcbiAgfSxcblxuICBnZXRGb3JFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBhdHRycyA9IGVsZW1lbnQuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cnNMZW4gPSBhdHRycy5sZW5ndGg7XG4gICAgdmFyIGRlZmluaXRpb25zID0gW107XG4gICAgdmFyIGlzQXR0ciA9IGF0dHJzLmlzO1xuICAgIHZhciBpc0F0dHJWYWx1ZSA9IGlzQXR0ciAmJiAoaXNBdHRyLnZhbHVlIHx8IGlzQXR0ci5ub2RlVmFsdWUpO1xuXG4gICAgLy8gVXNpbmcgbG9jYWxOYW1lIGFzIGZhbGxiYWNrIGZvciBlZGdlIGNhc2VzIHdoZW4gcHJvY2Vzc2luZyA8b2JqZWN0PiB0YWcgdGhhdCBpcyB1c2VkXG4gICAgLy8gYXMgaW50ZWZhY2UgdG8gTlBBUEkgcGx1Z2luLlxuICAgIHZhciB0YWcgPSAoZWxlbWVudC50YWdOYW1lIHx8IGVsZW1lbnQubG9jYWxOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBpc0F0dHJPclRhZyA9IGlzQXR0clZhbHVlIHx8IHRhZztcbiAgICB2YXIgZGVmaW5pdGlvbjtcbiAgICB2YXIgdGFnVG9FeHRlbmQ7XG5cbiAgICBpZiAodGhpcy5pc1R5cGUoaXNBdHRyT3JUYWcsIFRZUEVfRUxFTUVOVCkpIHtcbiAgICAgIGRlZmluaXRpb24gPSBnbG9iYWxzLnJlZ2lzdHJ5W2lzQXR0ck9yVGFnXTtcbiAgICAgIHRhZ1RvRXh0ZW5kID0gZGVmaW5pdGlvbi5leHRlbmRzO1xuXG4gICAgICBpZiAoaXNBdHRyVmFsdWUpIHtcbiAgICAgICAgaWYgKHRhZyA9PT0gdGFnVG9FeHRlbmQpIHtcbiAgICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0YWdUb0V4dGVuZCkge1xuICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGEgPSAwOyBhIDwgYXR0cnNMZW47IGErKykge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1thXS5ub2RlTmFtZTtcblxuICAgICAgaWYgKHRoaXMuaXNUeXBlKGF0dHIsIFRZUEVfQVRUUklCVVRFKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZ2xvYmFscy5yZWdpc3RyeVthdHRyXTtcbiAgICAgICAgdGFnVG9FeHRlbmQgPSBkZWZpbml0aW9uLmV4dGVuZHM7XG5cbiAgICAgICAgaWYgKCF0YWdUb0V4dGVuZCB8fCB0YWcgPT09IHRhZ1RvRXh0ZW5kKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjbGFzc0xpc3QgPSBnZXRDbGFzc0xpc3QoZWxlbWVudCk7XG4gICAgdmFyIGNsYXNzTGlzdExlbiA9IGNsYXNzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNsYXNzTGlzdExlbjsgYisrKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NMaXN0W2JdO1xuXG4gICAgICBpZiAodGhpcy5pc1R5cGUoY2xhc3NOYW1lLCBUWVBFX0NMQVNTTkFNRSkpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGdsb2JhbHMucmVnaXN0cnlbY2xhc3NOYW1lXTtcbiAgICAgICAgdGFnVG9FeHRlbmQgPSBkZWZpbml0aW9uLmV4dGVuZHM7XG5cbiAgICAgICAgaWYgKCF0YWdUb0V4dGVuZCB8fCB0YWcgPT09IHRhZ1RvRXh0ZW5kKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgfSxcblxuICBpc1R5cGU6IGZ1bmN0aW9uIChpZCwgdHlwZSkge1xuICAgIHZhciBkZWYgPSB0aGlzLmdldChpZCk7XG4gICAgcmV0dXJuIGRlZiAmJiBkZWYudHlwZSA9PT0gdHlwZTtcbiAgfSxcblxuICBpc05hdGl2ZUN1c3RvbUVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBzdXBwb3J0c05hdGl2ZUN1c3RvbUVsZW1lbnRzKCkgJiYgdGhpcy5pc1R5cGUoaWQsIFRZUEVfRUxFTUVOVCkgJiYgaXNWYWxpZE5hdGl2ZUN1c3RvbUVsZW1lbnROYW1lKGlkKTtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgIGlmIChoYXNPd24oZ2xvYmFscy5yZWdpc3RyeSwgaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IGRlZmluaXRpb24gb2YgdHlwZSBcIicgKyBkZWZpbml0aW9uLnR5cGUgKyAnXCIgd2l0aCB0aGUgSUQgb2YgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJyk7XG4gICAgfVxuXG4gICAgZ2xvYmFscy5yZWdpc3RyeVtpZF0gPSBkZWZpbml0aW9uO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7XG4gIFRZUEVfQVRUUklCVVRFLFxuICBUWVBFX0NMQVNTTkFNRSxcbiAgVFlQRV9FTEVNRU5UXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBkb2N1bWVudE9ic2VydmVyIGZyb20gJy4vZG9jdW1lbnQtb2JzZXJ2ZXInO1xuaW1wb3J0IHtcbiAgdHJpZ2dlckNyZWF0ZWQsXG4gIHRyaWdnZXJBdHRhY2hlZCxcbiAgdHJpZ2dlckRldGFjaGVkLFxuICB0cmlnZ2VyQXR0cmlidXRlQ2hhbmdlZCxcbiAgaW5pdEVsZW1lbnRzXG59IGZyb20gJy4vbGlmZWN5Y2xlJztcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL3JlZ2lzdHJ5JztcbmltcG9ydCB7XG4gIGRlYm91bmNlLFxuICBpbmhlcml0XG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi92ZXJzaW9uJztcblxudmFyIEhUTUxFbGVtZW50ID0gd2luZG93LkhUTUxFbGVtZW50O1xuXG4vLyBJRSA8PSAxMCBjYW4gZmlyZSBcImludGVyYWN0aXZlXCIgdG9vIGVhcmx5ICgjMjQzKS5cbnZhciBpc09sZElFID0gISFkb2N1bWVudC5hdHRhY2hFdmVudDsgIC8vIGF0dGFjaEV2ZW50IHdhcyByZW1vdmVkIGluIElFMTEuXG5cbmZ1bmN0aW9uIGlzUmVhZHkgKCkge1xuICBpZiAoaXNPbGRJRSkge1xuICAgIHJldHVybiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZSc7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXNlcyBhbGwgdmFsaWQgZWxlbWVudHMgaW4gdGhlIGRvY3VtZW50LiBFbnN1cmVzIHRoYXQgaXQgZG9lcyBub3RcbiAqIGhhcHBlbiBtb3JlIHRoYW4gb25jZSBpbiB0aGUgc2FtZSBleGVjdXRpb24sIGFuZCB0aGF0IGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIERPTSBpcyByZWFkeS5cbiAqXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG52YXIgaW5pdERvY3VtZW50ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICB2YXIgaW5pdGlhbGlzZVNrYXRlRWxlbWVudHNPbkRvbUxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaW5pdEVsZW1lbnRzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzKTtcbiAgfTtcbiAgaWYgKGlzUmVhZHkoKSkge1xuICAgIGluaXRpYWxpc2VTa2F0ZUVsZW1lbnRzT25Eb21Mb2FkKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2xkSUUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaW5pdGlhbGlzZVNrYXRlRWxlbWVudHNPbkRvbUxvYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgaW5pdGlhbGlzZVNrYXRlRWxlbWVudHNPbkRvbUxvYWQpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciB0aGUgc3BlY2lmaWVkIGRlZmluaXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gVGhlIGRlZmluaXRpb24gaW5mb3JtYXRpb24gdG8gdXNlIGZvciBnZW5lcmF0aW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBlbGVtZW50IGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBtYWtlRWxlbWVudENvbnN0cnVjdG9yIChkZWZpbml0aW9uKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbUVsZW1lbnQgKCkge1xuICAgIHZhciBlbGVtZW50O1xuICAgIHZhciB0YWdUb0V4dGVuZCA9IGRlZmluaXRpb24uZXh0ZW5kcztcbiAgICB2YXIgZGVmaW5pdGlvbklkID0gZGVmaW5pdGlvbi5pZDtcblxuICAgIGlmICh0YWdUb0V4dGVuZCkge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnVG9FeHRlbmQpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lzJywgZGVmaW5pdGlvbklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVmaW5pdGlvbklkKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIGRlZmluaXRpb24gcHJvdG90eXBlIGlzIHVwIHRvIGRhdGUgd2l0aCB0aGUgZWxlbWVudCdzXG4gICAgLy8gcHJvdG90eXBlLiBUaGlzIGVuc3VyZXMgdGhhdCBvdmVyd3JpdGluZyB0aGUgZWxlbWVudCBwcm90b3R5cGUgc3RpbGxcbiAgICAvLyB3b3Jrcy5cbiAgICBkZWZpbml0aW9uLnByb3RvdHlwZSA9IEN1c3RvbUVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgLy8gSWYgdGhleSB1c2UgdGhlIGNvbnN0cnVjdG9yIHdlIGRvbid0IGhhdmUgdG8gd2FpdCB1bnRpbCBpdCdzIGF0dGFjaGVkLlxuICAgIHRyaWdnZXJDcmVhdGVkKGVsZW1lbnQsIGRlZmluaXRpb24pO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBUaGlzIGFsbG93cyBtb2RpZmljYXRpb25zIHRvIHRoZSBlbGVtZW50IHByb3RvdHlwZSBwcm9wYWdhdGUgdG8gdGhlXG4gIC8vIGRlZmluaXRpb24gcHJvdG90eXBlLlxuICBDdXN0b21FbGVtZW50LnByb3RvdHlwZSA9IGRlZmluaXRpb24ucHJvdG90eXBlO1xuXG4gIHJldHVybiBDdXN0b21FbGVtZW50O1xufVxuXG4vLyBQdWJsaWMgQVBJXG4vLyAtLS0tLS0tLS0tXG5cbi8qKlxuICogQ3JlYXRlcyBhIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGRlZmluaXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgRnVuY3Rpb259IGRlZmluaXRpb24gVGhlIGRlZmluaXRpb24gZGVmaW5pdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IENvbnN0cnVjdG9yIHRoYXQgcmV0dXJucyBhIGN1c3RvbSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBza2F0ZSAoaWQsIGRlZmluaXRpb24pIHtcbiAgLy8gSnVzdCBpbiBjYXNlIHRoZSBkZWZpbml0aW9uIGlzIHNoYXJlZCwgd2UgZHVwbGljYXRlIGl0IHNvIHRoYXQgaW50ZXJuYWxcbiAgLy8gbW9kaWZpY2F0aW9ucyB0byB0aGUgb3JpZ2luYWwgYXJlbid0IHNoYXJlZC5cbiAgZGVmaW5pdGlvbiA9IGluaGVyaXQoe30sIGRlZmluaXRpb24pO1xuICBkZWZpbml0aW9uID0gaW5oZXJpdChkZWZpbml0aW9uLCBza2F0ZS5kZWZhdWx0cyk7XG4gIGRlZmluaXRpb24uaWQgPSBpZDtcblxuICByZWdpc3RyeS5zZXQoaWQsIGRlZmluaXRpb24pO1xuXG4gIGlmIChyZWdpc3RyeS5pc05hdGl2ZUN1c3RvbUVsZW1lbnQoaWQpKSB7XG4gICAgdmFyIGVsZW1lbnRQcm90b3R5cGUgPSBkZWZpbml0aW9uLmV4dGVuZHMgP1xuICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWZpbml0aW9uLmV4dGVuZHMpLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA6XG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICBpZiAoIWVsZW1lbnRQcm90b3R5cGUuaXNQcm90b3R5cGVPZihkZWZpbml0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgIGRlZmluaXRpb24ucHJvdG90eXBlID0gaW5oZXJpdChPYmplY3QuY3JlYXRlKGVsZW1lbnRQcm90b3R5cGUpLCBkZWZpbml0aW9uLnByb3RvdHlwZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwcm90b3R5cGU6IGluaGVyaXQoZGVmaW5pdGlvbi5wcm90b3R5cGUsIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJpZ2dlckNyZWF0ZWQodGhpcywgZGVmaW5pdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaGVkQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cmlnZ2VyQXR0YWNoZWQodGhpcywgZGVmaW5pdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGRldGFjaGVkQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cmlnZ2VyRGV0YWNoZWQodGhpcywgZGVmaW5pdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgIHRyaWdnZXJBdHRyaWJ1dGVDaGFuZ2VkKHRoaXMsIGRlZmluaXRpb24sIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuXG4gICAgaWYgKGRlZmluaXRpb24uZXh0ZW5kcykge1xuICAgICAgb3B0aW9ucy5leHRlbmRzID0gZGVmaW5pdGlvbi5leHRlbmRzO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgaW5pdERvY3VtZW50KCk7XG4gIGRvY3VtZW50T2JzZXJ2ZXIucmVnaXN0ZXIoISFkZWZpbml0aW9uLmRldGFjaGVkKTtcblxuICBpZiAocmVnaXN0cnkuaXNUeXBlKGlkLCBUWVBFX0VMRU1FTlQpKSB7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50Q29uc3RydWN0b3IoZGVmaW5pdGlvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGluaXRpYWxpc2VzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBvciBlbGVtZW50cyBhbmQgZGVzY2VuZGFudHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbm9kZXMgVGhlIG5vZGUsIG9yIG5vZGVzIHRvIGluaXRpYWxpc2UuIENhbiBiZSBhbnl0aGluZzpcbiAqICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSwgRE9NTm9kZUxpc3QsIERPTU5vZGUsIHNlbGVjdG9yIGV0Yy5cbiAqXG4gKiBAcmV0dXJucyB7c2thdGV9XG4gKi9cbnNrYXRlLmluaXQgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIG5vZGVzVG9Vc2UgPSBub2RlcztcblxuICBpZiAoIW5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBub2Rlc1RvVXNlID0gbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG5vZGVzKTtcbiAgfSBlbHNlIGlmIChub2RlcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgbm9kZXNUb1VzZSA9IFtub2Rlc107XG4gIH1cblxuICBpbml0RWxlbWVudHMobm9kZXNUb1VzZSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxuLy8gUmVzdHJpY3Rpb24gdHlwZSBjb25zdGFudHMuXG5za2F0ZS50eXBlID0ge1xuICBBVFRSSUJVVEU6IFRZUEVfQVRUUklCVVRFLFxuICBDTEFTU05BTUU6IFRZUEVfQ0xBU1NOQU1FLFxuICBFTEVNRU5UOiBUWVBFX0VMRU1FTlRcbn07XG5cbi8vIE1ha2VzIGNoZWNraW5nIHRoZSB2ZXJzaW9uIGVhc3kgd2hlbiBkZWJ1Z2dpbmcuXG5za2F0ZS52ZXJzaW9uID0gdmVyc2lvbjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhIGRlZmluaXRpb24uXG4gKlxuICogQHZhciB7T2JqZWN0fVxuICovXG5za2F0ZS5kZWZhdWx0cyA9IHtcbiAgLy8gQXR0cmlidXRlIGxpZmVjeWNsZSBjYWxsYmFjayBvciBjYWxsYmFja3MuXG4gIGF0dHJpYnV0ZXM6IHVuZGVmaW5lZCxcblxuICAvLyBUaGUgZXZlbnRzIHRvIG1hbmFnZSB0aGUgYmluZGluZyBhbmQgdW5iaW5kaW5nIG9mIGR1cmluZyB0aGUgZGVmaW5pdGlvbidzXG4gIC8vIGxpZmVjeWNsZS5cbiAgZXZlbnRzOiB1bmRlZmluZWQsXG5cbiAgLy8gUmVzdHJpY3RzIGEgcGFydGljdWxhciBkZWZpbml0aW9uIHRvIGJpbmRpbmcgZXhwbGljaXRseSB0byBhbiBlbGVtZW50IHdpdGhcbiAgLy8gYSB0YWcgbmFtZSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAgZXh0ZW5kczogdW5kZWZpbmVkLFxuXG4gIC8vIFRoZSBJRCBvZiB0aGUgZGVmaW5pdGlvbi4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IHNldCBpbiB0aGUgYHNrYXRlKClgXG4gIC8vIGZ1bmN0aW9uLlxuICBpZDogJycsXG5cbiAgLy8gUHJvcGVydGllcyBhbmQgbWV0aG9kcyB0byBhZGQgdG8gZWFjaCBlbGVtZW50LlxuICBwcm90b3R5cGU6IHt9LFxuXG4gIC8vIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBhZGQgYWZ0ZXIgY2FsbGluZyB0aGUgY3JlYXRlZCgpIGNhbGxiYWNrLlxuICByZXNvbHZlZEF0dHJpYnV0ZTogJ3Jlc29sdmVkJyxcblxuICAvLyBUaGUgdGVtcGxhdGUgdG8gcmVwbGFjZSB0aGUgY29udGVudCBvZiB0aGUgZWxlbWVudCB3aXRoLlxuICB0ZW1wbGF0ZTogdW5kZWZpbmVkLFxuXG4gIC8vIFRoZSB0eXBlIG9mIGJpbmRpbmdzIHRvIGFsbG93LlxuICB0eXBlOiBUWVBFX0VMRU1FTlQsXG5cbiAgLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHJlbW92ZSBhZnRlciBjYWxsaW5nIHRoZSBjcmVhdGVkKCkgY2FsbGJhY2suXG4gIHVucmVzb2x2ZWRBdHRyaWJ1dGU6ICd1bnJlc29sdmVkJ1xufTtcblxuLy8gRXhwb3J0aW5nXG4vLyAtLS0tLS0tLS1cblxudmFyIHByZXZpb3VzU2thdGUgPSB3aW5kb3cuc2thdGU7XG5za2F0ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICB3aW5kb3cuc2thdGUgPSBwcmV2aW91c1NrYXRlO1xuICByZXR1cm4gc2thdGU7XG59O1xuXG4vLyBHbG9iYWxcbndpbmRvdy5za2F0ZSA9IHNrYXRlO1xuXG4vLyBFUzZcbmV4cG9ydCBkZWZhdWx0IHNrYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuICBBVFRSX0lHTk9SRVxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbnZhciBEb2N1bWVudEZyYWdtZW50ID0gd2luZG93LkRvY3VtZW50RnJhZ21lbnQ7XG5leHBvcnQgdmFyIGVsZW1lbnRQcm90b3R5cGUgPSB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlO1xudmFyIGVsZW1lbnRQcm90b3R5cGVDb250YWlucyA9IGVsZW1lbnRQcm90b3R5cGUuY29udGFpbnM7XG5cbi8qKlxuICogQ2hlY2tzIHt9Lmhhc093blByb3BlcnR5IGluIGEgc2FmZSB3YXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoZSBwcm9wZXJ0eSBpcyBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG9iamVjdCBrZXkgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIENhbWVsLWNhc2VzIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjYW1lbC1jYXNlLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbENhc2UgKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC8tL2cpLm1hcChmdW5jdGlvbiAoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMCA/IHN0ciA6IHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfSkuam9pbignJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc291cmNlIGVsZW1lbnQgY29udGFpbnMgdGhlIHRhcmdldCBlbGVtZW50LlxuICogVGhpcyBpcyBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEVsZW1lbnQucHJvdG90eXBlLmNvbnRhaW5zIG9uIGFuXG4gKiBIVE1MVW5rbm93bkVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc291cmNlIFRoZSBzb3VyY2UgZWxlbWVudC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50Q29udGFpbnMgKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIC8vIFRoZSBkb2N1bWVudCBlbGVtZW50IGRvZXMgbm90IGhhdmUgdGhlIGNvbnRhaW5zIG1ldGhvZCBpbiBJRS5cbiAgaWYgKHNvdXJjZSA9PT0gZG9jdW1lbnQgJiYgIXNvdXJjZS5jb250YWlucykge1xuICAgIHJldHVybiBkb2N1bWVudC5oZWFkLmNvbnRhaW5zKHRhcmdldCkgfHwgZG9jdW1lbnQuYm9keS5jb250YWlucyh0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZS5jb250YWlucyA/IHNvdXJjZS5jb250YWlucyh0YXJnZXQpIDogZWxlbWVudFByb3RvdHlwZUNvbnRhaW5zLmNhbGwoc291cmNlLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJldmVudCBtb3JlIHRoYW4gb25lIGNhbGwgaW4gYSBzaW5nbGUgY2xvY2tcbiAqIHRpY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNwZWNpZmllZCBlbGVtZW50IGhhcyBiZWVuIHNlbGVjdGl2ZWx5IGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNoZWNrIGFuZCB0cmF2ZXJzZSB1cCBmcm9tLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdElnbm9yZWRFbGVtZW50IChlbGVtZW50KSB7XG4gIHZhciBwYXJlbnQgPSBlbGVtZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50ICE9PSBkb2N1bWVudCAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpKSB7XG4gICAgaWYgKHBhcmVudC5oYXNBdHRyaWJ1dGUoQVRUUl9JR05PUkUpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBzZWNvbmQgYXJndW1lbnQgaW50byB0aGUgZmlyc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkIFRoZSBvYmplY3QgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgVGhlIG9iamVjdCB0byBtZXJnZSBmcm9tLlxuICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgV2hldGhlciBvciBub3QgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgb24gdGhlIGNoaWxkLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNoaWxkIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaGVyaXQgKGNoaWxkLCBwYXJlbnQsIG92ZXJ3cml0ZSkge1xuICB2YXIgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJlbnQpO1xuICB2YXIgbmFtZXNMZW4gPSBuYW1lcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgYSA9IDA7IGEgPCBuYW1lc0xlbjsgYSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1thXTtcblxuICAgIGlmIChvdmVyd3JpdGUgfHwgY2hpbGRbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgbmFtZSk7XG4gICAgICB2YXIgc2hvdWxkRGVmaW5lUHJvcHMgPSBkZXNjLmdldCB8fCBkZXNjLnNldCB8fCAhZGVzYy53cml0YWJsZSB8fCAhZGVzYy5lbnVtZXJhYmxlIHx8ICFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICAgICAgaWYgKHNob3VsZERlZmluZVByb3BzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgbmFtZSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZFtuYW1lXSA9IHBhcmVudFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGFuIG9iamVjdCBjaGVja2luZyBoYXNPd25Qcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gdHJhdmVyc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtIGluIHRoZSBvYmplY3QuXG4gKlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iakVhY2ggKG9iaiwgZm4pIHtcbiAgZm9yICh2YXIgYSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duKG9iaiwgYSkpIHtcbiAgICAgIGZuKG9ialthXSwgYSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c05hdGl2ZUN1c3RvbUVsZW1lbnRzICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmF0aXZlQ3VzdG9tRWxlbWVudE5hbWUgKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuaW5kZXhPZignLScpID4gMDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0ICcwLjEzLjcnO1xuIiwiLyoqXG4gKiDQktGL0YHRh9C40YLRi9Cy0LDQtdGCINC4INC30LDQvNC10L3Rj9C10YIgQVZUIChhdHRyaWJ1dGUgdmFsdWUgdGVtcGxhdGVzKSDQstC90YPRgtGA0Lgg0YHRgtGA0L7QutC4OlxuICogXCJmb28ge3Bvc2l0aW9uKCkgKyAxfVwiIOKAkz4gXCJmb28gMlwiXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHhwYXRoID0gcmVxdWlyZSgneHBhdGgnKTtcbnZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCdzdHJpbmctc3RyZWFtJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyLCBjb250ZXh0KSB7XG5cdHJldHVybiBzcGxpdChzdHIpLm1hcChmdW5jdGlvbih0b2tlbikge1xuXHRcdGlmICh0b2tlbi50eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHRva2VuLnZhbHVlO1xuXHRcdH1cblxuXHRcdHZhciByZXN1bHQgPSB4cGF0aC5zZWxlY3QxKHRva2VuLnZhbHVlLCBjb250ZXh0KTtcblx0XHRyZXR1cm4gcmVzdWx0ID8gdXRpbHMuc3RyaW5naWZ5KHJlc3VsdCkgOiAnJztcblx0fSkuam9pbignJyk7XG59O1xuXG5mdW5jdGlvbiBzcGxpdChkYXRhKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGV4cHIgPSBmdW5jdGlvbihlKSB7XG5cdFx0b3V0LnB1c2goe3R5cGU6ICdleHByZXNzaW9uJywgdmFsdWU6IGV9KTtcblx0fTtcblx0dmFyIHN0ciA9IGZ1bmN0aW9uKHMpIHtcblx0XHRvdXQucHVzaCh7dHlwZTogJ3N0cmluZycsIHZhbHVlOiBzfSk7XG5cdH07XG5cblx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbShkYXRhKSwgY2g7XG5cdHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG5cdFx0aWYgKHN0cmVhbS5uZXh0KCkgPT09ICd7Jykge1xuXHRcdFx0c3RyZWFtLmJhY2tVcCgxKTtcblx0XHRcdHN0cihzdHJlYW0uY3VycmVudCgpKTtcblx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgKyAxO1xuXHRcdFx0aWYgKHN0cmVhbS5za2lwVG9QYWlyKCd7JywgJ30nLCB0cnVlKSkge1xuXHRcdFx0XHRleHByKHN0cmVhbS5jdXJyZW50KHRydWUpKTtcblx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBleHByZXNzaW9uOiAnICsgc3RyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0c3RyKHN0cmVhbS5jdXJyZW50KCkpO1xuXHRyZXR1cm4gb3V0LmZpbHRlcihmdW5jdGlvbih0b2tlbikge1xuXHRcdHJldHVybiB0b2tlbi52YWx1ZTtcblx0fSk7XG59IiwiLyoqXG4gKiDQmtC+0L3RgtC10LrRgdGCINGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNC4INC00LXRgNC10LLQsDog0LfQsNGF0LLQsNGC0YvQstCw0LXRgiDRgtC10LrRg9GJ0LjQuSDQutC+0L3RgtC10LrRgdGC0L3Ri9C5INGN0LvQtdC80LXQvdGCXG4gKiDQuCDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQuNC90YLQtdGA0YTQtdC50YEg0LTQu9GPINCy0YvQstC+0LTQsCDQtNCw0L3QvdGL0YVcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd0ZW1wbGF0ZTpjb250ZXh0Jyk7XG52YXIgYXZ0ID0gcmVxdWlyZSgnLi4vYXZ0Jyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RvbS9ub2RlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQWJzdHJhY3RDb250ZXh0IHtcblx0Y29uc3RydWN0b3IoaGFuZGxlcnMpIHtcblx0XHR0aGlzLl9oYW5kbGVycyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLl9jb250ZXh0ID0gW107XG5cblx0XHRpZiAoaGFuZGxlcnMpIHtcblx0XHRcdE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJIYW5kbGVyKG5vZGVOYW1lLCBoYW5kbGVyc1tub2RlTmFtZV0pO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0ZW50ZXIoZWxlbSkge1xuXHRcdHRoaXMuX2NvbnRleHQucHVzaChlbGVtKTtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGxlYXZlKCkge1xuXHRcdGlmICh0aGlzLl9jb250ZXh0Lmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jb250ZXh0LnBvcCgpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBjb250ZXh0KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0W3RoaXMuX2NvbnRleHQubGVuZ3RoIC0gMV07XG5cdH1cblxuXHRldmFsQVZUKHN0ciwgY29udGV4dCkge1xuXHRcdHJldHVybiBhdnQoc3RyLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCk7XG5cdH1cblxuXHRyZWdpc3RlckhhbmRsZXIobm9kZU5hbWUsIGdlbikge1xuXHRcdHRoaXMuX2hhbmRsZXJzLnNldChub2RlTmFtZSwgZ2VuKTtcblx0fVxuXG5cdGdldEhhbmRsZXJGb3JOb2RlKG5vZGUsIGdlbikge1xuXHRcdHZhciBoYW5kbGVyO1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdFx0aGFuZGxlciA9IHRoaXMuX2hhbmRsZXJzLmdldChub2RlLm5vZGVOYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIGhhbmRsZXIgfHwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0SGFuZGxlcjtcblx0fVxuXG5cdHRyYW5zZm9ybShub2RlKSB7XG5cdFx0Zm9yICh2YXIgbiBvZiB0cmFuc2Zvcm0obm9kZSwgdGhpcykpIHtcblx0XHRcdGRlYnVnKCd0cmFuc2Zvcm1pbmcgJXMnLCBub2RlU3RyKG5vZGUpKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0fVxuXG5cdHB1c2hFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuXHR9XG5cblx0cHVzaEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH1cblxuXHRwdXNoVGV4dCh2YWx1ZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH1cblxuXHRwb3BFbGVtZW50KCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRIYW5kbGVyID0gZGVmYXVsdEhhbmRsZXI7XG5cbmZ1bmN0aW9uKiB0cmFuc2Zvcm0obm9kZSwgY3R4KSB7XG5cdHZhciBoYW5kbGVyID0gY3R4LmdldEhhbmRsZXJGb3JOb2RlKG5vZGUpO1xuXHRmb3IgKHZhciBuZXh0IG9mIGhhbmRsZXIobm9kZSwgY3R4KSkge1xuXHRcdHlpZWxkIG5leHQ7XG5cdFx0eWllbGQqIHRyYW5zZm9ybShuZXh0LCBjdHgpO1xuXHR9XG59XG5cbmZ1bmN0aW9uKiBkZWZhdWx0SGFuZGxlcihub2RlLCBjdHgpIHtcblx0Y3R4ID0gY3R4IHx8IHRoaXM7XG5cdGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcblx0XHRmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpIHtcblx0XHRcdHlpZWxkIGNoaWxkO1xuXHRcdH1cblx0fSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdGN0eC5wdXNoRWxlbWVudChub2RlLm5vZGVOYW1lKTtcblx0XHR2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsID0gYXR0cnMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0Y3R4LnB1c2hBdHRyaWJ1dGUoYXR0cnNbaV0ubmFtZSwgY3R4LmV2YWxBVlQoYXR0cnNbaV0udmFsdWUpKTtcblx0XHR9XG5cdFx0Zm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKSB7XG5cdFx0XHR5aWVsZCBjaGlsZDtcblx0XHR9XG5cdFx0Y3R4LnBvcEVsZW1lbnQoKTtcblx0fSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdGN0eC5wdXNoVGV4dChub2RlLm5vZGVWYWx1ZSk7XG5cdH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5BVFRSSUJVVEVfTk9ERSkge1xuXHRcdGN0eC5wdXNoQXR0cmlidXRlKG5vZGUpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG5vZGVTdHIobm9kZSkge1xuXHRzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0XHRjYXNlIE5vZGUuRE9DVU1FTlRfTk9ERTogcmV0dXJuICcjZG9jdW1lbnQnO1xuXHRcdGNhc2UgTm9kZS5URVhUX05PREU6IHJldHVybiBgXCIke25vZGUubm9kZVZhbHVlfVwiYDtcblx0XHRjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOiByZXR1cm4gYDwke25vZGUubm9kZU5hbWV9PmA7XG5cdFx0Y2FzZSBOb2RlLkFUVFJJQlVURV9OT0RFOiByZXR1cm4gYEAke25vZGUubmFtZX1gO1xuXHR9XG59IiwiLyoqXG4gKiDQktCw0YDQuNCw0YbQuNGPINC60L7QvdGC0LXQutGB0YLQsCDQv9GA0LXQvtCx0YDQsNC30L7QstCw0L3QuNGPINC00LvRjyDQs9C10L3QtdGA0LDRhtC40LggRE9NLdC00LXRgNC10LLQsFxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgQWJzdHJhY3RDb250ZXh0ID0gcmVxdWlyZSgnLi9hYnN0cmFjdCcpO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi4vZG9tL2RvY3VtZW50Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndGVtcGxhdGU6ZG9tLWNvbnRleHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBET01Db250ZXh0IGV4dGVuZHMgQWJzdHJhY3RDb250ZXh0IHtcblx0Y29uc3RydWN0b3IoaGFuZGxlcnMpIHtcblx0XHRzdXBlcihoYW5kbGVycyk7XG5cdFx0dGhpcy5vdXRwdXQgPSBuZXcgRG9jdW1lbnQoKTtcblx0XHR0aGlzLm91dHB1dEN0eCA9IHRoaXMub3V0cHV0O1xuXHRcdHRoaXMuX2RvYyA9IHRoaXMub3V0cHV0Lm93bmVyRG9jdW1lbnQ7XG5cdH1cblxuXHRwdXNoRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdFx0ZGVidWcoJ3B1c2ggZWxlbWVudCAlcycsIG5hbWUpO1xuXHRcdHZhciBlbGVtID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSk7XG5cdFx0dGhpcy5vdXRwdXRDdHguYXBwZW5kQ2hpbGQoZWxlbSk7XG5cdFx0dGhpcy5vdXRwdXRDdHggPSBlbGVtO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKSB7XG5cdFx0XHRmb3IgKGxldCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0dGhpcy5wdXNoQXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXMoYXR0cmlidXRlcykpIHtcblx0XHRcdFx0dGhpcy5wdXNoQXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZXNbbmFtZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHB1c2hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR2YWx1ZSA9IG5hbWUudmFsdWU7XG5cdFx0XHRuYW1lID0gbmFtZS5uYW1lO1xuXHRcdH1cblx0XHRcblx0XHRkZWJ1ZygncHVzaCBhdHRyaWJ1dGUgJXMnLCBuYW1lKTtcblx0XHR0aGlzLm91dHB1dEN0eC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHR9XG5cblx0cHVzaFRleHQodmFsdWUpIHtcblx0XHRkZWJ1ZygncHVzaCB0ZXh0ICVzJywgdmFsdWUpO1xuXHRcdHZhciBub2RlID0gdGhpcy5fZG9jLmNyZWF0ZVRleHROb2RlKHV0aWxzLnN0cmluZ2lmeSh2YWx1ZSkpO1xuXHRcdHRoaXMub3V0cHV0Q3R4LmFwcGVuZENoaWxkKG5vZGUpO1xuXHR9XG5cblx0cG9wRWxlbWVudCgpIHtcblx0XHRkZWJ1ZygncG9wIGVsZW1lbnQnKTtcblx0XHRpZiAodGhpcy5vdXRwdXRDdHgucGFyZW50Tm9kZSkge1xuXHRcdFx0dGhpcy5vdXRwdXRDdHggPSB0aGlzLm91dHB1dEN0eC5wYXJlbnROb2RlO1xuXHRcdH1cblx0fVxuXG5cdHRyYW5zZm9ybShub2RlKSB7XG5cdFx0c3VwZXIudHJhbnNmb3JtKG5vZGUpO1xuXHRcdHJldHVybiB0aGlzLm91dHB1dDtcblx0fVxufTsiLCIvKipcbiAqINCa0L7QvdGC0LXQutGB0YIg0LTQu9GPINC/0YDQtdC+0LHRgNCw0LfQvtCy0LDQvdC40Y8g0LTQtdGA0LXQstCwINGH0LXRgNC10Lcg0LTQtdC60LvQsNGA0LDRgtC40LLQvdGL0Lkg0YjQsNCx0LvQvtC9XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHhwYXRoID0gcmVxdWlyZSgneHBhdGgnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndGVtcGxhdGU6dGVtcGxhdGUtY3R4Jyk7XG52YXIgRE9NQ29udGV4dCA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb20vZG9jdW1lbnQnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi4vZG9tL25vZGUnKTtcblxudmFyIGRlZmF1bHRUZW1wbGF0ZSA9IHt9O1xudmFyIGRlZmF1bHRIYW5kbGVycyA9IGV4dGVuZChyZXF1aXJlKCcuLi9oYW5kbGVycycpLCB7XG5cdCd0ZW1wbGF0ZSc6IHRlbXBsYXRlSGFuZGxlcixcblx0J2FwcGx5LXRlbXBsYXRlJzogYXBwbHlUZW1wbGF0ZUhhbmRsZXJcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRlbXBsYXRlQ29udGV4dCBleHRlbmRzIERPTUNvbnRleHQge1xuXHRjb25zdHJ1Y3Rvcih0ZW1wbGF0ZURvYywgaGFuZGxlcnMpIHtcblx0XHRzdXBlcihleHRlbmQoZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycyB8fCB7fSkpO1xuXHRcdC8vINGB0L7Qt9C00LDRkdC8INC60LDRgNGC0YMg0YjQsNCx0LvQvtC90L7Qsjog0LjQtyDQstGB0LXRhSDQtNC+0LrRg9C80LXQvdGC0L7QsiDQv9C+0LvRg9GH0LDQtdC8INC40LzQtdC90LBcblx0XHQvLyDRiNCw0LHQu9C+0L3QvtCyINC4INGF0YDQsNC90LjQvCDQuNGFINCyINC/0L7RgNGP0LTQutC1INC00L7QsdCw0LLQu9C10L3QuNGPXG5cdFx0dmFyIHRlbXBsYXRlTWFwID0gdGhpcy5fdGVtcGxhdGVNYXAgPSBuZXcgTWFwKCk7XG5cdFx0dmFyIGRvY3MgPSBBcnJheS5pc0FycmF5KHRlbXBsYXRlRG9jKSA/IHRlbXBsYXRlRG9jIDogW3RlbXBsYXRlRG9jXTtcblx0XHRkb2NzLmZvckVhY2goZnVuY3Rpb24oZG9jKSB7XG5cdFx0XHRmaW5kVGVtcGxhdGVzKGRvYykuZm9yRWFjaChmdW5jdGlvbih0ZW1wbGF0ZSkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IHRlbXBsYXRlLmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8IGRlZmF1bHRUZW1wbGF0ZTtcblx0XHRcdFx0dmFyIGxpc3QgPSB0ZW1wbGF0ZU1hcC5nZXQobmFtZSk7XG5cdFx0XHRcdGlmICghbGlzdCkge1xuXHRcdFx0XHRcdGxpc3QgPSBbdGVtcGxhdGVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QucHVzaCh0ZW1wbGF0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGVNYXAuc2V0KG5hbWUsIGxpc3QpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHRnZXRCeU5hbWUobmFtZSkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fdGVtcGxhdGVNYXAuZ2V0KG5hbWUpO1xuXHRcdHJldHVybiBsaXN0ID8gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdIDogbnVsbDtcblx0fVxuXG5cdHRyYW5zZm9ybShkYXRhKSB7XG5cdFx0dmFyIGVudHJ5UG9pbnQgPSB0aGlzLl90ZW1wbGF0ZU1hcC5nZXQoZGVmYXVsdFRlbXBsYXRlKTtcblx0XHRpZiAoIWVudHJ5UG9pbnQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gZW50cnkgcG9pbnQgKGRlZmF1bHQgdGVtcGxhdGUpJyk7XG5cdFx0fVxuXHRcdHRoaXMuZW50ZXIoZGF0YSk7XG5cdFx0cmV0dXJuIHN1cGVyLnRyYW5zZm9ybShlbnRyeVBvaW50WzBdKTtcblx0fVxufTtcblxuZnVuY3Rpb24gZmluZFRlbXBsYXRlcyhkb2MpIHtcblx0dmFyIHJvb3QgPSBkb2Mub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgY2hpbGQgb2Ygcm9vdC5jaGlsZE5vZGVzKSB7XG5cdFx0aWYgKGNoaWxkLm5vZGVOYW1lID09PSAndGVtcGxhdGUnKSB7XG5cdFx0XHRvdXQucHVzaChjaGlsZCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDQntCx0YDQsNCx0L7RgtC60LAg0Y3Qu9C10LzQtdC90YLQsCA8dGVtcGxhdGU+XG4gKi9cbmZ1bmN0aW9uKiB0ZW1wbGF0ZUhhbmRsZXIobm9kZSwgY3R4KSB7XG5cdGZvciAodmFyIGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuXHRcdHlpZWxkIGNoaWxkO1xuXHR9XG59XG5cbi8qKlxuICog0J7QsdGA0LDQsdC+0YLQutCwINGN0LvQtdC80LXQvdGC0LAgPGFwcGx5LXRlbXBsYXRlIG5hbWU9XCJcIiBzZWxlY3Q9XCJcIj46XG4gKiDQvdCw0YXQvtC00LjQvCDRiNCw0LHQu9C+0L0g0YEg0YPQutCw0LfQsNC90L3Ri9C8INC40LzQtdC90LXQvCDQsiDRgdC/0LjRgdC60LUg0LfQsNGA0LXQs9C40YHRgtGA0LjRgNC+0LLQsNC90L3Ri9GFINC4LCDQtdGB0LvQuCDQtdGB0YLRjFxuICog0LDRgtGA0LjQsdGD0YIgc2VsZWN0LCDRg9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDRgtC10LrRg9GJ0LjQuSDQutC+0L3RgtC10LrRgdGCLCDRgNCw0LLQvdGL0Lkg0YDQtdC30YPQu9GM0YLQsNGC0YMgXG4gKiDRjdGC0L7Qs9C+INCy0YvRgNCw0LbQtdC90LjRj1xuICovXG5mdW5jdGlvbiogYXBwbHlUZW1wbGF0ZUhhbmRsZXIobm9kZSwgY3R4KSB7XG5cdGRlYnVnKCdhcHBseSB0ZW1wbGF0ZScpO1xuXHR2YXIgdG1wbE5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXHRpZiAoIXRtcGxOYW1lKSB7XG5cdFx0ZGVidWcoJ25vIHRlbXBsYXRlIG5hbWUsIGFib3J0aW5nJyk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHRtcGwgPSBjdHguZ2V0QnlOYW1lKHRtcGxOYW1lKTtcblx0aWYgKCF0bXBsKSB7XG5cdFx0ZGVidWcoJ25vIHRlbXBsYXRlIGZvciBuYW1lICVzLCBhYm9ydGluZycsIHRtcGxOYW1lKTtcblx0fVxuXG5cdHZhciBjdHhFeHByID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3NlbGVjdCcpO1xuXHRpZiAoY3R4RXhwcikge1xuXHRcdGxldCByZXN1bHQgPSB4cGF0aC5zZWxlY3QoY3R4RXhwciwgY3R4LmNvbnRleHQpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRjdHguZW50ZXIocmVzdWx0WzBdKTtcblx0XHRcdHlpZWxkIHRtcGw7XG5cdFx0XHRjdHgubGVhdmUoKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0eWllbGQgdG1wbDtcblx0fVxufSIsIi8qKlxuICog0JrQu9Cw0YHRgSDQtNC70Y8g0L/RgNC10LTRgdGC0LDQstC70LXQvdC40Y8g0LDRgtGA0LjQsdGD0YLQsCDRjdC70LXQvNC10L3RgtCwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBBdHRyaWJ1dGUgZXh0ZW5kcyBOb2RlIHtcblx0Y29uc3RydWN0b3IobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblx0XHR9XG5cdFx0c3VwZXIoTm9kZS5BVFRSSUJVVEVfTk9ERSk7XG5cblx0XHR0aGlzLm5vZGVOYW1lID0gbmFtZTtcblx0XHR0aGlzLm5vZGVWYWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMub3duZXJFbGVtZW50ID0gbnVsbDtcblx0fVxuXG5cdGdldCBvd25lckRvY3VtZW50KCkge1xuXHRcdHJldHVybiBjdHgub3duZXJFbGVtZW50ICYmIGN0eC5vd25lckVsZW1lbnQub3duZXJEb2N1bWVudDtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLm5vZGVOYW1lO1xuXHR9XG5cblx0c2V0IG5hbWUodmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5ub2RlTmFtZSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLm5vZGVWYWx1ZTtcblx0fVxuXG5cdHNldCB2YWx1ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLm5vZGVWYWx1ZSA9IHZhbHVlO1xuXHR9XG59OyIsIi8qKlxuICog0JrQu9Cw0YHRgSDQtNC70Y8g0L/RgNC10LTRgdGC0LDQstC70Y/QtdC90LjRjyDQutC+0YDQvdC10LLQvtCz0L4g0Y3Qu9C10LzQtdC90YLQsCDQtNC10YDQtdCy0LBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbnZhciBUZXh0ID0gcmVxdWlyZSgnLi90ZXh0Jyk7XG52YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEb2N1bWVudCBleHRlbmRzIE5vZGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihOb2RlLkRPQ1VNRU5UX05PREUpO1xuXHR9XG5cblx0Ly8gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdC8vIGNyZWF0ZUNvbW1lbnQoZGF0YSlcblx0Ly8gY3JlYXRlQ0RBVEFTZWN0aW9uKGRhdGEpXG5cdC8vIGNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbih0YXJnZXQsIGRhdGEpXG5cdC8vIGNyZWF0ZUVudGl0eVJlZmVyZW5jZShuYW1lKVxuXHQvLyBpbXBvcnROb2RlKGltcG9ydGVkTm9kZSwgZGVlcClcblxuXHRjcmVhdGVFbGVtZW50KHRhZ05hbWUpIHtcblx0XHRyZXR1cm4gbmV3IEVsZW1lbnQodGFnTmFtZSk7XG5cdH1cblxuXHRjcmVhdGVUZXh0Tm9kZShkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBUZXh0KGRhdGEpO1xuXHR9XG5cblx0Y3JlYXRlQXR0cmlidXRlKG5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IEF0dHJpYnV0ZShuYW1lKTtcblx0fVxuXG5cdGdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpIHtcblx0XHRyZXR1cm4gRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUuY2FsbCh0aGlzLCBuYW1lKTtcblx0fVxuXG5cdGdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH1cblxuXHRnZXQgb3duZXJEb2N1bWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGdldCBkb2N1bWVudEVsZW1lbnQoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5fY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NoaWxkTm9kZXNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Z2V0IGlubmVySFRNTCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbm9kZS5ub2RlVmFsdWUgOiBub2RlLm91dGVySFRNTDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdGdldCBvdXRlckhUTUwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5uZXJIVE1MO1xuXHR9XG59OyIsIi8qKlxuICog0JrQu9Cw0YHRgSDQtNC70Y8g0L/RgNC10LTRgdGC0LDQstC70LXQvdC40Y8g0YPQt9C70LAg0Y3Qu9C10LzQtdC90YLQsFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG52YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGUnKTtcbnZhciBub2RlTGlzdCA9IHJlcXVpcmUoJy4vbm9kZS1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRWxlbWVudCBleHRlbmRzIE5vZGUge1xuXHRjb25zdHJ1Y3RvcihuYW1lKSB7XG5cdFx0aWYgKCFuYW1lKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbmFtZSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXHRcdH1cblxuXHRcdHN1cGVyKE5vZGUuRUxFTUVOVF9OT0RFKTtcblx0XHR0aGlzLm5vZGVOYW1lID0gbmFtZTtcblx0fVxuXG5cdGdldEF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzLmdldChuYW1lKTtcblx0XHRyZXR1cm4gYXR0ciA/IGF0dHIudmFsdWUgOiB2b2lkIDA7XG5cdH1cblxuXHRzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAobmFtZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuXHRcdFx0Ly8gcmVwbGFjZSBhdHRyaWJ1dGUgbm9kZVxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlTm9kZShuYW1lKTtcblx0XHR9XG5cblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZShuYW1lKTtcblx0XHRpZiAoIWF0dHIpIHtcblx0XHRcdGF0dHIgPSBuZXcgQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXR0ci52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblx0XHR0aGlzLnNldEF0dHJpYnV0ZU5vZGUoYXR0cik7XG5cdH1cblxuXHRyZW1vdmVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdHRoaXMuX2F0dHJpYnV0ZXMuZGVsZXRlKG5hbWUpO1xuXHR9XG5cblx0cmVtb3ZlQXR0cmlidXRlTm9kZShhdHRyKSB7XG5cdFx0Zm9yICh2YXIgaXRlbSBvZiB0aGlzLl9hdHRyaWJ1dGVzKSB7XG5cdFx0XHRpZiAoaXRlbVsxXSA9PT0gYXR0cikge1xuXHRcdFx0XHR0aGlzLl9hdHRyaWJ1dGVzLmRlbGV0ZShpdGVtWzBdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aGFzQXR0cmlidXRlKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5oYXMobmFtZSk7XG5cdH1cblxuXHRnZXRBdHRyaWJ1dGVOb2RlKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5nZXQobmFtZSk7XG5cdH1cblxuXHRzZXRBdHRyaWJ1dGVOb2RlKGF0dHIpIHtcblx0XHRsZXQgcHJldiA9IHRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGF0dHIubmFtZSk7XG5cdFx0aWYgKHByZXYgJiYgcHJldiAhPT0gYXR0cikge1xuXHRcdFx0cHJldi5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dGhpcy5fYXR0cmlidXRlcy5zZXQoYXR0ci5uYW1lLCBhdHRyKTtcblx0XHRhdHRyLm93bmVyRWxlbWVudCA9IHRoaXM7XG5cdH1cblxuXHRnZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSB7XG5cdFx0dmFyIG91dCA9IG5vZGVMaXN0KCk7XG5cdFx0dmFyIGFsbCA9IChuYW1lID09PSAnKicpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMuX2NoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0bGV0IG5vZGUgPSB0aGlzLl9jaGlsZE5vZGVzW2ldO1xuXHRcdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdFx0XHRcdGlmIChhbGwgfHwgbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSkge1xuXHRcdFx0XHRcdG91dC5wdXNoKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG91dCA9IG91dC5jb25jYXQobm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRnZXQgdGFnTmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ub2RlTmFtZTtcblx0fVxuXG5cdGdldCBpbm5lckhUTUwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkTm9kZXMubWFwKHN0cmluZ2lmeSkuam9pbignJyk7XG5cdH1cblxuXHRnZXQgb3V0ZXJIVE1MKCkge1xuXHRcdHJldHVybiBzdHJpbmdpZnkodGhpcyk7XG5cdH1cbn07XG5cbi8vINCU0LDQvdC90YvQtSDRjdC70LXQvNC10L3RgtGLINC90LUg0LzQvtCz0YPRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0LrQvtC90YLQtdC90YIg0YHQu9C10LTQvtCy0LDRgtC10LvRjNC90L4g0L3QtSDQvNC+0LPRg9GCINC40LzQtdGC0Ywg0LfQsNC60YDRi9Cy0LDRjtGI0LjQuSDRgtC10LMuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9zeW50YXguaHRtbCN2b2lkLWVsZW1lbnRzXG5jb25zdCB2b2lkRWxlbWVudHNMaXN0ID0gW1xuXHQnYXJlYScsXG5cdCdiYXNlJyxcblx0J2JyJyxcblx0J2NvbCcsXG5cdCdlbWJlZCcsXG5cdCdocicsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQna2V5Z2VuJyxcblx0J2xpbmsnLFxuXHQnbWVudWl0ZW0nLFxuXHQnbWV0YScsXG5cdCdwYXJhbScsXG5cdCdzb3VyY2UnLFxuXHQndHJhY2snLFxuXHQnd2JyJ1xuXTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcblx0aWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdFx0cmV0dXJuIG5vZGUubm9kZVZhbHVlO1xuXHR9XG5cblx0aWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdFx0bGV0IGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRyZXR1cm4gYCAke2F0dHIubmFtZX09XCIke2F0dHIudmFsdWV9XCJgO1xuXHRcdH0pLmpvaW4oJycpO1xuXHRcdGxldCB7bm9kZU5hbWV9ID0gbm9kZTtcblxuXHRcdGlmICh+dm9pZEVsZW1lbnRzTGlzdC5pbmRleE9mKG5vZGVOYW1lKSkge1xuXHRcdFx0cmV0dXJuIGA8JHtub2RlTmFtZX0ke2F0dHJzfSAvPmA7XG5cdFx0fVxuXHRcdHJldHVybiBgPCR7bm9kZU5hbWV9JHthdHRyc30+JHtub2RlLl9jaGlsZE5vZGVzLm1hcChzdHJpbmdpZnkpLmpvaW4oJycpfTwvJHtub2RlTmFtZX0+YDtcblx0fVxuXG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZWxlbWVudCB0eXBlOiAnICsgbm9kZS5ub2RlVHlwZSk7XG59OyIsIid1c2Ugc3J0aWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIpIHtcblx0YXJyID0gYXJyIHx8IFtdO1xuXHRhcnIuaXRlbSA9IGl0ZW07XG5cdHJldHVybiBhcnI7XG59O1xuXG5mdW5jdGlvbiBpdGVtKG4pIHtcblx0cmV0dXJuIHRoaXNbbl07XG59IiwiLyoqXG4gKiDQkdCw0LfQvtCy0YvQuSDQutC70LDRgdGBINC00LvRjyDQv9GA0LXQtNGB0YLQsNCy0LvRj9C10L3QuNGPINGD0LfQu9CwINCyINC00LXRgNC10LLQtVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub2RlTGlzdCA9IHJlcXVpcmUoJy4vbm9kZS1saXN0Jyk7XG5cbnZhciBOb2RlID0gbW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKHR5cGUpIHtcblx0XHR0aGlzLm5vZGVUeXBlID0gdHlwZTtcblx0XHR0aGlzLm5vZGVOYW1lID0gbnVsbDtcblx0XHR0aGlzLm5vZGVWYWx1ZSA9IG51bGw7XG5cdFx0dGhpcy5wYXJlbnROb2RlID0gbnVsbDtcblx0XHR0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcblx0XHR0aGlzLnByZXZpb3VzU2libGluZyA9IG51bGw7XG5cblx0XHR0aGlzLl9jaGlsZE5vZGVzID0gW107XG5cdFx0dGhpcy5fYXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdGdldCBjaGlsZE5vZGVzKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZE5vZGVzLnNsaWNlKDApO1xuXHR9XG5cblx0Z2V0IGZpcnN0Q2hpbGQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkTm9kZXNbMF07XG5cdH1cblxuXHRnZXQgbGFzdENoaWxkKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZE5vZGVzW3RoaXMuX2NoaWxkTm9kZXMubGVuZ3RoIC0gMV07XG5cdH1cblxuXHRnZXQgYXR0cmlidXRlcygpIHtcblx0XHR2YXIgb3V0ID0gbm9kZUxpc3QoKTtcblx0XHRmb3IgKHZhciBhdHRyIG9mIHRoaXMuX2F0dHJpYnV0ZXMudmFsdWVzKCkpIHtcblx0XHRcdG91dC5wdXNoKGF0dHIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRnZXQgb3duZXJEb2N1bWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5vd25lckRvY3VtZW50O1xuXHR9XG5cblx0Z2V0IGxvY2FsTmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ub2RlTmFtZTtcblx0fVxuXG5cdGFwcGVuZENoaWxkKG5vZGUpIHtcblx0XHRyZXR1cm4gaW5zZXJ0Q2hpbGRBdCh0aGlzLCBub2RlLCAnbGFzdCcpO1xuXHR9XG5cblx0aW5zZXJ0QmVmb3JlKG5vZGUsIHByZXYpIHtcblx0XHR2YXIgaXggPSB0aGlzLl9jaGlsZE5vZGVzLmluZGV4T2YocHJldik7XG5cdFx0aWYgKGl4ICE9PSAtMSkge1xuXHRcdFx0aW5zZXJ0Q2hpbGRBdCh0aGlzLCBub2RlLCBpeCk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0cmVtb3ZlQ2hpbGQobm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkTm9kZXM7XG5cdFx0dmFyIGl4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcblx0XHRpZiAoaXggPT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9XG5cblx0XHR2YXIgcHJldiA9IGNoaWxkcmVuW2l4IC0gMV07XG5cdFx0dmFyIG5leHQgPSBjaGlsZHJlbltpeCArIDFdO1xuXHRcdGNoaWxkcmVuLnNwbGljZShpeCwgMSk7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0U2libGluZyA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldmlvdXNTaWJsaW5nID0gcHJldjtcblx0XHR9XG5cdH1cblxuXHRyZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKSB7XG5cdFx0dmFyIGl4ID0gdGhpcy5fY2hpbGROb2Rlcy5pbmRleE9mKG9sZENoaWxkKTtcblx0XHRpZiAoaXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUNoaWxkKG9sZENoaWxkKTtcblx0XHRcdGluc2VydENoaWxkQXQodGhpcywgbmV3Q2hpbGQsIGl4KTtcblx0XHR9XG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fVxuXG5cdGNsb25lTm9kZShkZWVwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fVxuXG5cdGhhc0NoaWxkTm9kZXMoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fY2hpbGROb2Rlcy5sZW5ndGg7XG5cdH1cblxuXHRoYXNBdHRyaWJ1dGVzKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTtcblx0fVxufTtcblxuTm9kZS5FTEVNRU5UX05PREUgPSAxO1xuTm9kZS5BVFRSSUJVVEVfTk9ERSA9IDI7XG5Ob2RlLlRFWFRfTk9ERSA9IDM7XG5Ob2RlLkNEQVRBX1NFQ1RJT05fTk9ERSA9IDQ7XG5Ob2RlLkVOVElUWV9SRUZFUkVOQ0VfTk9ERSA9IDU7XG5Ob2RlLkVOVElUWV9OT0RFID0gNjtcbk5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gNztcbk5vZGUuQ09NTUVOVF9OT0RFID0gODtcbk5vZGUuRE9DVU1FTlRfTk9ERSA9IDk7XG5Ob2RlLkRPQ1VNRU5UX1RZUEVfTk9ERSA9IDEwO1xuTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbmZ1bmN0aW9uIGluc2VydENoaWxkQXQocGFyZW50LCBjaGlsZCwgcG9zKSB7XG5cdC8vIHJlbW92ZSBjaGlsZCBmcm9tIHByZXZpb3VzIHBhcmVudFxuXHRpZiAoY2hpbGQucGFyZW50Tm9kZSkge1xuXHRcdGNoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHR9XG5cblx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZE5vZGVzO1xuXHRpZiAocG9zID09PSAnbGFzdCcpIHtcblx0XHRwb3MgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdH0gZWxzZSBpZiAocG9zID09PSAnZmlyc3QnKSB7XG5cdFx0cG9zID0gMDtcblx0fVxuXG5cdHBvcyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHBvcyksIGNoaWxkcmVuLmxlbmd0aCk7XG5cdHZhciBwcmV2ID0gY2hpbGRyZW5bcG9zIC0gMV07XG5cdHZhciBuZXh0ID0gY2hpbGRyZW5bcG9zICsgMV07XG5cblx0Y2hpbGRyZW4uc3BsaWNlKHBvcywgMCwgY2hpbGQpO1xuXHRjaGlsZC5wYXJlbnROb2RlID0gcGFyZW50O1xuXHRjaGlsZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2O1xuXHRjaGlsZC5uZXh0U2libGluZyA9IG5leHQ7XG5cblx0aWYgKHByZXYpIHtcblx0XHRwcmV2Lm5leHRTaWJsaW5nID0gY2hpbGQ7XG5cdH1cblxuXHRpZiAobmV4dCkge1xuXHRcdG5leHQucHJldmlvdXNTaWJsaW5nID0gY2hpbGQ7XG5cdH1cblxuXHRyZXR1cm4gY2hpbGQ7XG59XG4iLCIvKipcbiAqINCa0LvQsNGB0YEg0LTQu9GPINC/0YDQtdC00YHRgtCw0LLQu9C10L3QuNGPINGC0LXQutGB0YLQvtCy0L7Qs9C+INGD0LfQu9CwXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUZXh0IGV4dGVuZHMgTm9kZSB7XG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoTm9kZS5URVhUX05PREUpO1xuXHRcdHRoaXMubm9kZVZhbHVlID0gdmFsdWUgfHwgJyc7XG5cdH1cbn07IiwiLyoqXG4gKiDQodGC0LDQvdC00LDRgNGC0L3Ri9C1INGF0Y3QvdC00LvQtdGA0Ysg0LTQu9GPINGN0LvQtdC80LXQvdGC0L7QsiDRiNCw0LHQu9C+0L3QsFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB4cGF0aCA9IHJlcXVpcmUoJ3hwYXRoJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vZG9tL25vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuXHQgKiDQntCx0YDQsNCx0L7RgtC60LAgPGF0dHJpYnV0ZSBuYW1lPVwiXCIgdmFsdWU9XCJcIi8+OlxuXHQgKiDQtNC+0LHQsNCy0LvRj9C10YIg0LDRgtGA0LjQsdGD0YIg0LrQvtC90YLQtdC60YHRgtC90L7QvNGDINGB0LPQtdC90LXRgNC40YDQvtCy0LDQvdC90L7QvNGDINGN0LvQtdC80LXQvdGC0YNcblx0ICovXG5cdCdhdHRyaWJ1dGUnOiBmdW5jdGlvbioobm9kZSwgY3R4KSB7XG5cdFx0dmFyIHZhbHVlID0gJyc7XG5cblx0XHRpZiAobm9kZS5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcblx0XHRcdHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJlbnQgPSBjdHgub3V0cHV0Q3R4O1xuXHRcdFx0Y3R4Lm91dHB1dEN0eCA9IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuXHRcdFx0XHR5aWVsZCBjaGlsZDtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdXRpbHMuaW5uZXJUZXh0KGN0eC5vdXRwdXRDdHgpO1xuXHRcdFx0Y3R4Lm91dHB1dEN0eCA9IHBhcmVudDtcblx0XHR9XG5cdFx0Y3R4LnB1c2hBdHRyaWJ1dGUobm9kZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSwgdmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiDQntCx0YDQsNCx0L7RgtC60LAgPHZhbHVlLW9mIHNlbGVjdD1cIi4uLlwiLz46XG5cdCAqINC/0L4geHBhdGgt0LfQsNC/0YDQvtGB0YMg0LjQtyDQsNGC0YDQuNCx0YPRgtCwIHNlbGVjdCDQtNC+0YHRgtCw0ZHRgiDRgNC10LfRg9C70YzRgtCw0YIg0LgsINC10YHQu9C4INC+0L0g0LXRgdGC0YwsXG5cdCAqINCy0YvQstC+0LTQuNGCINC10LPQviDRgtC10LrRgdGC0L7QstC+0LUg0YHQvtC00LXRgNC20LjQvNC+0LVcblx0ICovXG5cdCd2YWx1ZS1vZic6IGZ1bmN0aW9uKihub2RlLCBjdHgpIHtcblx0XHR2YXIgZXhwciA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzZWxlY3QnKTtcblx0XHRpZiAoZXhwcikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHhwYXRoLnNlbGVjdDEoZXhwciwgY3R4LmNvbnRleHQpO1xuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRcdGN0eC5wdXNoVGV4dChyZXN1bHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICog0J7QsdGA0LDQsdC+0YLQutCwIDxjb3B5LW9mIHNlbGVjdD1cIi4uLlwiLz46XG5cdCAqINC/0L4geHBhdGgt0LfQsNC/0YDQvtGB0YMg0LjQtyDQsNGC0YDQuNCx0YPRgtCwIHNlbGVjdCDQtNC+0YHRgtCw0ZHRgiDRgNC10LfRg9C70YzRgtCw0YIg0LgsINC10YHQu9C4INC+0L0g0LXRgdGC0YwsXG5cdCAqINC60L7Qv9C40YDRg9C10YIg0LXQs9C+INGB0L7QtNC10YDQttC40LzQvtC1XG5cdCAqL1xuXHQnY29weS1vZic6IGZ1bmN0aW9uKihub2RlLCBjdHgpIHtcblx0XHR2YXIgZXhwciA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzZWxlY3QnKTtcblx0XHRpZiAoZXhwcikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHhwYXRoLnNlbGVjdChleHByLCBjdHguY29udGV4dCk7XG5cdFx0XHRmb3IgKGxldCBjaGlsZCBvZiByZXN1bHQpIHtcblx0XHRcdFx0Y29weU5vZGUoY2hpbGQsIGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiDQntCx0YDQsNCx0L7RgtC60LAgPGlmIHRlc3Q9XCIuLi5cIi8+OlxuXHQgKiDQv9C+IHhwYXRoLdC30LDQv9GA0L7RgdGDINC40Lcg0LDRgtGA0LjQsdGD0YLQsCB0ZXN0INC00L7RgdGC0LDRkdGCINGA0LXQt9GD0LvRjNGC0LDRgiDQuCDQv9GA0LjQstC+0LTQuNGCINC10LPQviDQuiBCb29sZWFuLCBcblx0ICog0LXRgdC70Lgg0YDQtdC30YPQu9GM0YLQsNGCINC/0L7Qu9C+0LbQuNGC0LXQu9GM0L3Ri9C5LCDRgtC+INCy0YvQv9C+0LvQvdGP0LXRgiDQstC70L7QttC10L3QvdGL0Lkg0YjQsNCx0LvQvtC9LlxuXHQgKi9cblx0J2lmJzogZnVuY3Rpb24qKG5vZGUsIGN0eCkge1xuXHRcdHZhciBleHByID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3Rlc3QnKTtcblx0XHRpZiAoZXhwcikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHhwYXRoLnNlbGVjdChleHByLCBjdHguY29udGV4dCk7XG5cdFx0XHRpZiAoKEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdC5maWx0ZXIoQm9vbGVhbikubGVuZ3RoIDogcmVzdWx0KSkge1xuXHRcdFx0XHRmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpIHtcblx0XHRcdFx0XHR5aWVsZCBjaGlsZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gY29weU5vZGUobm9kZSwgY3R4KSB7XG5cdGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdGN0eC5wdXNoRWxlbWVudChub2RlLm5vZGVOYW1lLCBub2RlLmF0dHJpYnV0ZXMpO1xuXHRcdGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuXHRcdFx0Y29weU5vZGUoY2hpbGQsIGN0eCk7XG5cdFx0fVxuXHRcdGN0eC5wb3BFbGVtZW50KCk7XG5cdH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRjdHgucHVzaFRleHQobm9kZS5ub2RlVmFsdWUpO1xuXHR9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gTm9kZS5BVFRSSUJVVEVfTk9ERSkge1xuXHRcdGN0eC5wdXNoQXR0cmlidXRlKG5vZGUubmFtZSwgbm9kZS52YWx1ZSk7XG5cdH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9kb20vbm9kZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3RyaW5naWZ5KG9iaikge1xuXHRcdGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAnbm9kZVR5cGUnIGluIG9iaikge1xuXHRcdFx0aWYgKG9iai5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0XHRcdFx0cmV0dXJuIGlubmVyVGV4dChvYmopO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2JqLm5vZGVUeXBlID09PSBOb2RlLkFUVFJJQlVURV9OT0RFKSB7XG5cdFx0XHRcdHJldHVybiBvYmoudmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAnbm9kZVZhbHVlJyBpbiBvYmogPyBvYmoubm9kZVZhbHVlIDogJyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFN0cmluZyhvYmopO1xuXHR9LFxuXG5cdGlubmVyVGV4dChub2RlKSB7XG5cdFx0cmV0dXJuIGlubmVyVGV4dChub2RlKTtcblx0fVxufTtcblxuZnVuY3Rpb24gaW5uZXJUZXh0KG5vZGUpIHtcblx0aWYgKCdpbm5lclRleHQnIGluIG5vZGUpIHtcblx0XHRyZXR1cm4gbm9kZS5pbm5lclRleHQ7XG5cdH1cblxuXHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRyZXR1cm4gbm9kZS5ub2RlVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gbm9kZS5jaGlsZE5vZGVzLm1hcChmdW5jdGlvbihub2RlKSB7XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdFx0XHRyZXR1cm4gbm9kZS5ub2RlVmFsdWU7XG5cdFx0fSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGlubmVyVGV4dChub2RlKTtcblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9KS5qb2luKCcnKTtcbn0iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8qKlxuICogQSB0cmltbWVkIHZlcnNpb24gb2YgQ29kZU1pcnJvcidzIFN0cmluZ1N0cmVhbSBtb2R1bGUgZm9yIHN0cmluZyBwYXJzaW5nXG4gKi9cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG5cdHZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuXHR9O1xufVxuXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSBTdHJpbmdTdHJlYW1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgQXNzdW1pbmcgdGhhdCBib3VuZCBzdHJpbmcgc2hvdWxkIGJlXG5cdCAqIGltbXV0YWJsZVxuXHQgKi9cblx0ZnVuY3Rpb24gU3RyaW5nU3RyZWFtKHN0cmluZykge1xuXHRcdHRoaXMucG9zID0gdGhpcy5zdGFydCA9IDA7XG5cdFx0dGhpcy5zdHJpbmcgPSBzdHJpbmc7XG5cdFx0dGhpcy5fbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0fVxuXHRcblx0U3RyaW5nU3RyZWFtLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZW9sOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLl9sZW5ndGg7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHNvbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wb3MgPT09IDA7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBuZXh0IGNoYXJhY3RlciBpbiB0aGUgc3RyZWFtIHdpdGhvdXQgYWR2YW5jaW5nIGl0LiBcblx0XHQgKiBXaWxsIHJldHVybiA8Y29kZT51bmRlZmluZWQ8L2NvZGU+IGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRwZWVrOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmVhbSBhbmQgYWR2YW5jZXMgaXQuXG5cdFx0ICogQWxzbyByZXR1cm5zIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gd2hlbiBubyBtb3JlIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdG5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMucG9zIDwgdGhpcy5fbGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogbWF0Y2ggY2FuIGJlIGEgY2hhcmFjdGVyLCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgYSBmdW5jdGlvbiB0aGF0XG5cdFx0ICogdGFrZXMgYSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgYSBib29sZWFuLiBJZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gdGhlXG5cdFx0ICogc3RyZWFtICdtYXRjaGVzJyB0aGUgZ2l2ZW4gYXJndW1lbnQsIGl0IGlzIGNvbnN1bWVkIGFuZCByZXR1cm5lZC5cblx0XHQgKiBPdGhlcndpc2UsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGVhdDogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdHZhciBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyksIG9rO1xuXHRcdFx0aWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRvayA9IGNoID09IG1hdGNoO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvayA9IGNoICYmIChtYXRjaC50ZXN0ID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuXHRcdFx0XG5cdFx0XHRpZiAob2spIHtcblx0XHRcdFx0Kyt0aGlzLnBvcztcblx0XHRcdFx0cmV0dXJuIGNoO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwZWF0ZWRseSBjYWxscyA8Y29kZT5lYXQ8L2NvZGU+IHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LCB1bnRpbCBpdFxuXHRcdCAqIGZhaWxzLiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIGFueSBjaGFyYWN0ZXJzIHdlcmUgZWF0ZW4uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG1hdGNoXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZWF0V2hpbGU6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSB0aGlzLnBvcztcblx0XHRcdHdoaWxlICh0aGlzLmVhdChtYXRjaCkpIHt9XG5cdFx0XHRyZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNob3J0Y3V0IGZvciA8Y29kZT5lYXRXaGlsZTwvY29kZT4gd2hlbiBtYXRjaGluZyB3aGl0ZS1zcGFjZS5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRlYXRTcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSB0aGlzLnBvcztcblx0XHRcdHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuXHRcdFx0XHQrK3RoaXMucG9zO1xuXHRcdFx0cmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBNb3ZlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cblx0XHQgKi9cblx0XHRza2lwVG9FbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wb3MgPSB0aGlzLl9sZW5ndGg7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTa2lwcyB0byB0aGUgbmV4dCBvY2N1cnJlbmNlIG9mIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGlmIGZvdW5kIG9uIHRoZVxuXHRcdCAqIGN1cnJlbnQgbGluZSAoZG9lc24ndCBhZHZhbmNlIHRoZSBzdHJlYW0gaWYgdGhlIGNoYXJhY3RlciBkb2VzIG5vdFxuXHRcdCAqIG9jY3VyIG9uIHRoZSBsaW5lKS4gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjaFxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHNraXBUbzogZnVuY3Rpb24oY2gpIHtcblx0XHRcdHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcblx0XHRcdGlmIChmb3VuZCA+IC0xKSB7XG5cdFx0XHRcdHRoaXMucG9zID0gZm91bmQ7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2tpcHMgdG8gPGNvZGU+Y2xvc2U8L2NvZGU+IGNoYXJhY3RlciB3aGljaCBpcyBwYWlyIHRvIDxjb2RlPm9wZW48L2NvZGU+XG5cdFx0ICogY2hhcmFjdGVyLCBjb25zaWRlcmluZyBwb3NzaWJsZSBwYWlyIG5lc3RpbmcuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuXHRcdCAqIHRvIGNvbnN1bWUgcGFpciBvZiBjaGFyYWN0ZXJzLCBsaWtlIG9wZW5pbmcgYW5kIGNsb3NpbmcgYnJhY2VzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG9wZW5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY2xvc2Vcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBwYWlyIHdhcyBzdWNjZXNzZnVsbHlcblx0XHQgKiBjb25zdW1lZFxuXHRcdCAqL1xuXHRcdHNraXBUb1BhaXI6IGZ1bmN0aW9uKG9wZW4sIGNsb3NlLCBza2lwU3RyaW5nKSB7XG5cdFx0XHR2YXIgYnJhY2VDb3VudCA9IDAsIGNoO1xuXHRcdFx0dmFyIHBvcyA9IHRoaXMucG9zLCBsZW4gPSB0aGlzLl9sZW5ndGg7XG5cdFx0XHR3aGlsZSAocG9zIDwgbGVuKSB7XG5cdFx0XHRcdGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHBvcysrKTtcblx0XHRcdFx0aWYgKGNoID09IG9wZW4pIHtcblx0XHRcdFx0XHRicmFjZUNvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gY2xvc2UpIHtcblx0XHRcdFx0XHRicmFjZUNvdW50LS07XG5cdFx0XHRcdFx0aWYgKGJyYWNlQ291bnQgPCAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChza2lwU3RyaW5nICYmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSkge1xuXHRcdFx0XHRcdHRoaXMuc2tpcFN0cmluZyhjaCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBIGhlbHBlciBmdW5jdGlvbiB3aGljaCwgaW4gY2FzZSBvZiBlaXRoZXIgc2luZ2xlIG9yXG5cdFx0ICogZG91YmxlIHF1b3RlIHdhcyBmb3VuZCBpbiBjdXJyZW50IHBvc2l0aW9uLCBza2lwcyBlbnRpcmVcblx0XHQgKiBzdHJpbmcgKHF1b3RlZCB2YWx1ZSlcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBXZXRoZXIgcXVvdGVkIHN0cmluZyB3YXMgc2tpcHBlZFxuXHRcdCAqL1xuXHRcdHNraXBRdW90ZWQ6IGZ1bmN0aW9uKG5vQmFja3VwKSB7XG5cdFx0XHR2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQobm9CYWNrdXAgPyB0aGlzLnBvcyA6IHRoaXMucG9zIC0gMSk7XG5cdFx0XHRpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG5cdFx0XHRcdGlmIChub0JhY2t1cCkge1xuXHRcdFx0XHRcdHRoaXMucG9zKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2tpcFN0cmluZyhjaCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEEgY3VzdG9tIGZ1bmN0aW9uIHRvIHNraXAgc3RyaW5nIGxpdGVyYWwsIGUuZy4gYSBcImRvdWJsZS1xdW90ZWRcIlxuXHRcdCAqIG9yICdzaW5nbGUtcXVvdGVkJyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gcXVvdGUgQW4gb3BlbmluZyBxdW90ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0c2tpcFN0cmluZzogZnVuY3Rpb24ocXVvdGUpIHtcblx0XHRcdHZhciBwb3MgPSB0aGlzLnBvcywgbGVuID0gdGhpcy5fbGVuZ3RoLCBjaDtcblx0XHRcdHdoaWxlIChwb3MgPCBsZW4pIHtcblx0XHRcdFx0Y2ggPSB0aGlzLnN0cmluZy5jaGFyQXQocG9zKyspO1xuXHRcdFx0XHRpZiAoY2ggPT0gJ1xcXFwnKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gcXVvdGUpIHtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBCYWNrcyB1cCB0aGUgc3RyZWFtIG4gY2hhcmFjdGVycy4gQmFja2luZyBpdCB1cCBmdXJ0aGVyIHRoYW4gdGhlXG5cdFx0ICogc3RhcnQgb2YgdGhlIGN1cnJlbnQgdG9rZW4gd2lsbCBjYXVzZSB0aGluZ3MgdG8gYnJlYWssIHNvIGJlIGNhcmVmdWwuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG5cblx0XHQgKi9cblx0XHRiYWNrVXAgOiBmdW5jdGlvbihuKSB7XG5cdFx0XHR0aGlzLnBvcyAtPSBuO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWN0IGxpa2UgYSBtdWx0aS1jaGFyYWN0ZXIgPGNvZGU+ZWF0PC9jb2RlPuKAlGlmIDxjb2RlPmNvbnN1bWU8L2NvZGU+IGlzIHRydWUgb3Jcblx0XHQgKiBub3QgZ2l2ZW7igJRvciBhIGxvb2stYWhlYWQgdGhhdCBkb2Vzbid0IHVwZGF0ZSB0aGUgc3RyZWFtIHBvc2l0aW9u4oCUaWZcblx0XHQgKiBpdCBpcyBmYWxzZS4gPGNvZGU+cGF0dGVybjwvY29kZT4gY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhXG5cdFx0ICogcmVndWxhciBleHByZXNzaW9uIHN0YXJ0aW5nIHdpdGggXi4gV2hlbiBpdCBpcyBhIHN0cmluZyxcblx0XHQgKiA8Y29kZT5jYXNlSW5zZW5zaXRpdmU8L2NvZGU+IGNhbiBiZSBzZXQgdG8gdHJ1ZSB0byBtYWtlIHRoZSBtYXRjaFxuXHRcdCAqIGNhc2UtaW5zZW5zaXRpdmUuIFdoZW4gc3VjY2Vzc2Z1bGx5IG1hdGNoaW5nIGEgcmVndWxhciBleHByZXNzaW9uLFxuXHRcdCAqIHRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIHRoZSBhcnJheSByZXR1cm5lZCBieSA8Y29kZT5tYXRjaDwvY29kZT4sXG5cdFx0ICogaW4gY2FzZSB5b3UgbmVlZCB0byBleHRyYWN0IG1hdGNoZWQgZ3JvdXBzLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBjb25zdW1lXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBjYXNlSW5zZW5zaXRpdmVcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdG1hdGNoOiBmdW5jdGlvbihwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcblx0XHRcdGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHZhciBjYXNlZCA9IGNhc2VJbnNlbnNpdGl2ZVxuXHRcdFx0XHRcdD8gZnVuY3Rpb24oc3RyKSB7cmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO31cblx0XHRcdFx0XHQ6IGZ1bmN0aW9uKHN0cikge3JldHVybiBzdHI7fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjYXNlZCh0aGlzLnN0cmluZykuaW5kZXhPZihjYXNlZChwYXR0ZXJuKSwgdGhpcy5wb3MpID09IHRoaXMucG9zKSB7XG5cdFx0XHRcdFx0aWYgKGNvbnN1bWUgIT09IGZhbHNlKVxuXHRcdFx0XHRcdFx0dGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcblx0XHRcdFx0aWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuXHRcdFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzdHJpbmcgYmV0d2VlbiB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgdG9rZW4gYW5kIHRoZSBcblx0XHQgKiBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbi5cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGN1cnJlbnQ6IGZ1bmN0aW9uKGJhY2tVcCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zIC0gKGJhY2tVcCA/IDEgOiAwKSk7XG5cdFx0fVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG5ldyBTdHJpbmdTdHJlYW0oc3RyaW5nKTtcblx0fTtcblxuXHQvKiogQGRlcHJlY2F0ZWQgKi9cblx0bW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gbW9kdWxlLmV4cG9ydHM7XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn0pOyIsIi8qXHJcbiAqIHhwYXRoLmpzXHJcbiAqXHJcbiAqIEFuIFhQYXRoIDEuMCBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxyXG4gKlxyXG4gKiBDYW1lcm9uIE1jQ29ybWFjayA8Y2FtIChhdCkgbWNjLmlkLmF1PlxyXG4gKlxyXG4gKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIENyZWF0aXZlIENvbW1vbnMgQXR0cmlidXRpb24tU2hhcmVBbGlrZVxyXG4gKiBMaWNlbnNlLiBUbyB2aWV3IGEgY29weSBvZiB0aGlzIGxpY2Vuc2UsIHZpc2l0XHJcbiAqXHJcbiAqICAgaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1xyXG4gKlxyXG4gKiBvciBzZW5kIGEgbGV0dGVyIHRvIENyZWF0aXZlIENvbW1vbnMsIDU1OSBOYXRoYW4gQWJib3R0IFdheSwgU3RhbmZvcmQsXHJcbiAqIENhbGlmb3JuaWEgOTQzMDUsIFVTQS5cclxuICpcclxuICogUmV2aXNpb24gMjA6IEFwcmlsIDI2LCAyMDExXHJcbiAqICAgRml4ZWQgYSB0eXBvIHJlc3VsdGluZyBpbiBGSVJTVF9PUkRFUkVEX05PREVfVFlQRSByZXN1bHRzIGJlaW5nIHdyb25nLFxyXG4gKiAgIHRoYW5rcyB0byA8c2hpX2EwMDkgKGF0KSBob3RtYWlsLmNvbT4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE5OiBOb3ZlbWJlciAyOSwgMjAwNVxyXG4gKiAgIE5vZGVzZXRzIG5vdyBzdG9yZSB0aGVpciBub2RlcyBpbiBhIGhlaWdodCBiYWxhbmNlZCB0cmVlLCBpbmNyZWFzaW5nXHJcbiAqICAgcGVyZm9ybWFuY2UgZm9yIHRoZSBjb21tb24gY2FzZSBvZiBzZWxlY3Rpbmcgbm9kZXMgaW4gZG9jdW1lbnQgb3JkZXIsXHJcbiAqICAgdGhhbmtzIHRvIFPplo5hc3RpZW4gQ3JhbWF0dGUgPGNvbnRhY3QgKGF0KSB6ZW5pbnRlcmFjdGlmLmNvbT4uXHJcbiAqICAgQVZMIHRyZWUgY29kZSBhZGFwdGVkIGZyb20gUmFpbXVuZCBOZXVtYW5uIDxybm92YSAoYXQpIGdteC5uZXQ+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAxODogT2N0b2JlciAyNywgMjAwNVxyXG4gKiAgIERPTSAzIFhQYXRoIHN1cHBvcnQuICBDYXZlYXRzOlxyXG4gKiAgICAgLSBuYW1lc3BhY2UgcHJlZml4ZXMgYXJlbid0IHJlc29sdmVkIGluIFhQYXRoRXZhbHVhdG9yLmNyZWF0ZUV4cHJlc3Npb24sXHJcbiAqICAgICAgIGJ1dCBpbiBYUGF0aEV4cHJlc3Npb24uZXZhbHVhdGUuXHJcbiAqICAgICAtIFhQYXRoUmVzdWx0LmludmFsaWRJdGVyYXRvclN0YXRlIGlzIG5vdCBpbXBsZW1lbnRlZC5cclxuICpcclxuICogUmV2aXNpb24gMTc6IE9jdG9iZXIgMjUsIDIwMDVcclxuICogICBTb21lIGNvcmUgWFBhdGggZnVuY3Rpb24gZml4ZXMgYW5kIGEgcGF0Y2ggdG8gYXZvaWQgY3Jhc2hpbmcgY2VydGFpblxyXG4gKiAgIHZlcnNpb25zIG9mIE1TWE1MIGluIFBhdGhFeHByLnByb3RvdHlwZS5nZXRPd25lckVsZW1lbnQsIHRoYW5rcyB0b1xyXG4gKiAgIFPplo5hc3RpZW4gQ3JhbWF0dGUgPGNvbnRhY3QgKGF0KSB6ZW5pbnRlcmFjdGlmLmNvbT4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE2OiBTZXB0ZW1iZXIgMjIsIDIwMDVcclxuICogICBXb3JrYXJvdW5kcyBmb3Igc29tZSBJRSA1LjUgZGVmaWNpZW5jaWVzLlxyXG4gKiAgIEZpeGVkIHByb2JsZW0gd2l0aCBwcmVmaXggbm9kZSB0ZXN0cyBvbiBhdHRyaWJ1dGUgbm9kZXMuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE1OiBNYXkgMjEsIDIwMDVcclxuICogICBGaXhlZCBwcm9ibGVtIHdpdGggUU5hbWUgbm9kZSB0ZXN0cyBvbiBlbGVtZW50cyB3aXRoIGFuIHhtbG5zPVwiLi4uXCIuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE0OiBNYXkgMTksIDIwMDVcclxuICogICBGaXhlZCBRTmFtZSBub2RlIHRlc3RzIG9uIGF0dHJpYnV0ZSBub2RlIHJlZ3Jlc3Npb24uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDEzOiBNYXkgMywgMjAwNVxyXG4gKiAgIE5vZGUgdGVzdHMgYXJlIGNhc2UgaW5zZW5zaXRpdmUgbm93IGlmIHdvcmtpbmcgaW4gYW4gSFRNTCBET00uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDEyOiBBcHJpbCAyNiwgMjAwNVxyXG4gKiAgIFVwZGF0ZWQgbGljZW5jZS4gIFNsaWdodCBjb2RlIGNoYW5nZXMgdG8gZW5hYmxlIHVzZSBvZiBEZWFuXHJcbiAqICAgRWR3YXJkcycgc2NyaXB0IGNvbXByZXNzaW9uLCBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvcGFja2VyLyAuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDExOiBBcHJpbCAyMywgMjAwNVxyXG4gKiAgIEZpeGVkIGJ1ZyB3aXRoICdhbmQnIGFuZCAnb3InIG9wZXJhdG9ycywgZml4IHRoYW5rcyB0b1xyXG4gKiAgIFNhbmR5IE1jQXJ0aHVyIDxzYW5keSAoYXQpIG1jYXJ0aHVyLm9yZz4uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDEwOiBBcHJpbCAxNSwgMjAwNVxyXG4gKiAgIEFkZGVkIHN1cHBvcnQgZm9yIGEgdmlydHVhbCByb290IG5vZGUsIHN1cHBvc2VkbHkgaGVscGZ1bCBmb3JcclxuICogICBpbXBsZW1lbnRpbmcgWEZvcm1zLiAgRml4ZWQgcHJvYmxlbSB3aXRoIFFOYW1lIG5vZGUgdGVzdHMgYW5kXHJcbiAqICAgdGhlIHBhcmVudCBheGlzLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiA5OiBNYXJjaCAxNywgMjAwNVxyXG4gKiAgIE5hbWVzcGFjZSByZXNvbHZlciB0d2Vha2VkIHNvIHVzaW5nIHRoZSBkb2N1bWVudCBub2RlIGFzIHRoZSBjb250ZXh0XHJcbiAqICAgZm9yIG5hbWVzcGFjZSBsb29rdXBzIGlzIGVxdWl2YWxlbnQgdG8gdXNpbmcgdGhlIGRvY3VtZW50IGVsZW1lbnQuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDg6IEZlYnJ1YXJ5IDEzLCAyMDA1XHJcbiAqICAgSGFuZGxlIGltcGxpY2l0IGRlY2xhcmF0aW9uIG9mICd4bWxucycgbmFtZXNwYWNlIHByZWZpeC5cclxuICogICBGaXhlZCBidWcgd2hlbiBjb21wYXJpbmcgbm9kZXNldHMuXHJcbiAqICAgSW5zdGFuY2UgZGF0YSBjYW4gbm93IGJlIGFzc29jaWF0ZWQgd2l0aCBhIEZ1bmN0aW9uUmVzb2x2ZXIsIGFuZFxyXG4gKiAgICAgd29ya2Fyb3VuZCBmb3IgTVNYTUwgbm90IHN1cHBvcnRpbmcgJ2xvY2FsTmFtZScgYW5kICdnZXRFbGVtZW50QnlJZCcsXHJcbiAqICAgICB0aGFua3MgdG8gR3JhbnQgR29uZ2F3YXJlLlxyXG4gKiAgIEZpeCBhIGZldyBwcm9ibGVtcyB3aGVuIHRoZSBjb250ZXh0IG5vZGUgaXMgdGhlIHJvb3Qgbm9kZS5cclxuICpcclxuICogUmV2aXNpb24gNzogRmVicnVhcnkgMTEsIDIwMDVcclxuICogICBEZWZhdWx0IG5hbWVzcGFjZSByZXNvbHZlciBmaXggZnJvbSBHcmFudCBHb25nYXdhcmVcclxuICogICA8Z3JhbnQgKGF0KSBnb25nYXdhcmUuY29tPi5cclxuICpcclxuICogUmV2aXNpb24gNjogRmVicnVhcnkgMTAsIDIwMDVcclxuICogICBGaXhlZCBidWcgaW4gJ251bWJlcicgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFJldmlzaW9uIDU6IEZlYnJ1YXJ5IDksIDIwMDVcclxuICogICBGaXhlZCBidWcgd2hlcmUgdGV4dCBub2RlcyBub3QgZ2V0dGluZyBjb252ZXJ0ZWQgdG8gc3RyaW5nIHZhbHVlcy5cclxuICpcclxuICogUmV2aXNpb24gNDogSmFudWFyeSAyMSwgMjAwNVxyXG4gKiAgIEJ1ZyBpbiAnbmFtZScgZnVuY3Rpb24sIGZpeCB0aGFua3MgdG8gQmlsbCBFZG5leS5cclxuICogICBGaXhlZCBpbmNvcnJlY3QgcHJvY2Vzc2luZyBvZiBuYW1lc3BhY2Ugbm9kZXMuXHJcbiAqICAgRml4ZWQgTmFtZXNwYWNlUmVzb2x2ZXIgdG8gcmVzb2x2ZSAneG1sJyBuYW1lc3BhY2UuXHJcbiAqICAgSW1wbGVtZW50ZWQgdW5pb24gJ3wnIG9wZXJhdG9yLlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAzOiBKYW51YXJ5IDE0LCAyMDA1XHJcbiAqICAgRml4ZWQgYnVnIHdpdGggbm9kZXNldCBjb21wYXJpc29ucywgYnVnIGxleGluZyA8IGFuZCA+LlxyXG4gKlxyXG4gKiBSZXZpc2lvbiAyOiBPY3RvYmVyIDI2LCAyMDA0XHJcbiAqICAgUU5hbWUgbm9kZSB0ZXN0IG5hbWVzcGFjZSBoYW5kbGluZyBmaXhlZC4gIEZldyBvdGhlciBidWcgZml4ZXMuXHJcbiAqXHJcbiAqIFJldmlzaW9uIDE6IEF1Z3VzdCAxMywgMjAwNFxyXG4gKiAgIEJ1ZyBmaXhlcyBmcm9tIFdpbGxpYW0gSi4gRWRuZXkgPGJlZG5leSAoYXQpIHRlY2huaWNhbHB1cnN1aXQuY29tPi5cclxuICogICBBZGRlZCBtaW5pbWFsIGxpY2VuY2UuXHJcbiAqXHJcbiAqIEluaXRpYWwgdmVyc2lvbjogSnVuZSAxNCwgMjAwNFxyXG4gKi9cclxuXHJcbi8vIG5vbi1ub2RlIHdyYXBwZXJcclxuaWYodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnICkge1xyXG5cdHhwYXRoID0ge307XHJcbn1cclxuKGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuXHRcclxuLy8gWFBhdGhQYXJzZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblhQYXRoUGFyc2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoUGFyc2VyO1xyXG5YUGF0aFBhcnNlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoUGFyc2VyKCkge1xyXG5cdHRoaXMuaW5pdCgpO1xyXG59XHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMucmVkdWNlQWN0aW9ucyA9IFtdO1xyXG5cclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbM10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgT3JPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzVdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEFuZE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbN10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgRXF1YWxzT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBOb3RFcXVhbE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IExlc3NUaGFuT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxMV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgR3JlYXRlclRoYW5PcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzEyXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzEzXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzE1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBQbHVzT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1sxNl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgTWludXNPcGVyYXRpb24ocmhzWzBdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzE4XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBNdWx0aXBseU9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMTldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IERpdk9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE1vZE9wZXJhdGlvbihyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjJdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFVuYXJ5TWludXNPcGVyYXRpb24ocmhzWzFdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syNF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgQmFyT3BlcmF0aW9uKHJoc1swXSwgcmhzWzJdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syNV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgUGF0aEV4cHIodW5kZWZpbmVkLCB1bmRlZmluZWQsIHJoc1swXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMF0ubG9jYXRpb25QYXRoID0gcmhzWzJdO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1syOF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1swXS5sb2NhdGlvblBhdGggPSByaHNbMl07XHJcblx0XHRyaHNbMF0ubG9jYXRpb25QYXRoLnN0ZXBzLnVuc2hpZnQobmV3IFN0ZXAoU3RlcC5ERVNDRU5EQU5UT1JTRUxGLCBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKSwgW10pKTtcclxuXHRcdHJldHVybiByaHNbMF07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMjldID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBhdGhFeHByKHJoc1swXSwgW10sIHVuZGVmaW5lZCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHJoc1swXSwgUGF0aEV4cHIpKSB7XHJcblx0XHRcdGlmIChyaHNbMF0uZmlsdGVyUHJlZGljYXRlcyA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyaHNbMF0uZmlsdGVyUHJlZGljYXRlcyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJoc1swXS5maWx0ZXJQcmVkaWNhdGVzLnB1c2gocmhzWzFdKTtcclxuXHRcdFx0cmV0dXJuIHJoc1swXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBuZXcgUGF0aEV4cHIocmhzWzBdLCBbcmhzWzFdXSwgdW5kZWZpbmVkKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szMl0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzNdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcocmhzWzBdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szNF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgWE51bWJlcihyaHNbMF0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzM2XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwocmhzWzBdLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChyaHNbMF0sIHJoc1syXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbMzhdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gWyByaHNbMF0gXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1szOV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1syXS51bnNoaWZ0KHJoc1swXSk7XHJcblx0XHRyZXR1cm4gcmhzWzJdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQzXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBMb2NhdGlvblBhdGgodHJ1ZSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzQ0XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzFdLmFic29sdXRlID0gdHJ1ZTtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IExvY2F0aW9uUGF0aChmYWxzZSwgWyByaHNbMF0gXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNDddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyaHNbMF0uc3RlcHMucHVzaChyaHNbMl0pO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s0OV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChyaHNbMF0sIHJoc1sxXSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzUwXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKFN0ZXAuQ0hJTEQsIHJoc1swXSwgW10pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzUxXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKHJoc1swXSwgcmhzWzFdLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzUyXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGVwKFN0ZXAuQ0hJTEQsIHJoc1swXSwgcmhzWzFdKTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1NF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBbIHJoc1swXSBdO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzU1XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmhzWzFdLnVuc2hpZnQocmhzWzBdKTtcclxuXHRcdHJldHVybiByaHNbMV07XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNTZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRpZiAocmhzWzBdID09IFwiYW5jZXN0b3JcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5BTkNFU1RPUjtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwiYW5jZXN0b3Itb3Itc2VsZlwiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLkFOQ0VTVE9ST1JTRUxGO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJhdHRyaWJ1dGVcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5BVFRSSUJVVEU7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImNoaWxkXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuQ0hJTEQ7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImRlc2NlbmRhbnRcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5ERVNDRU5EQU5UO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJkZXNjZW5kYW50LW9yLXNlbGZcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5ERVNDRU5EQU5UT1JTRUxGO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJmb2xsb3dpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5GT0xMT1dJTkc7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcImZvbGxvd2luZy1zaWJsaW5nXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuRk9MTE9XSU5HU0lCTElORztcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwibmFtZXNwYWNlXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuTkFNRVNQQUNFO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJwYXJlbnRcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5QQVJFTlQ7XHJcblx0XHR9IGVsc2UgaWYgKHJoc1swXSA9PSBcInByZWNlZGluZ1wiKSB7XHJcblx0XHRcdHJldHVybiBTdGVwLlBSRUNFRElORztcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwicHJlY2VkaW5nLXNpYmxpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gU3RlcC5QUkVDRURJTkdTSUJMSU5HO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJzZWxmXCIpIHtcclxuXHRcdFx0cmV0dXJuIFN0ZXAuU0VMRjtcclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1N10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBTdGVwLkFUVFJJQlVURTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s1OV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdGlmIChyaHNbMF0gPT0gXCJjb21tZW50XCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5DT01NRU5ULCB1bmRlZmluZWQpO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJ0ZXh0XCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5URVhULCB1bmRlZmluZWQpO1xyXG5cdFx0fSBlbHNlIGlmIChyaHNbMF0gPT0gXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5QSSwgdW5kZWZpbmVkKTtcclxuXHRcdH0gZWxzZSBpZiAocmhzWzBdID09IFwibm9kZVwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTk9ERSwgdW5kZWZpbmVkKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoLTEsIHVuZGVmaW5lZCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0LlBJLCByaHNbMl0pO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzYxXSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2M10gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1sxXS5hYnNvbHV0ZSA9IHRydWU7XHJcblx0XHRyaHNbMV0uc3RlcHMudW5zaGlmdChuZXcgU3RlcChTdGVwLkRFU0NFTkRBTlRPUlNFTEYsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSkpO1xyXG5cdFx0cmV0dXJuIHJoc1sxXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2NF0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJoc1swXS5zdGVwcy5wdXNoKG5ldyBTdGVwKFN0ZXAuREVTQ0VOREFOVE9SU0VMRiwgbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5PREUsIHVuZGVmaW5lZCksIFtdKSk7XHJcblx0XHRyaHNbMF0uc3RlcHMucHVzaChyaHNbMl0pO1xyXG5cdFx0cmV0dXJuIHJoc1swXTtcclxuXHR9O1xyXG5cdHRoaXMucmVkdWNlQWN0aW9uc1s2NV0gPSBmdW5jdGlvbihyaHMpIHtcclxuXHRcdHJldHVybiBuZXcgU3RlcChTdGVwLlNFTEYsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjZdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0ZXAoU3RlcC5QQVJFTlQsIG5ldyBOb2RlVGVzdChOb2RlVGVzdC5OT0RFLCB1bmRlZmluZWQpLCBbXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjddID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZhcmlhYmxlUmVmZXJlbmNlKHJoc1sxXSk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNjhdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5BTUVURVNUQU5ZLCB1bmRlZmluZWQpO1xyXG5cdH07XHJcblx0dGhpcy5yZWR1Y2VBY3Rpb25zWzY5XSA9IGZ1bmN0aW9uKHJocykge1xyXG5cdFx0dmFyIHByZWZpeCA9IHJoc1swXS5zdWJzdHJpbmcoMCwgcmhzWzBdLmluZGV4T2YoXCI6XCIpKTtcclxuXHRcdHJldHVybiBuZXcgTm9kZVRlc3QoTm9kZVRlc3QuTkFNRVRFU1RQUkVGSVhBTlksIHByZWZpeCk7XHJcblx0fTtcclxuXHR0aGlzLnJlZHVjZUFjdGlvbnNbNzBdID0gZnVuY3Rpb24ocmhzKSB7XHJcblx0XHRyZXR1cm4gbmV3IE5vZGVUZXN0KE5vZGVUZXN0Lk5BTUVURVNUUU5BTUUsIHJoc1swXSk7XHJcblx0fTtcclxufTtcclxuXHJcblhQYXRoUGFyc2VyLmFjdGlvblRhYmxlID0gW1xyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgIHMgICAgICAgICAgICAgICAgICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIHJycnJyICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcInJzICBycnJycnJyciBzICBzc3Nzc3JycnJyciAgcnJzIHJzIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICAgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJyICAgICAgIHMgICAgICAgICAgICAgICAgICAgIHJyICByICBcIixcclxuXHRcInIgICAgICBzciAgICAgICAgICAgICAgICAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHMgIHJyICAgICAgICAgICAgcyAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnNzcnIgICAgICAgICAgICByc3MgICAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyc3NzICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJycyAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnJyICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgc3IgIFwiLFxyXG5cdFwiciAgc3JycnJycnJyICAgICAgICAgcnJycnJycyByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyciAgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBzc3NzcyAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciBzciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciByciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCIgICAgICAgICAgICAgIHMgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgIHJycnJyICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzc3MgcyAgc3NcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgcyBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCIgcyBzICAgICAgICBzc3Nzc3Nzc3MgICAgICBzcyAgcyAgc3NcIixcclxuXHRcIiBzIHMgICAgICAgIHNzc3Nzc3NzcyAgICBzIHNzICBzICBzc1wiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiIHMgICAgICAgICAgIHMgIHNzc3NzICAgICAgICAgIHMgIHMgXCIsXHJcblx0XCIgcyAgICAgICAgICAgcyAgc3Nzc3MgICAgICAgICAgcyAgcyBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgc3IgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciBzciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICAgICAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICByciAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnMgICAgIFwiLFxyXG5cdFwiciAgICAgIHNyICAgICAgICAgICAgICAgICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcyAgcnIgICAgICAgICAgICBzICAgICAgIHJyICByICBcIixcclxuXHRcInIgICByc3NyciAgICAgICAgICAgIHJzcyAgICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJzc3JyICAgICAgICAgICAgcnNzICAgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJyciAgICAgICAgICAgIHJycnNzICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyICAgICAgICAgICAgcnJyc3MgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnIgICAgICAgICAgICBycnJzcyAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnNzcyAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJyc3NzICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJyciAgIHJyICByICBcIixcclxuXHRcInIgICBycnJycnJyciAgICAgICAgIHJycnJyICAgcnIgIHIgIFwiLFxyXG5cdFwiciAgIHJycnJycnJyICAgICAgICAgcnJycnIgICByciAgciAgXCIsXHJcblx0XCJyICAgcnJycnJycnIgICAgICAgICBycnJycnIgIHJyICByICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAgXCIsXHJcblx0XCJyICBzcnJycnJycnIgICAgICAgICBycnJycnJzIHJyICByICBcIixcclxuXHRcInIgIHNycnJycnJyciAgICAgICAgIHJycnJycnMgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyICByICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgIHIgIFwiLFxyXG5cdFwiciAgcnJycnJycnJyICAgICAgICAgcnJycnJyciByciAgciAgXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcInIgIHJycnJycnJyciAgICAgICAgIHJycnJycnIgcnIgcnIgIFwiLFxyXG5cdFwiIHMgcyAgICAgICAgc3Nzc3Nzc3NzICAgIHMgc3MgIHMgIHNzXCIsXHJcblx0XCJyICBycnJycnJycnIgICAgICAgICBycnJycnJyIHJyIHJyICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciAgICAgIFwiXHJcbl07XHJcblxyXG5YUGF0aFBhcnNlci5hY3Rpb25UYWJsZU51bWJlciA9IFtcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICBKICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJhICBhYWFhYWFhYWEgICAgICAgICBhYWFhYWFhIGFhICBhICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBZWVlZWSAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCJLMSAgS0tLS0tLS0sgLiAgKyopKCdLS0tLS0sgIEtLIyBLXFxcIiBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIE4gICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyAgICAgICBcIixcclxuXHRcImUgIGVlZWVlZWVlZSAgICAgICAgIGVlZWVlZWUgZWUgZWUgIFwiLFxyXG5cdFwiZiAgZmZmZmZmZmZmICAgICAgICAgZmZmZmZmZiBmZiBmZiAgXCIsXHJcblx0XCJkICBkZGRkZGRkZGQgICAgICAgICBkZGRkZGRkIGRkIGRkICBcIixcclxuXHRcIkIgIEJCQkJCQkJCQiAgICAgICAgIEJCQkJCQkIgQkIgQkIgIFwiLFxyXG5cdFwiQSAgQUFBQUFBQUFBICAgICAgICAgQUFBQUFBQSBBQSBBQSAgXCIsXHJcblx0XCIgIFAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBRICAgICAgIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCJiICBiYmJiYmJiYmIgICAgICAgICBiYmJiYmJiIGJiICBiICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiISAgICAgICBTICAgICAgICAgICAgICAgICAgICAhISAgISAgXCIsXHJcblx0XCJcXFwiICAgICAgVFxcXCIgICAgICAgICAgICAgICAgICAgIFxcXCJcXFwiICBcXFwiICBcIixcclxuXHRcIiQgICBWICAkJCAgICAgICAgICAgIFUgICAgICAgJCQgICQgIFwiLFxyXG5cdFwiJiAgICZaWSYmICAgICAgICAgICAgJlhXICAgICAmJiAgJiAgXCIsXHJcblx0XCIpICAgKSkpKSkgICAgICAgICAgICApKSlcXFxcWyAgICkpICApICBcIixcclxuXHRcIi4gICAuLi4uLl9eXSAgICAgICAgIC4uLi4uICAgLi4gIC4gIFwiLFxyXG5cdFwiMSAgIDExMTExMTExICAgICAgICAgMTExMTEgICAxMSAgMSAgXCIsXHJcblx0XCI1ICAgNTU1NTU1NTUgICAgICAgICA1NTU1NWAgIDU1ICA1ICBcIixcclxuXHRcIjcgICA3Nzc3Nzc3NyAgICAgICAgIDc3Nzc3NyAgNzcgIDcgIFwiLFxyXG5cdFwiOSAgIDk5OTk5OTk5ICAgICAgICAgOTk5OTk5ICA5OSAgOSAgXCIsXHJcblx0XCI6ICBjOjo6Ojo6OjogICAgICAgICA6Ojo6OjpiIDo6IGE6ICBcIixcclxuXHRcIkkgIGZJSUlJSUlJSSAgICAgICAgIElJSUlJSWUgSUkgIEkgIFwiLFxyXG5cdFwiPSAgPT09PT09PT09ICAgICAgICAgPT09PT09PSA9PSA9PSAgXCIsXHJcblx0XCI/ICA/Pz8/Pz8/Pz8gICAgICAgICA/Pz8/Pz8/ID8/ID8/ICBcIixcclxuXHRcIkMgIENDQ0NDQ0NDQyAgICAgICAgIENDQ0NDQ0MgQ0MgQ0MgIFwiLFxyXG5cdFwiSiAgIEpKSkpKSkpKICAgICAgICAgSkpKSkpKICBKSiAgSiAgXCIsXHJcblx0XCJNICAgTU1NTU1NTU0gICAgICAgICBNTU1NTU0gIE1NICBNICBcIixcclxuXHRcIk4gIE5OTk5OTk5OTiAgICAgICAgIE5OTk5OTk4gTk4gIE4gIFwiLFxyXG5cdFwiUCAgUFBQUFBQUFBQICAgICAgICAgUFBQUFBQUCBQUCAgUCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgKyopKCcgICAgICAgICAgICAgICBcIixcclxuXHRcIlIgIFJSUlJSUlJSUiAgICAgICAgIFJSUlJSUlIgUlIgYVIgIFwiLFxyXG5cdFwiVSAgVVVVVVVVVVVVICAgICAgICAgVVVVVVVVVSBVVSAgVSAgXCIsXHJcblx0XCJaICBaWlpaWlpaWlogICAgICAgICBaWlpaWlpaIFpaIFpaICBcIixcclxuXHRcImMgIGNjY2NjY2NjYyAgICAgICAgIGNjY2NjY2MgY2MgY2MgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqICAgICAgXCIsXHJcblx0XCJMICBmTExMTExMTEwgICAgICAgICBMTExMTExlIExMICBMICBcIixcclxuXHRcIjYgICA2NjY2NjY2NiAgICAgICAgIDY2NjY2ICAgNjYgIDYgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBrICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICBYWFhYWCAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSRtICMgIFxcXCIhXCIsXHJcblx0XCJfICBmX19fX19fX18gICAgICAgICBfX19fX19lIF9fICBfICBcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICYgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxIDAgICAgICAgIC8uLSwrKikoJyAgICAmICUkICAjICBcXFwiIVwiLFxyXG5cdFwiIDEgMCAgICAgICAgLy4tLCsqKSgnICAgICAgJSQgICMgIFxcXCIhXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCI+ICA+Pj4+Pj4+Pj4gICAgICAgICA+Pj4+Pj4+ID4+ID4+ICBcIixcclxuXHRcIiAxICAgICAgICAgICAuICArKikoJyAgICAgICAgICAjICBcXFwiIFwiLFxyXG5cdFwiIDEgICAgICAgICAgIC4gICsqKSgnICAgICAgICAgICMgIFxcXCIgXCIsXHJcblx0XCJRICBRUVFRUVFRUVEgICAgICAgICBRUVFRUVFRIFFRIGFRICBcIixcclxuXHRcIlYgIFZWVlZWVlZWViAgICAgICAgIFZWVlZWVlYgVlYgYVYgIFwiLFxyXG5cdFwiVCAgVFRUVFRUVFRUICAgICAgICAgVFRUVFRUVCBUVCAgVCAgXCIsXHJcblx0XCJAICBAQEBAQEBAQEAgICAgICAgICBAQEBAQEBAIEBAIEBAICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx4ODcgICAgICBcIixcclxuXHRcIlsgIFtbW1tbW1tbWyAgICAgICAgIFtbW1tbW1sgW1sgW1sgIFwiLFxyXG5cdFwiRCAgREREREREREREICAgICAgICAgRERERERERCBERCBERCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhIICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFx4ODggICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlxceDg5ICAgICBcIixcclxuXHRcIiMgICAgICBUIyAgICAgICAgICAgICAgICAgICAgIyMgICMgIFwiLFxyXG5cdFwiJSAgIFYgICUlICAgICAgICAgICAgVSAgICAgICAlJSAgJSAgXCIsXHJcblx0XCInICAgJ1pZJycgICAgICAgICAgICAnWFcgICAgICcnICAnICBcIixcclxuXHRcIiggICAoWlkoKCAgICAgICAgICAgIChYVyAgICAgKCggICggIFwiLFxyXG5cdFwiKyAgICsrKysrICAgICAgICAgICAgKysrXFxcXFsgICArKyAgKyAgXCIsXHJcblx0XCIqICAgKioqKiogICAgICAgICAgICAqKipcXFxcWyAgICoqICAqICBcIixcclxuXHRcIi0gICAtLS0tLSAgICAgICAgICAgIC0tLVxcXFxbICAgLS0gIC0gIFwiLFxyXG5cdFwiLCAgICwsLCwsICAgICAgICAgICAgLCwsXFxcXFsgICAsLCAgLCAgXCIsXHJcblx0XCIwICAgMDAwMDBfXl0gICAgICAgICAwMDAwMCAgIDAwICAwICBcIixcclxuXHRcIi8gICAvLy8vL19eXSAgICAgICAgIC8vLy8vICAgLy8gIC8gIFwiLFxyXG5cdFwiMiAgIDIyMjIyMjIyICAgICAgICAgMjIyMjIgICAyMiAgMiAgXCIsXHJcblx0XCIzICAgMzMzMzMzMzMgICAgICAgICAzMzMzMyAgIDMzICAzICBcIixcclxuXHRcIjQgICA0NDQ0NDQ0NCAgICAgICAgIDQ0NDQ0ICAgNDQgIDQgIFwiLFxyXG5cdFwiOCAgIDg4ODg4ODg4ICAgICAgICAgODg4ODg4ICA4OCAgOCAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxceDhhICBcIixcclxuXHRcIjsgIGY7Ozs7Ozs7OyAgICAgICAgIDs7Ozs7O2UgOzsgIDsgIFwiLFxyXG5cdFwiPCAgZjw8PDw8PDw8ICAgICAgICAgPDw8PDw8ZSA8PCAgPCAgXCIsXHJcblx0XCJPICBPT09PT09PT08gICAgICAgICBPT09PT09PIE9PICBPICBcIixcclxuXHRcImAgIGBgYGBgYGBgYCAgICAgICAgIGBgYGBgYGAgYGAgIGAgIFwiLFxyXG5cdFwiUyAgU1NTU1NTU1NTICAgICAgICAgU1NTU1NTUyBTUyAgUyAgXCIsXHJcblx0XCJXICBXV1dXV1dXV1cgICAgICAgICBXV1dXV1dXIFdXICBXICBcIixcclxuXHRcIlxcXFwgIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAgICAgICAgIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgXFxcXFxcXFwgXFxcXFxcXFwgIFwiLFxyXG5cdFwiRSAgRUVFRUVFRUVFICAgICAgICAgRUVFRUVFRSBFRSBFRSAgXCIsXHJcblx0XCIgMSAwICAgICAgICAvLi0sKyopKCcgICAgJiAlJCAgIyAgXFxcIiFcIixcclxuXHRcIl0gIF1dXV1dXV1dXSAgICAgICAgIF1dXV1dXV0gXV0gXV0gIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHICAgICAgXCJcclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLmdvdG9UYWJsZSA9IFtcclxuXHRcIjM0NTY3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJMNDU2Nzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgTSAgICAgICAgRUZHSCBJSiBcIixcclxuXHRcIiAgICAgICBOOzw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICBTICAgICAgICBFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBlICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgaCAgSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgaSAgICAgICAgICBqICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCJvNDU2Nzg5Ojs8PT4/QCBBQnBxQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgcjY3ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICBzNzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgIHQ4OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICB1ODk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgIHY5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICB3OTo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgeDk6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgIHk5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgejo7PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgIHs6Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgfDs8PT4/QCBBQiAgQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgIH07PD0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIiAgICAgICB+Ozw9Pj9AIEFCICBDREVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICBcXHg3Zj0+P0AgQUIgIENERUZHSCBJSiBcIixcclxuXHRcIlxceDgwNDU2Nzg5Ojs8PT4/QCBBQiAgQ0RFRkdIIElKXFx4ODFcIixcclxuXHRcIiAgICAgICAgICAgIFxceDgyICAgICAgICBFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgXFx4ODMgICAgICAgIEVGR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgXFx4ODQgR0ggSUogXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICBcXHg4NSBHSCBJSiBcIixcclxuXHRcIiAgICAgICAgICAgICAgaSAgICAgICAgICBcXHg4NiAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICBpICAgICAgICAgIFxceDg3ICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXHJcblx0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIm80NTY3ODk6Ozw9Pj9AIEFCXFx4OGNxQ0RFRkdIIElKIFwiLFxyXG5cdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcclxuXHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zID0gW1xyXG5cdFsxLCAxLCAyXSxcclxuXHRbMiwgMSwgM10sXHJcblx0WzMsIDEsIDRdLFxyXG5cdFszLCAzLCAzLCAtOSwgNF0sXHJcblx0WzQsIDEsIDVdLFxyXG5cdFs0LCAzLCA0LCAtOCwgNV0sXHJcblx0WzUsIDEsIDZdLFxyXG5cdFs1LCAzLCA1LCAtMjIsIDZdLFxyXG5cdFs1LCAzLCA1LCAtNSwgNl0sXHJcblx0WzYsIDEsIDddLFxyXG5cdFs2LCAzLCA2LCAtMjMsIDddLFxyXG5cdFs2LCAzLCA2LCAtMjQsIDddLFxyXG5cdFs2LCAzLCA2LCAtNiwgN10sXHJcblx0WzYsIDMsIDYsIC03LCA3XSxcclxuXHRbNywgMSwgOF0sXHJcblx0WzcsIDMsIDcsIC0yNSwgOF0sXHJcblx0WzcsIDMsIDcsIC0yNiwgOF0sXHJcblx0WzgsIDEsIDldLFxyXG5cdFs4LCAzLCA4LCAtMTIsIDldLFxyXG5cdFs4LCAzLCA4LCAtMTEsIDldLFxyXG5cdFs4LCAzLCA4LCAtMTAsIDldLFxyXG5cdFs5LCAxLCAxMF0sXHJcblx0WzksIDIsIC0yNiwgOV0sXHJcblx0WzEwLCAxLCAxMV0sXHJcblx0WzEwLCAzLCAxMCwgLTI3LCAxMV0sXHJcblx0WzExLCAxLCAxMl0sXHJcblx0WzExLCAxLCAxM10sXHJcblx0WzExLCAzLCAxMywgLTI4LCAxNF0sXHJcblx0WzExLCAzLCAxMywgLTQsIDE0XSxcclxuXHRbMTMsIDEsIDE1XSxcclxuXHRbMTMsIDIsIDEzLCAxNl0sXHJcblx0WzE1LCAxLCAxN10sXHJcblx0WzE1LCAzLCAtMjksIDIsIC0zMF0sXHJcblx0WzE1LCAxLCAtMTVdLFxyXG5cdFsxNSwgMSwgLTE2XSxcclxuXHRbMTUsIDEsIDE4XSxcclxuXHRbMTgsIDMsIC0xMywgLTI5LCAtMzBdLFxyXG5cdFsxOCwgNCwgLTEzLCAtMjksIDE5LCAtMzBdLFxyXG5cdFsxOSwgMSwgMjBdLFxyXG5cdFsxOSwgMywgMjAsIC0zMSwgMTldLFxyXG5cdFsyMCwgMSwgMl0sXHJcblx0WzEyLCAxLCAxNF0sXHJcblx0WzEyLCAxLCAyMV0sXHJcblx0WzIxLCAxLCAtMjhdLFxyXG5cdFsyMSwgMiwgLTI4LCAxNF0sXHJcblx0WzIxLCAxLCAyMl0sXHJcblx0WzE0LCAxLCAyM10sXHJcblx0WzE0LCAzLCAxNCwgLTI4LCAyM10sXHJcblx0WzE0LCAxLCAyNF0sXHJcblx0WzIzLCAyLCAyNSwgMjZdLFxyXG5cdFsyMywgMSwgMjZdLFxyXG5cdFsyMywgMywgMjUsIDI2LCAyN10sXHJcblx0WzIzLCAyLCAyNiwgMjddLFxyXG5cdFsyMywgMSwgMjhdLFxyXG5cdFsyNywgMSwgMTZdLFxyXG5cdFsyNywgMiwgMTYsIDI3XSxcclxuXHRbMjUsIDIsIC0xNCwgLTNdLFxyXG5cdFsyNSwgMSwgLTMyXSxcclxuXHRbMjYsIDEsIDI5XSxcclxuXHRbMjYsIDMsIC0yMCwgLTI5LCAtMzBdLFxyXG5cdFsyNiwgNCwgLTIxLCAtMjksIC0xNSwgLTMwXSxcclxuXHRbMTYsIDMsIC0zMywgMzAsIC0zNF0sXHJcblx0WzMwLCAxLCAyXSxcclxuXHRbMjIsIDIsIC00LCAxNF0sXHJcblx0WzI0LCAzLCAxNCwgLTQsIDIzXSxcclxuXHRbMjgsIDEsIC0zNV0sXHJcblx0WzI4LCAxLCAtMl0sXHJcblx0WzE3LCAyLCAtMzYsIC0xOF0sXHJcblx0WzI5LCAxLCAtMTddLFxyXG5cdFsyOSwgMSwgLTE5XSxcclxuXHRbMjksIDEsIC0xOF1cclxuXTtcclxuXHJcblhQYXRoUGFyc2VyLkRPVUJMRURPVCA9IDI7XHJcblhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OID0gMztcclxuWFBhdGhQYXJzZXIuRE9VQkxFU0xBU0ggPSA0O1xyXG5YUGF0aFBhcnNlci5OT1RFUVVBTCA9IDU7XHJcblhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTCA9IDY7XHJcblhQYXRoUGFyc2VyLkdSRUFURVJUSEFOT1JFUVVBTCA9IDc7XHJcblhQYXRoUGFyc2VyLkFORCA9IDg7XHJcblhQYXRoUGFyc2VyLk9SID0gOTtcclxuWFBhdGhQYXJzZXIuTU9EID0gMTA7XHJcblhQYXRoUGFyc2VyLkRJViA9IDExO1xyXG5YUGF0aFBhcnNlci5NVUxUSVBMWU9QRVJBVE9SID0gMTI7XHJcblhQYXRoUGFyc2VyLkZVTkNUSU9OTkFNRSA9IDEzO1xyXG5YUGF0aFBhcnNlci5BWElTTkFNRSA9IDE0O1xyXG5YUGF0aFBhcnNlci5MSVRFUkFMID0gMTU7XHJcblhQYXRoUGFyc2VyLk5VTUJFUiA9IDE2O1xyXG5YUGF0aFBhcnNlci5BU1RFUklTS05BTUVURVNUID0gMTc7XHJcblhQYXRoUGFyc2VyLlFOQU1FID0gMTg7XHJcblhQYXRoUGFyc2VyLk5DTkFNRUNPTE9OQVNURVJJU0sgPSAxOTtcclxuWFBhdGhQYXJzZXIuTk9ERVRZUEUgPSAyMDtcclxuWFBhdGhQYXJzZXIuUFJPQ0VTU0lOR0lOU1RSVUNUSU9OV0lUSExJVEVSQUwgPSAyMTtcclxuWFBhdGhQYXJzZXIuRVFVQUxTID0gMjI7XHJcblhQYXRoUGFyc2VyLkxFU1NUSEFOID0gMjM7XHJcblhQYXRoUGFyc2VyLkdSRUFURVJUSEFOID0gMjQ7XHJcblhQYXRoUGFyc2VyLlBMVVMgPSAyNTtcclxuWFBhdGhQYXJzZXIuTUlOVVMgPSAyNjtcclxuWFBhdGhQYXJzZXIuQkFSID0gMjc7XHJcblhQYXRoUGFyc2VyLlNMQVNIID0gMjg7XHJcblhQYXRoUGFyc2VyLkxFRlRQQVJFTlRIRVNJUyA9IDI5O1xyXG5YUGF0aFBhcnNlci5SSUdIVFBBUkVOVEhFU0lTID0gMzA7XHJcblhQYXRoUGFyc2VyLkNPTU1BID0gMzE7XHJcblhQYXRoUGFyc2VyLkFUID0gMzI7XHJcblhQYXRoUGFyc2VyLkxFRlRCUkFDS0VUID0gMzM7XHJcblhQYXRoUGFyc2VyLlJJR0hUQlJBQ0tFVCA9IDM0O1xyXG5YUGF0aFBhcnNlci5ET1QgPSAzNTtcclxuWFBhdGhQYXJzZXIuRE9MTEFSID0gMzY7XHJcblxyXG5YUGF0aFBhcnNlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbihzMSkge1xyXG5cdHZhciB0eXBlcyA9IFtdO1xyXG5cdHZhciB2YWx1ZXMgPSBbXTtcclxuXHR2YXIgcyA9IHMxICsgJ1xcMCc7XHJcblxyXG5cdHZhciBwb3MgPSAwO1xyXG5cdHZhciBjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdHdoaWxlICgxKSB7XHJcblx0XHR3aGlsZSAoYyA9PSAnICcgfHwgYyA9PSAnXFx0JyB8fCBjID09ICdcXHInIHx8IGMgPT0gJ1xcbicpIHtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICdcXDAnIHx8IHBvcyA+PSBzLmxlbmd0aCkge1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnKCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MRUZUUEFSRU5USEVTSVMpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnKScpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5SSUdIVFBBUkVOVEhFU0lTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ1snKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVQpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnXScpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5SSUdIVEJSQUNLRVQpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaChjKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoYyA9PSAnQCcpIHtcclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5BVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICcsJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkNPTU1BKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJ3wnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQkFSKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJysnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuUExVUyk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmIChjID09ICctJykge1xyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk1JTlVTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJz0nKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRVFVQUxTKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGMgPT0gJyQnKSB7XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9MTEFSKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICcuJykge1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRpZiAoYyA9PSAnLicpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRPVUJMRURPVCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCIuLlwiKTtcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHRcdHZhciBudW1iZXIgPSBcIi5cIiArIGM7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHR3aGlsZSAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0XHRcdG51bWJlciArPSBjO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OVU1CRVIpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKG51bWJlcik7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET1QpO1xyXG5cdFx0XHR2YWx1ZXMucHVzaCgnLicpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnXFwnJyB8fCBjID09ICdcIicpIHtcclxuXHRcdFx0dmFyIGRlbGltaXRlciA9IGM7XHJcblx0XHRcdHZhciBsaXRlcmFsID0gXCJcIjtcclxuXHRcdFx0d2hpbGUgKChjID0gcy5jaGFyQXQocG9zKyspKSAhPSBkZWxpbWl0ZXIpIHtcclxuXHRcdFx0XHRsaXRlcmFsICs9IGM7XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5MSVRFUkFMKTtcclxuXHRcdFx0dmFsdWVzLnB1c2gobGl0ZXJhbCk7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xyXG5cdFx0XHR2YXIgbnVtYmVyID0gYztcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0d2hpbGUgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XHJcblx0XHRcdFx0bnVtYmVyICs9IGM7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYyA9PSAnLicpIHtcclxuXHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA+PSAnMCcgJiYgcy5jaGFyQXQocG9zKSA8PSAnOScpIHtcclxuXHRcdFx0XHRcdG51bWJlciArPSBjO1xyXG5cdFx0XHRcdFx0bnVtYmVyICs9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHR3aGlsZSAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcclxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGM7XHJcblx0XHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTlVNQkVSKTtcclxuXHRcdFx0dmFsdWVzLnB1c2gobnVtYmVyKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJyonKSB7XHJcblx0XHRcdGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIGxhc3QgPSB0eXBlc1t0eXBlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRpZiAobGFzdCAhPSBYUGF0aFBhcnNlci5BVFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVFBBUkVOVEhFU0lTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5BTkRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5PUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1PRFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRJVlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1JcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5TTEFTSFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRVNMQVNIXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuQkFSXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuUExVU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1JTlVTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRVFVQUxTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTk9URVFVQUxcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRVNTVEhBTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5PUkVRVUFMKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1IpO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYyk7XHJcblx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQVNURVJJU0tOQU1FVEVTVCk7XHJcblx0XHRcdHZhbHVlcy5wdXNoKGMpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnOicpIHtcclxuXHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJzonKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5ET1VCTEVDT0xPTik7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCI6OlwiKTtcclxuXHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJy8nKSB7XHJcblx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdGlmIChjID09ICcvJykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRE9VQkxFU0xBU0gpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiLy9cIik7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlNMQVNIKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goJy8nKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJyEnKSB7XHJcblx0XHRcdGlmIChzLmNoYXJBdChwb3MpID09ICc9Jykge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTk9URVFVQUwpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiIT1cIik7XHJcblx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjID09ICc8Jykge1xyXG5cdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnPScpIHtcclxuXHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTCk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goXCI8PVwiKTtcclxuXHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTEVTU1RIQU4pO1xyXG5cdFx0XHR2YWx1ZXMucHVzaCgnPCcpO1xyXG5cdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYyA9PSAnPicpIHtcclxuXHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJz0nKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5HUkVBVEVSVEhBTk9SRVFVQUwpO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKFwiPj1cIik7XHJcblx0XHRcdFx0cG9zKys7XHJcblx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOKTtcclxuXHRcdFx0dmFsdWVzLnB1c2goJz4nKTtcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGMgPT0gJ18nIHx8IFV0aWxpdGllcy5pc0xldHRlcihjLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0XHRcdHZhciBuYW1lID0gYztcclxuXHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0d2hpbGUgKFV0aWxpdGllcy5pc05DTmFtZUNoYXIoYy5jaGFyQ29kZUF0KDApKSkge1xyXG5cdFx0XHRcdG5hbWUgKz0gYztcclxuXHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIGxhc3QgPSB0eXBlc1t0eXBlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRpZiAobGFzdCAhPSBYUGF0aFBhcnNlci5BVFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRUNPTE9OXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVFBBUkVOVEhFU0lTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTEVGVEJSQUNLRVRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5BTkRcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5PUlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1PRFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRJVlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1VTFRJUExZT1BFUkFUT1JcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5TTEFTSFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkRPVUJMRVNMQVNIXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuQkFSXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuUExVU1xyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLk1JTlVTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuRVFVQUxTXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuTk9URVFVQUxcclxuXHRcdFx0XHRcdFx0JiYgbGFzdCAhPSBYUGF0aFBhcnNlci5MRVNTVEhBTlxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkxFU1NUSEFOT1JFUVVBTFxyXG5cdFx0XHRcdFx0XHQmJiBsYXN0ICE9IFhQYXRoUGFyc2VyLkdSRUFURVJUSEFOXHJcblx0XHRcdFx0XHRcdCYmIGxhc3QgIT0gWFBhdGhQYXJzZXIuR1JFQVRFUlRIQU5PUkVRVUFMKSB7XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PSBcImFuZFwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQU5EKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gXCJvclwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuT1IpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PSBcIm1vZFwiKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuTU9EKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG5hbWUgPT0gXCJkaXZcIikge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLkRJVik7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGMgPT0gJzonKSB7XHJcblx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJyonKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5DTkFNRUNPTE9OQVNURVJJU0spO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSArIFwiOipcIik7XHJcblx0XHRcdFx0XHRwb3MrKztcclxuXHRcdFx0XHRcdGMgPSBzLmNoYXJBdChwb3MrKyk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHMuY2hhckF0KHBvcykgPT0gJ18nIHx8IFV0aWxpdGllcy5pc0xldHRlcihzLmNoYXJDb2RlQXQocG9zKSkpIHtcclxuXHRcdFx0XHRcdG5hbWUgKz0gJzonO1xyXG5cdFx0XHRcdFx0YyA9IHMuY2hhckF0KHBvcysrKTtcclxuXHRcdFx0XHRcdHdoaWxlIChVdGlsaXRpZXMuaXNOQ05hbWVDaGFyKGMuY2hhckNvZGVBdCgwKSkpIHtcclxuXHRcdFx0XHRcdFx0bmFtZSArPSBjO1xyXG5cdFx0XHRcdFx0XHRjID0gcy5jaGFyQXQocG9zKyspO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGMgPT0gJygnKSB7XHJcblx0XHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRlVOQ1RJT05OQU1FKTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5RTkFNRSk7XHJcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnOicpIHtcclxuXHRcdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuQVhJU05BTUUpO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGMgPT0gJygnKSB7XHJcblx0XHRcdFx0aWYgKG5hbWUgPT0gXCJjb21tZW50XCIgfHwgbmFtZSA9PSBcInRleHRcIiB8fCBuYW1lID09IFwibm9kZVwiKSB7XHJcblx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLk5PREVUWVBFKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChuYW1lID09IFwicHJvY2Vzc2luZy1pbnN0cnVjdGlvblwiKSB7XHJcblx0XHRcdFx0XHRpZiAocy5jaGFyQXQocG9zKSA9PSAnKScpIHtcclxuXHRcdFx0XHRcdFx0dHlwZXMucHVzaChYUGF0aFBhcnNlci5OT0RFVFlQRSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlBST0NFU1NJTkdJTlNUUlVDVElPTldJVEhMSVRFUkFMKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHR5cGVzLnB1c2goWFBhdGhQYXJzZXIuRlVOQ1RJT05OQU1FKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaChuYW1lKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlcy5wdXNoKFhQYXRoUGFyc2VyLlFOQU1FKTtcclxuXHRcdFx0dmFsdWVzLnB1c2gobmFtZSk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiICsgYyk7XHJcblx0fVxyXG5cdHR5cGVzLnB1c2goMSk7XHJcblx0dmFsdWVzLnB1c2goXCJbRU9GXVwiKTtcclxuXHRyZXR1cm4gW3R5cGVzLCB2YWx1ZXNdO1xyXG59O1xyXG5cclxuWFBhdGhQYXJzZXIuU0hJRlQgPSAncyc7XHJcblhQYXRoUGFyc2VyLlJFRFVDRSA9ICdyJztcclxuWFBhdGhQYXJzZXIuQUNDRVBUID0gJ2EnO1xyXG5cclxuWFBhdGhQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24ocykge1xyXG5cdHZhciB0eXBlcztcclxuXHR2YXIgdmFsdWVzO1xyXG5cdHZhciByZXMgPSB0aGlzLnRva2VuaXplKHMpO1xyXG5cdGlmIChyZXMgPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHR0eXBlcyA9IHJlc1swXTtcclxuXHR2YWx1ZXMgPSByZXNbMV07XHJcblx0dmFyIHRva2VuUG9zID0gMDtcclxuXHR2YXIgc3RhdGUgPSBbXTtcclxuXHR2YXIgdG9rZW5UeXBlID0gW107XHJcblx0dmFyIHRva2VuVmFsdWUgPSBbXTtcclxuXHR2YXIgcztcclxuXHR2YXIgYTtcclxuXHR2YXIgdDtcclxuXHJcblx0c3RhdGUucHVzaCgwKTtcclxuXHR0b2tlblR5cGUucHVzaCgxKTtcclxuXHR0b2tlblZhbHVlLnB1c2goXCJfU1wiKTtcclxuXHJcblx0YSA9IHR5cGVzW3Rva2VuUG9zXTtcclxuXHR0ID0gdmFsdWVzW3Rva2VuUG9zKytdO1xyXG5cdHdoaWxlICgxKSB7XHJcblx0XHRzID0gc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV07XHJcblx0XHRzd2l0Y2ggKFhQYXRoUGFyc2VyLmFjdGlvblRhYmxlW3NdLmNoYXJBdChhIC0gMSkpIHtcclxuXHRcdFx0Y2FzZSBYUGF0aFBhcnNlci5TSElGVDpcclxuXHRcdFx0XHR0b2tlblR5cGUucHVzaCgtYSk7XHJcblx0XHRcdFx0dG9rZW5WYWx1ZS5wdXNoKHQpO1xyXG5cdFx0XHRcdHN0YXRlLnB1c2goWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMik7XHJcblx0XHRcdFx0YSA9IHR5cGVzW3Rva2VuUG9zXTtcclxuXHRcdFx0XHR0ID0gdmFsdWVzW3Rva2VuUG9zKytdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFhQYXRoUGFyc2VyLlJFRFVDRTpcclxuXHRcdFx0XHR2YXIgbnVtID0gWFBhdGhQYXJzZXIucHJvZHVjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl1bMV07XHJcblx0XHRcdFx0dmFyIHJocyA9IFtdO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuXHRcdFx0XHRcdHRva2VuVHlwZS5wb3AoKTtcclxuXHRcdFx0XHRcdHJocy51bnNoaWZ0KHRva2VuVmFsdWUucG9wKCkpO1xyXG5cdFx0XHRcdFx0c3RhdGUucG9wKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBzXyA9IHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdHRva2VuVHlwZS5wdXNoKFhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdWzBdKTtcclxuXHRcdFx0XHRpZiAodGhpcy5yZWR1Y2VBY3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0dG9rZW5WYWx1ZS5wdXNoKHJoc1swXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2VuVmFsdWUucHVzaCh0aGlzLnJlZHVjZUFjdGlvbnNbWFBhdGhQYXJzZXIuYWN0aW9uVGFibGVOdW1iZXJbc10uY2hhckNvZGVBdChhIC0gMSkgLSAzMl0ocmhzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN0YXRlLnB1c2goWFBhdGhQYXJzZXIuZ290b1RhYmxlW3NfXS5jaGFyQ29kZUF0KFhQYXRoUGFyc2VyLnByb2R1Y3Rpb25zW1hQYXRoUGFyc2VyLmFjdGlvblRhYmxlTnVtYmVyW3NdLmNoYXJDb2RlQXQoYSAtIDEpIC0gMzJdWzBdIC0gMikgLSAzMyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgWFBhdGhQYXJzZXIuQUNDRVBUOlxyXG5cdFx0XHRcdHJldHVybiBuZXcgWFBhdGgodG9rZW5WYWx1ZS5wb3AoKSk7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiWFBhdGggcGFyc2UgZXJyb3JcIik7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gWFBhdGggLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblhQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoO1xyXG5YUGF0aC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoKGUpIHtcclxuXHR0aGlzLmV4cHJlc3Npb24gPSBlO1xyXG59XHJcblxyXG5YUGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5leHByZXNzaW9uLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5YUGF0aC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0Yy5jb250ZXh0Tm9kZSA9IGMuZXhwcmVzc2lvbkNvbnRleHROb2RlO1xyXG5cdGMuY29udGV4dFNpemUgPSAxO1xyXG5cdGMuY29udGV4dFBvc2l0aW9uID0gMTtcclxuXHRjLmNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xyXG5cdGlmIChjLmNvbnRleHROb2RlICE9IG51bGwpIHtcclxuXHRcdHZhciBkb2MgPSBjLmNvbnRleHROb2RlO1xyXG5cdFx0aWYgKGRvYy5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0ZG9jID0gZG9jLm93bmVyRG9jdW1lbnQ7XHJcblx0XHR9XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjLmNhc2VJbnNlbnNpdGl2ZSA9IGRvYy5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiSFRNTFwiLCBcIjIuMFwiKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Yy5jYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKGMpO1xyXG59O1xyXG5cclxuWFBhdGguWE1MX05BTUVTUEFDRV9VUkkgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xyXG5YUGF0aC5YTUxOU19OQU1FU1BBQ0VfVVJJID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiO1xyXG5cclxuLy8gRXhwcmVzc2lvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5FeHByZXNzaW9uLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHByZXNzaW9uO1xyXG5FeHByZXNzaW9uLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRXhwcmVzc2lvbigpIHtcclxufVxyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCI8RXhwcmVzc2lvbj5cIjtcclxufTtcclxuXHJcbkV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBldmFsdWF0ZSBleHByZXNzaW9uLlwiKTtcclxufTtcclxuXHJcbi8vIFVuYXJ5T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVW5hcnlPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuVW5hcnlPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVW5hcnlPcGVyYXRpb247XHJcblVuYXJ5T3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFVuYXJ5T3BlcmF0aW9uKHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5VbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHJocykge1xyXG5cdHRoaXMucmhzID0gcmhzO1xyXG59O1xyXG5cclxuLy8gVW5hcnlNaW51c09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBVbmFyeU9wZXJhdGlvbigpO1xyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVuYXJ5TWludXNPcGVyYXRpb247XHJcblVuYXJ5TWludXNPcGVyYXRpb24uc3VwZXJjbGFzcyA9IFVuYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFVuYXJ5TWludXNPcGVyYXRpb24ocmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQocmhzKTtcclxuXHR9XHJcbn1cclxuXHJcblVuYXJ5TWludXNPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihyaHMpIHtcclxuXHRVbmFyeU1pbnVzT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIHJocyk7XHJcbn07XHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkubmVnYXRlKCk7XHJcbn07XHJcblxyXG5VbmFyeU1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIi1cIiArIHRoaXMucmhzLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vLyBCaW5hcnlPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5CaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmluYXJ5T3BlcmF0aW9uO1xyXG5CaW5hcnlPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gQmluYXJ5T3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHR0aGlzLmxocyA9IGxocztcclxuXHR0aGlzLnJocyA9IHJocztcclxufTtcclxuXHJcbi8vIE9yT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuT3JPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPck9wZXJhdGlvbjtcclxuT3JPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBPck9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk9yT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRPck9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgb3IgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG5Pck9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dmFyIGIgPSB0aGlzLmxocy5ldmFsdWF0ZShjKS5ib29sKCk7XHJcblx0aWYgKGIuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdHJldHVybiBiO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5yaHMuZXZhbHVhdGUoYykuYm9vbCgpO1xyXG59O1xyXG5cclxuLy8gQW5kT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5kT3BlcmF0aW9uO1xyXG5BbmRPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBBbmRPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEFuZE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5BbmRPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIGFuZCBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbkFuZE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0dmFyIGIgPSB0aGlzLmxocy5ldmFsdWF0ZShjKS5ib29sKCk7XHJcblx0aWYgKCFiLmJvb2xlYW5WYWx1ZSgpKSB7XHJcblx0XHRyZXR1cm4gYjtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMucmhzLmV2YWx1YXRlKGMpLmJvb2woKTtcclxufTtcclxuXHJcbi8vIEVxdWFsc09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWFsc09wZXJhdGlvbjtcclxuRXF1YWxzT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRXF1YWxzT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRFcXVhbHNPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA9IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykuZXF1YWxzKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbi8vIE5vdEVxdWFsT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTm90RXF1YWxPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb3RFcXVhbE9wZXJhdGlvbjtcclxuTm90RXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBOb3RFcXVhbE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk5vdEVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHROb3RFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgIT0gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG5Ob3RFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm5vdGVxdWFsKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbi8vIExlc3NUaGFuT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTGVzc1RoYW5PcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXNzVGhhbk9wZXJhdGlvbjtcclxuTGVzc1RoYW5PcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBMZXNzVGhhbk9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRMZXNzVGhhbk9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5MZXNzVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmxlc3N0aGFuKHRoaXMucmhzLmV2YWx1YXRlKGMpKTtcclxufTtcclxuXHJcbkxlc3NUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA8IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gR3JlYXRlclRoYW5PcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyZWF0ZXJUaGFuT3BlcmF0aW9uO1xyXG5HcmVhdGVyVGhhbk9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIEdyZWF0ZXJUaGFuT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEdyZWF0ZXJUaGFuT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkdyZWF0ZXJUaGFuT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykuZ3JlYXRlcnRoYW4odGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuR3JlYXRlclRoYW5PcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiID4gXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXNzVGhhbk9yRXF1YWxPcGVyYXRpb247XHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIExlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TGVzc1RoYW5PckVxdWFsT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbkxlc3NUaGFuT3JFcXVhbE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLmxlc3N0aGFub3JlcXVhbCh0aGlzLnJocy5ldmFsdWF0ZShjKSk7XHJcbn07XHJcblxyXG5MZXNzVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIDw9IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uO1xyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBHcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdEdyZWF0ZXJUaGFuT3JFcXVhbE9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5HcmVhdGVyVGhhbk9yRXF1YWxPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5ncmVhdGVydGhhbm9yZXF1YWwodGhpcy5yaHMuZXZhbHVhdGUoYykpO1xyXG59O1xyXG5cclxuR3JlYXRlclRoYW5PckVxdWFsT3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiA+PSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIFBsdXNPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuUGx1c09wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGx1c09wZXJhdGlvbjtcclxuUGx1c09wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFBsdXNPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5QbHVzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRQbHVzT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5wbHVzKHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcblBsdXNPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiICsgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBNaW51c09wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk1pbnVzT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWludXNPcGVyYXRpb247XHJcbk1pbnVzT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTWludXNPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TWludXNPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuTWludXNPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5taW51cyh0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5NaW51c09wZXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLmxocy50b1N0cmluZygpICsgXCIgLSBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIE11bHRpcGx5T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTXVsdGlwbHlPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aXBseU9wZXJhdGlvbjtcclxuTXVsdGlwbHlPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBNdWx0aXBseU9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRNdWx0aXBseU9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5NdWx0aXBseU9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLm11bHRpcGx5KHRoaXMucmhzLmV2YWx1YXRlKGMpLm51bWJlcigpKTtcclxufTtcclxuXHJcbk11bHRpcGx5T3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiAqIFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKSArIFwiKVwiO1xyXG59O1xyXG5cclxuLy8gRGl2T3BlcmF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlID0gbmV3IEJpbmFyeU9wZXJhdGlvbigpO1xyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGl2T3BlcmF0aW9uO1xyXG5EaXZPcGVyYXRpb24uc3VwZXJjbGFzcyA9IEJpbmFyeU9wZXJhdGlvbi5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBEaXZPcGVyYXRpb24obGhzLCByaHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChsaHMsIHJocyk7XHJcblx0fVxyXG59XHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG5cdERpdk9wZXJhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBsaHMsIHJocyk7XHJcbn07XHJcblxyXG5EaXZPcGVyYXRpb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiB0aGlzLmxocy5ldmFsdWF0ZShjKS5udW1iZXIoKS5kaXYodGhpcy5yaHMuZXZhbHVhdGUoYykubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuRGl2T3BlcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIihcIiArIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiBkaXYgXCIgKyB0aGlzLnJocy50b1N0cmluZygpICsgXCIpXCI7XHJcbn07XHJcblxyXG4vLyBNb2RPcGVyYXRpb24gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUgPSBuZXcgQmluYXJ5T3BlcmF0aW9uKCk7XHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RPcGVyYXRpb247XHJcbk1vZE9wZXJhdGlvbi5zdXBlcmNsYXNzID0gQmluYXJ5T3BlcmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE1vZE9wZXJhdGlvbihsaHMsIHJocykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGxocywgcmhzKTtcclxuXHR9XHJcbn1cclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XHJcblx0TW9kT3BlcmF0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGxocywgcmhzKTtcclxufTtcclxuXHJcbk1vZE9wZXJhdGlvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLmV2YWx1YXRlKGMpLm51bWJlcigpLm1vZCh0aGlzLnJocy5ldmFsdWF0ZShjKS5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5Nb2RPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiKFwiICsgdGhpcy5saHMudG9TdHJpbmcoKSArIFwiIG1vZCBcIiArIHRoaXMucmhzLnRvU3RyaW5nKCkgKyBcIilcIjtcclxufTtcclxuXHJcbi8vIEJhck9wZXJhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZSA9IG5ldyBCaW5hcnlPcGVyYXRpb24oKTtcclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhck9wZXJhdGlvbjtcclxuQmFyT3BlcmF0aW9uLnN1cGVyY2xhc3MgPSBCaW5hcnlPcGVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gQmFyT3BlcmF0aW9uKGxocywgcmhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobGhzLCByaHMpO1xyXG5cdH1cclxufVxyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuXHRCYXJPcGVyYXRpb24uc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbGhzLCByaHMpO1xyXG59O1xyXG5cclxuQmFyT3BlcmF0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcy5saHMuZXZhbHVhdGUoYykubm9kZXNldCgpLnVuaW9uKHRoaXMucmhzLmV2YWx1YXRlKGMpLm5vZGVzZXQoKSk7XHJcbn07XHJcblxyXG5CYXJPcGVyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubGhzLnRvU3RyaW5nKCkgKyBcIiB8IFwiICsgdGhpcy5yaHMudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbi8vIFBhdGhFeHByIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuUGF0aEV4cHIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGF0aEV4cHI7XHJcblBhdGhFeHByLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFBhdGhFeHByKGZpbHRlciwgZmlsdGVyUHJlZHMsIGxvY3BhdGgpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChmaWx0ZXIsIGZpbHRlclByZWRzLCBsb2NwYXRoKTtcclxuXHR9XHJcbn1cclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZmlsdGVyLCBmaWx0ZXJQcmVkcywgbG9jcGF0aCkge1xyXG5cdFBhdGhFeHByLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuZmlsdGVyID0gZmlsdGVyO1xyXG5cdHRoaXMuZmlsdGVyUHJlZGljYXRlcyA9IGZpbHRlclByZWRzO1xyXG5cdHRoaXMubG9jYXRpb25QYXRoID0gbG9jcGF0aDtcclxufTtcclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR2YXIgbm9kZXM7XHJcblx0dmFyIHhwYyA9IG5ldyBYUGF0aENvbnRleHQoKTtcclxuXHR4cGMudmFyaWFibGVSZXNvbHZlciA9IGMudmFyaWFibGVSZXNvbHZlcjtcclxuXHR4cGMuZnVuY3Rpb25SZXNvbHZlciA9IGMuZnVuY3Rpb25SZXNvbHZlcjtcclxuXHR4cGMubmFtZXNwYWNlUmVzb2x2ZXIgPSBjLm5hbWVzcGFjZVJlc29sdmVyO1xyXG5cdHhwYy5leHByZXNzaW9uQ29udGV4dE5vZGUgPSBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZTtcclxuXHR4cGMudmlydHVhbFJvb3QgPSBjLnZpcnR1YWxSb290O1xyXG5cdHhwYy5jYXNlSW5zZW5zaXRpdmUgPSBjLmNhc2VJbnNlbnNpdGl2ZTtcclxuXHRpZiAodGhpcy5maWx0ZXIgPT0gbnVsbCkge1xyXG5cdFx0bm9kZXMgPSBbIGMuY29udGV4dE5vZGUgXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIG5zID0gdGhpcy5maWx0ZXIuZXZhbHVhdGUoYyk7XHJcblx0XHRpZiAoIVV0aWxpdGllcy5pbnN0YW5jZV9vZihucywgWE5vZGVTZXQpKSB7XHJcblx0XHRcdGlmICh0aGlzLmZpbHRlclByZWRpY2F0ZXMgIT0gbnVsbCAmJiB0aGlzLmZpbHRlclByZWRpY2F0ZXMubGVuZ3RoID4gMCB8fCB0aGlzLmxvY2F0aW9uUGF0aCAhPSBudWxsKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGF0aCBleHByZXNzaW9uIGZpbHRlciBtdXN0IGV2YWx1YXRlIHRvIGEgbm9kc2V0IGlmIHByZWRpY2F0ZXMgb3IgbG9jYXRpb24gcGF0aCBhcmUgdXNlZFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnM7XHJcblx0XHR9XHJcblx0XHRub2RlcyA9IG5zLnRvQXJyYXkoKTtcclxuXHRcdGlmICh0aGlzLmZpbHRlclByZWRpY2F0ZXMgIT0gbnVsbCkge1xyXG5cdFx0XHQvLyBhcHBseSBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm5cclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmZpbHRlclByZWRpY2F0ZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHR2YXIgcHJlZCA9IHRoaXMuZmlsdGVyUHJlZGljYXRlc1tqXTtcclxuXHRcdFx0XHR2YXIgbmV3Tm9kZXMgPSBbXTtcclxuXHRcdFx0XHR4cGMuY29udGV4dFNpemUgPSBub2Rlcy5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICh4cGMuY29udGV4dFBvc2l0aW9uID0gMTsgeHBjLmNvbnRleHRQb3NpdGlvbiA8PSB4cGMuY29udGV4dFNpemU7IHhwYy5jb250ZXh0UG9zaXRpb24rKykge1xyXG5cdFx0XHRcdFx0eHBjLmNvbnRleHROb2RlID0gbm9kZXNbeHBjLmNvbnRleHRQb3NpdGlvbiAtIDFdO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJlZGljYXRlTWF0Y2hlcyhwcmVkLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bm9kZXMgPSBuZXdOb2RlcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAodGhpcy5sb2NhdGlvblBhdGggIT0gbnVsbCkge1xyXG5cdFx0aWYgKHRoaXMubG9jYXRpb25QYXRoLmFic29sdXRlKSB7XHJcblx0XHRcdGlmIChub2Rlc1swXS5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0XHRpZiAoeHBjLnZpcnR1YWxSb290ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdG5vZGVzID0gWyB4cGMudmlydHVhbFJvb3QgXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKG5vZGVzWzBdLm93bmVyRG9jdW1lbnQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHQvLyBJRSA1LjUgZG9lc24ndCBoYXZlIG93bmVyRG9jdW1lbnQ/XHJcblx0XHRcdFx0XHRcdHZhciBuID0gbm9kZXNbMF07XHJcblx0XHRcdFx0XHRcdHdoaWxlIChuLnBhcmVudE5vZGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdG4gPSBuLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0bm9kZXMgPSBbIG4gXTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdG5vZGVzID0gWyBub2Rlc1swXS5vd25lckRvY3VtZW50IF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5vZGVzID0gWyBub2Rlc1swXSBdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb25QYXRoLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzdGVwID0gdGhpcy5sb2NhdGlvblBhdGguc3RlcHNbaV07XHJcblx0XHRcdHZhciBuZXdOb2RlcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0eHBjLmNvbnRleHROb2RlID0gbm9kZXNbal07XHJcblx0XHRcdFx0c3dpdGNoIChzdGVwLmF4aXMpIHtcclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5BTkNFU1RPUjpcclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgdGhlIGFuY2VzdG9yIG5vZGVzXHJcblx0XHRcdFx0XHRcdGlmICh4cGMuY29udGV4dE5vZGUgPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBtO1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdFx0XHRcdFx0XHRtID0gdGhpcy5nZXRPd25lckVsZW1lbnQoeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRtID0geHBjLmNvbnRleHROb2RlLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0d2hpbGUgKG0gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwLm5vZGVUZXN0Lm1hdGNoZXMobSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYgKG0gPT09IHhwYy52aXJ0dWFsUm9vdCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdG0gPSBtLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkFOQ0VTVE9ST1JTRUxGOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYW5kIHRoZSBjdXJyZW50IG5vZGVcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZTsgbSAhPSBudWxsOyBtID0gbS5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovID8gdGhpcy5nZXRPd25lckVsZW1lbnQobSkgOiBtLnBhcmVudE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmIChtID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuQVRUUklCVVRFOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IHRoZSBhdHRyaWJ1dGVzXHJcblx0XHRcdFx0XHRcdHZhciBubm0gPSB4cGMuY29udGV4dE5vZGUuYXR0cmlidXRlcztcclxuXHRcdFx0XHRcdFx0aWYgKG5ubSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBubm0ubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBtID0gbm5tLml0ZW0oayk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdGVwLkNISUxEOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCBjaGlsZCBlbGVtZW50c1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQ7IG0gIT0gbnVsbDsgbSA9IG0ubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IGFsbCBkZXNjZW5kYW50IG5vZGVzXHJcblx0XHRcdFx0XHRcdHZhciBzdCA9IFsgeHBjLmNvbnRleHROb2RlLmZpcnN0Q2hpbGQgXTtcclxuXHRcdFx0XHRcdFx0d2hpbGUgKHN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gc3QucG9wKCk7IG0gIT0gbnVsbDsgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMucHVzaChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdC5wdXNoKG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5maXJzdENoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UT1JTRUxGOlxyXG5cdFx0XHRcdFx0XHQvLyBsb29rIGF0IHNlbGZcclxuXHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyh4cGMuY29udGV4dE5vZGUsIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Ly8gbG9vayBhdCBhbGwgZGVzY2VuZGFudCBub2Rlc1xyXG5cdFx0XHRcdFx0XHR2YXIgc3QgPSBbIHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkIF07XHJcblx0XHRcdFx0XHRcdHdoaWxlIChzdC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHN0LnBvcCgpOyBtICE9IG51bGw7ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3QucHVzaChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0uZmlyc3RDaGlsZDtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuRk9MTE9XSU5HOlxyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR2YXIgc3QgPSBbXTtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRzdC51bnNoaWZ0KHhwYy5jb250ZXh0Tm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdC51bnNoaWZ0KHhwYy5jb250ZXh0Tm9kZS5uZXh0U2libGluZyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZS5wYXJlbnROb2RlOyBtICE9IG51bGwgJiYgbS5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8gJiYgbSAhPT0geHBjLnZpcnR1YWxSb290OyBtID0gbS5wYXJlbnROb2RlKSB7XHJcblx0XHRcdFx0XHRcdFx0c3QudW5zaGlmdChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHN0LnBvcCgpOyBtICE9IG51bGw7ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobS5maXJzdENoaWxkICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3QucHVzaChtLm5leHRTaWJsaW5nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0uZmlyc3RDaGlsZDtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG0gPSBtLm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSB3aGlsZSAoc3QubGVuZ3RoID4gMCk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5GT0xMT1dJTkdTSUJMSU5HOlxyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLm5leHRTaWJsaW5nOyBtICE9IG51bGw7IG0gPSBtLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXAubm9kZVRlc3QubWF0Y2hlcyhtLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN0ZXAuTkFNRVNQQUNFOlxyXG5cdFx0XHRcdFx0XHR2YXIgbiA9IHt9O1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdFx0XHRcdFx0bltcInhtbFwiXSA9IFhQYXRoLlhNTF9OQU1FU1BBQ0VfVVJJO1xyXG5cdFx0XHRcdFx0XHRcdG5bXCJ4bWxuc1wiXSA9IFhQYXRoLlhNTE5TX05BTUVTUEFDRV9VUkk7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbSA9IHhwYy5jb250ZXh0Tm9kZTsgbSAhPSBudWxsICYmIG0ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi87IG0gPSBtLnBhcmVudE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBhdHRyID0gbS5hdHRyaWJ1dGVzLml0ZW0oayk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBubSA9IFN0cmluZyhhdHRyLm5hbWUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobm0gPT0gXCJ4bWxuc1wiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5bXCJcIl0gPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuW1wiXCJdID0gYXR0ci52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobm0ubGVuZ3RoID4gNiAmJiBubS5zdWJzdHJpbmcoMCwgNikgPT0gXCJ4bWxuczpcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBwcmUgPSBubS5zdWJzdHJpbmcoNiwgbm0ubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobltwcmVdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bltwcmVdID0gYXR0ci52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgcHJlIGluIG4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBuc24gPSBuZXcgWFBhdGhOYW1lc3BhY2UocHJlLCBuW3ByZV0sIHhwYy5jb250ZXh0Tm9kZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG5zbiwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG5zbik7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5QQVJFTlQ6XHJcblx0XHRcdFx0XHRcdG0gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlICE9PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLmdldE93bmVyRWxlbWVudCh4cGMuY29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRtID0geHBjLmNvbnRleHROb2RlLnBhcmVudE5vZGU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmIChtICE9IG51bGwgJiYgc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdOb2Rlcy5wdXNoKG0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5QUkVDRURJTkc6XHJcblx0XHRcdFx0XHRcdHZhciBzdDtcclxuXHRcdFx0XHRcdFx0aWYgKHhwYy52aXJ0dWFsUm9vdCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0c3QgPSBbIHhwYy52aXJ0dWFsUm9vdCBdO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0ID0geHBjLmNvbnRleHROb2RlLm5vZGVUeXBlID09IDkgLypOb2RlLkRPQ1VNRU5UX05PREUqL1xyXG5cdFx0XHRcdFx0XHRcdFx0PyBbIHhwYy5jb250ZXh0Tm9kZSBdXHJcblx0XHRcdFx0XHRcdFx0XHQ6IFsgeHBjLmNvbnRleHROb2RlLm93bmVyRG9jdW1lbnQgXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRvdXRlcjogd2hpbGUgKHN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gc3QucG9wKCk7IG0gIT0gbnVsbDsgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAobSA9PSB4cGMuY29udGV4dE5vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMudW5zaGlmdChtKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtLmZpcnN0Q2hpbGQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdC5wdXNoKG0ubmV4dFNpYmxpbmcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtID0gbS5maXJzdENoaWxkO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5QUkVDRURJTkdTSUJMSU5HOlxyXG5cdFx0XHRcdFx0XHRpZiAoeHBjLmNvbnRleHROb2RlID09PSB4cGMudmlydHVhbFJvb3QpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBtID0geHBjLmNvbnRleHROb2RlLnByZXZpb3VzU2libGluZzsgbSAhPSBudWxsOyBtID0gbS5wcmV2aW91c1NpYmxpbmcpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKG0sIHhwYykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2gobSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgU3RlcC5TRUxGOlxyXG5cdFx0XHRcdFx0XHRpZiAoc3RlcC5ub2RlVGVzdC5tYXRjaGVzKHhwYy5jb250ZXh0Tm9kZSwgeHBjKSkge1xyXG5cdFx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlcyA9IG5ld05vZGVzO1xyXG5cdFx0XHQvLyBhcHBseSBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm5cclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzdGVwLnByZWRpY2F0ZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHR2YXIgcHJlZCA9IHN0ZXAucHJlZGljYXRlc1tqXTtcclxuXHRcdFx0XHR2YXIgbmV3Tm9kZXMgPSBbXTtcclxuXHRcdFx0XHR4cGMuY29udGV4dFNpemUgPSBub2Rlcy5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICh4cGMuY29udGV4dFBvc2l0aW9uID0gMTsgeHBjLmNvbnRleHRQb3NpdGlvbiA8PSB4cGMuY29udGV4dFNpemU7IHhwYy5jb250ZXh0UG9zaXRpb24rKykge1xyXG5cdFx0XHRcdFx0eHBjLmNvbnRleHROb2RlID0gbm9kZXNbeHBjLmNvbnRleHRQb3NpdGlvbiAtIDFdO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJlZGljYXRlTWF0Y2hlcyhwcmVkLCB4cGMpKSB7XHJcblx0XHRcdFx0XHRcdG5ld05vZGVzLnB1c2goeHBjLmNvbnRleHROb2RlKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG5vZGVzID0gbmV3Tm9kZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIG5zID0gbmV3IFhOb2RlU2V0KCk7XHJcblx0bnMuYWRkQXJyYXkobm9kZXMpO1xyXG5cdHJldHVybiBucztcclxufTtcclxuXHJcblBhdGhFeHByLnByb3RvdHlwZS5wcmVkaWNhdGVNYXRjaGVzID0gZnVuY3Rpb24ocHJlZCwgYykge1xyXG5cdHZhciByZXMgPSBwcmVkLmV2YWx1YXRlKGMpO1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YocmVzLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIGMuY29udGV4dFBvc2l0aW9uID09IHJlcy5udW1iZXJWYWx1ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVzLmJvb2xlYW5WYWx1ZSgpO1xyXG59O1xyXG5cclxuUGF0aEV4cHIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKHRoaXMuZmlsdGVyICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIHMgPSB0aGlzLmZpbHRlci50b1N0cmluZygpO1xyXG5cdFx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZih0aGlzLmZpbHRlciwgWFN0cmluZykpIHtcclxuXHRcdFx0cyA9IFwiJ1wiICsgcyArIFwiJ1wiO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuZmlsdGVyUHJlZGljYXRlcyAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlclByZWRpY2F0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRzID0gcyArIFwiW1wiICsgdGhpcy5maWx0ZXJQcmVkaWNhdGVzW2ldLnRvU3RyaW5nKCkgKyBcIl1cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMubG9jYXRpb25QYXRoICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAoIXRoaXMubG9jYXRpb25QYXRoLmFic29sdXRlKSB7XHJcblx0XHRcdFx0cyArPSBcIi9cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzICs9IHRoaXMubG9jYXRpb25QYXRoLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcztcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubG9jYXRpb25QYXRoLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5QYXRoRXhwci5wcm90b3R5cGUuZ2V0T3duZXJFbGVtZW50ID0gZnVuY3Rpb24obikge1xyXG5cdC8vIERPTSAyIGhhcyBvd25lckVsZW1lbnRcclxuXHRpZiAobi5vd25lckVsZW1lbnQpIHtcclxuXHRcdHJldHVybiBuLm93bmVyRWxlbWVudDtcclxuXHR9XHJcblx0Ly8gRE9NIDEgSW50ZXJuZXQgRXhwbG9yZXIgY2FuIHVzZSBzZWxlY3RTaW5nbGVOb2RlIChpcm9uaWNhbGx5KVxyXG5cdHRyeSB7XHJcblx0XHRpZiAobi5zZWxlY3RTaW5nbGVOb2RlKSB7XHJcblx0XHRcdHJldHVybiBuLnNlbGVjdFNpbmdsZU5vZGUoXCIuLlwiKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0fVxyXG5cdC8vIE90aGVyIERPTSAxIGltcGxlbWVudGF0aW9ucyBtdXN0IHVzZSB0aGlzIGVncmVnaW91cyBzZWFyY2hcclxuXHR2YXIgZG9jID0gbi5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi9cclxuXHRcdFx0PyBuXHJcblx0XHRcdDogbi5vd25lckRvY3VtZW50O1xyXG5cdHZhciBlbHRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVsdHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBlbHQgPSBlbHRzLml0ZW0oaSk7XHJcblx0XHR2YXIgbm5tID0gZWx0LmF0dHJpYnV0ZXM7XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG5ubS5sZW5ndGg7IGorKykge1xyXG5cdFx0XHR2YXIgYW4gPSBubm0uaXRlbShqKTtcclxuXHRcdFx0aWYgKGFuID09PSBuKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVsdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIExvY2F0aW9uUGF0aCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuTG9jYXRpb25QYXRoLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuTG9jYXRpb25QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvY2F0aW9uUGF0aDtcclxuTG9jYXRpb25QYXRoLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTG9jYXRpb25QYXRoKGFicywgc3RlcHMpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChhYnMsIHN0ZXBzKTtcclxuXHR9XHJcbn1cclxuXHJcbkxvY2F0aW9uUGF0aC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGFicywgc3RlcHMpIHtcclxuXHR0aGlzLmFic29sdXRlID0gYWJzO1xyXG5cdHRoaXMuc3RlcHMgPSBzdGVwcztcclxufTtcclxuXHJcbkxvY2F0aW9uUGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcztcclxuXHRpZiAodGhpcy5hYnNvbHV0ZSkge1xyXG5cdFx0cyA9IFwiL1wiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzID0gXCJcIjtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaSAhPSAwKSB7XHJcblx0XHRcdHMgKz0gXCIvXCI7XHJcblx0XHR9XHJcblx0XHRzICs9IHRoaXMuc3RlcHNbaV0udG9TdHJpbmcoKTtcclxuXHR9XHJcblx0cmV0dXJuIHM7XHJcbn07XHJcblxyXG4vLyBTdGVwIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblN0ZXAucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5TdGVwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0ZXA7XHJcblN0ZXAuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBTdGVwKGF4aXMsIG5vZGV0ZXN0LCBwcmVkcykge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KGF4aXMsIG5vZGV0ZXN0LCBwcmVkcyk7XHJcblx0fVxyXG59XHJcblxyXG5TdGVwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYXhpcywgbm9kZXRlc3QsIHByZWRzKSB7XHJcblx0dGhpcy5heGlzID0gYXhpcztcclxuXHR0aGlzLm5vZGVUZXN0ID0gbm9kZXRlc3Q7XHJcblx0dGhpcy5wcmVkaWNhdGVzID0gcHJlZHM7XHJcbn07XHJcblxyXG5TdGVwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzO1xyXG5cdHN3aXRjaCAodGhpcy5heGlzKSB7XHJcblx0XHRjYXNlIFN0ZXAuQU5DRVNUT1I6XHJcblx0XHRcdHMgPSBcImFuY2VzdG9yXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkFOQ0VTVE9ST1JTRUxGOlxyXG5cdFx0XHRzID0gXCJhbmNlc3Rvci1vci1zZWxmXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkFUVFJJQlVURTpcclxuXHRcdFx0cyA9IFwiYXR0cmlidXRlXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkNISUxEOlxyXG5cdFx0XHRzID0gXCJjaGlsZFwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5ERVNDRU5EQU5UOlxyXG5cdFx0XHRzID0gXCJkZXNjZW5kYW50XCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBTdGVwLkRFU0NFTkRBTlRPUlNFTEY6XHJcblx0XHRcdHMgPSBcImRlc2NlbmRhbnQtb3Itc2VsZlwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5GT0xMT1dJTkc6XHJcblx0XHRcdHMgPSBcImZvbGxvd2luZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5GT0xMT1dJTkdTSUJMSU5HOlxyXG5cdFx0XHRzID0gXCJmb2xsb3dpbmctc2libGluZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5OQU1FU1BBQ0U6XHJcblx0XHRcdHMgPSBcIm5hbWVzcGFjZVwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5QQVJFTlQ6XHJcblx0XHRcdHMgPSBcInBhcmVudFwiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5QUkVDRURJTkc6XHJcblx0XHRcdHMgPSBcInByZWNlZGluZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5QUkVDRURJTkdTSUJMSU5HOlxyXG5cdFx0XHRzID0gXCJwcmVjZWRpbmctc2libGluZ1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgU3RlcC5TRUxGOlxyXG5cdFx0XHRzID0gXCJzZWxmXCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHRzICs9IFwiOjpcIjtcclxuXHRzICs9IHRoaXMubm9kZVRlc3QudG9TdHJpbmcoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJlZGljYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0cyArPSBcIltcIiArIHRoaXMucHJlZGljYXRlc1tpXS50b1N0cmluZygpICsgXCJdXCI7XHJcblx0fVxyXG5cdHJldHVybiBzO1xyXG59O1xyXG5cclxuU3RlcC5BTkNFU1RPUiA9IDA7XHJcblN0ZXAuQU5DRVNUT1JPUlNFTEYgPSAxO1xyXG5TdGVwLkFUVFJJQlVURSA9IDI7XHJcblN0ZXAuQ0hJTEQgPSAzO1xyXG5TdGVwLkRFU0NFTkRBTlQgPSA0O1xyXG5TdGVwLkRFU0NFTkRBTlRPUlNFTEYgPSA1O1xyXG5TdGVwLkZPTExPV0lORyA9IDY7XHJcblN0ZXAuRk9MTE9XSU5HU0lCTElORyA9IDc7XHJcblN0ZXAuTkFNRVNQQUNFID0gODtcclxuU3RlcC5QQVJFTlQgPSA5O1xyXG5TdGVwLlBSRUNFRElORyA9IDEwO1xyXG5TdGVwLlBSRUNFRElOR1NJQkxJTkcgPSAxMTtcclxuU3RlcC5TRUxGID0gMTI7XHJcblxyXG4vLyBOb2RlVGVzdCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbk5vZGVUZXN0LnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuTm9kZVRlc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9kZVRlc3Q7XHJcbk5vZGVUZXN0LnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gTm9kZVRlc3QodHlwZSwgdmFsdWUpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdCh0eXBlLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7XHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcbn07XHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVEFOWTpcclxuXHRcdFx0cmV0dXJuIFwiKlwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFBSRUZJWEFOWTpcclxuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWUgKyBcIjoqXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUkVTT0xWRURBTlk6XHJcblx0XHRcdHJldHVybiBcIntcIiArIHRoaXMudmFsdWUgKyBcIn0qXCI7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUU5BTUU6XHJcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFJFU09MVkVETkFNRTpcclxuXHRcdFx0cmV0dXJuIFwie1wiICsgdGhpcy5uYW1lc3BhY2VVUkkgKyBcIn1cIiArIHRoaXMudmFsdWU7XHJcblx0XHRjYXNlIE5vZGVUZXN0LkNPTU1FTlQ6XHJcblx0XHRcdHJldHVybiBcImNvbW1lbnQoKVwiO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5URVhUOlxyXG5cdFx0XHRyZXR1cm4gXCJ0ZXh0KClcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuUEk6XHJcblx0XHRcdGlmICh0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiBcInByb2Nlc3NpbmctaW5zdHJ1Y3Rpb24oXFxcIlwiICsgdGhpcy52YWx1ZSArIFwiXFxcIilcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gXCJwcm9jZXNzaW5nLWluc3RydWN0aW9uKClcIjtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTk9ERTpcclxuXHRcdFx0cmV0dXJuIFwibm9kZSgpXCI7XHJcblx0fVxyXG5cdHJldHVybiBcIjx1bmtub3duIG5vZGV0ZXN0IHR5cGU+XCI7XHJcbn07XHJcblxyXG5Ob2RlVGVzdC5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHhwYykge1xyXG5cdHN3aXRjaCAodGhpcy50eXBlKSB7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUQU5ZOlxyXG5cdFx0XHRpZiAobi5ub2RlVHlwZSA9PSAyIC8qTm9kZS5BVFRSSUJVVEVfTk9ERSovXHJcblx0XHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovXHJcblx0XHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IFhQYXRoTmFtZXNwYWNlLlhQQVRIX05BTUVTUEFDRV9OT0RFKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Y2FzZSBOb2RlVGVzdC5OQU1FVEVTVFBSRUZJWEFOWTpcclxuXHRcdFx0aWYgKChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8gfHwgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykpIHtcclxuXHRcdFx0XHR2YXIgbnMgPSB4cGMubmFtZXNwYWNlUmVzb2x2ZXIuZ2V0TmFtZXNwYWNlKHRoaXMudmFsdWUsIHhwYy5leHByZXNzaW9uQ29udGV4dE5vZGUpO1xyXG5cdFx0XHRcdGlmIChucyA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBRTmFtZSBcIiArIHRoaXMudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbnMgPT0gKG4ubmFtZXNwYWNlVVJJIHx8ICcnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRjYXNlIE5vZGVUZXN0Lk5BTUVURVNUUU5BTUU6XHJcblx0XHRcdGlmIChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi9cclxuXHRcdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi9cclxuXHRcdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gWFBhdGhOYW1lc3BhY2UuWFBBVEhfTkFNRVNQQUNFX05PREUpIHtcclxuXHRcdFx0XHR2YXIgdGVzdCA9IFV0aWxpdGllcy5yZXNvbHZlUU5hbWUodGhpcy52YWx1ZSwgeHBjLm5hbWVzcGFjZVJlc29sdmVyLCB4cGMuZXhwcmVzc2lvbkNvbnRleHROb2RlLCBmYWxzZSk7XHJcblx0XHRcdFx0aWYgKHRlc3RbMF0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgUU5hbWUgXCIgKyB0aGlzLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGVzdFswXSA9IFN0cmluZyh0ZXN0WzBdKTtcclxuXHRcdFx0XHR0ZXN0WzFdID0gU3RyaW5nKHRlc3RbMV0pO1xyXG5cdFx0XHRcdGlmICh0ZXN0WzBdID09IFwiXCIpIHtcclxuXHRcdFx0XHRcdHRlc3RbMF0gPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgbm9kZSA9IFtuLm5hbWVzcGFjZVVSSSB8fCAnJywgbi5sb2NhbE5hbWVdO1xyXG5cdFx0XHRcdG5vZGVbMF0gPSBTdHJpbmcobm9kZVswXSk7XHJcblx0XHRcdFx0bm9kZVsxXSA9IFN0cmluZyhub2RlWzFdKTtcclxuXHRcdFx0XHRpZiAobm9kZVswXSA9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHRub2RlWzBdID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHhwYy5jYXNlSW5zZW5zaXRpdmUpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0ZXN0WzBdID09IG5vZGVbMF0gJiYgU3RyaW5nKHRlc3RbMV0pLnRvTG93ZXJDYXNlKCkgPT0gU3RyaW5nKG5vZGVbMV0pLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0ZXN0WzBdID09IG5vZGVbMF0gJiYgdGVzdFsxXSA9PSBub2RlWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuQ09NTUVOVDpcclxuXHRcdFx0cmV0dXJuIG4ubm9kZVR5cGUgPT0gOCAvKk5vZGUuQ09NTUVOVF9OT0RFKi87XHJcblx0XHRjYXNlIE5vZGVUZXN0LlRFWFQ6XHJcblx0XHRcdHJldHVybiBuLm5vZGVUeXBlID09IDMgLypOb2RlLlRFWFRfTk9ERSovIHx8IG4ubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi87XHJcblx0XHRjYXNlIE5vZGVUZXN0LlBJOlxyXG5cdFx0XHRyZXR1cm4gbi5ub2RlVHlwZSA9PSA3IC8qTm9kZS5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUqL1xyXG5cdFx0XHRcdCYmICh0aGlzLnZhbHVlID09IG51bGwgfHwgbi5ub2RlTmFtZSA9PSB0aGlzLnZhbHVlKTtcclxuXHRcdGNhc2UgTm9kZVRlc3QuTk9ERTpcclxuXHRcdFx0cmV0dXJuIG4ubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSAxIC8qTm9kZS5FTEVNRU5UX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi9cclxuXHRcdFx0XHR8fCBuLm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovXHJcblx0XHRcdFx0fHwgbi5ub2RlVHlwZSA9PSA4IC8qTm9kZS5DT01NRU5UX05PREUqL1xyXG5cdFx0XHRcdHx8IG4ubm9kZVR5cGUgPT0gNyAvKk5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFKi87XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbk5vZGVUZXN0Lk5BTUVURVNUQU5ZID0gMDtcclxuTm9kZVRlc3QuTkFNRVRFU1RQUkVGSVhBTlkgPSAxO1xyXG5Ob2RlVGVzdC5OQU1FVEVTVFFOQU1FID0gMjtcclxuTm9kZVRlc3QuQ09NTUVOVCA9IDM7XHJcbk5vZGVUZXN0LlRFWFQgPSA0O1xyXG5Ob2RlVGVzdC5QSSA9IDU7XHJcbk5vZGVUZXN0Lk5PREUgPSA2O1xyXG5cclxuLy8gVmFyaWFibGVSZWZlcmVuY2UgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYXJpYWJsZVJlZmVyZW5jZTtcclxuVmFyaWFibGVSZWZlcmVuY2Uuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gVmFyaWFibGVSZWZlcmVuY2Uodikge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dGhpcy5pbml0KHYpO1xyXG5cdH1cclxufVxyXG5cclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih2KSB7XHJcblx0dGhpcy52YXJpYWJsZSA9IHY7XHJcbn07XHJcblxyXG5WYXJpYWJsZVJlZmVyZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gXCIkXCIgKyB0aGlzLnZhcmlhYmxlO1xyXG59O1xyXG5cclxuVmFyaWFibGVSZWZlcmVuY2UucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiBjLnZhcmlhYmxlUmVzb2x2ZXIuZ2V0VmFyaWFibGUodGhpcy52YXJpYWJsZSwgYyk7XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbkNhbGwgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnVuY3Rpb25DYWxsO1xyXG5GdW5jdGlvbkNhbGwuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gRnVuY3Rpb25DYWxsKGZuLCBhcmdzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQoZm4sIGFyZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZm4sIGFyZ3MpIHtcclxuXHR0aGlzLmZ1bmN0aW9uTmFtZSA9IGZuO1xyXG5cdHRoaXMuYXJndW1lbnRzID0gYXJncztcclxufTtcclxuXHJcbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcyA9IHRoaXMuZnVuY3Rpb25OYW1lICsgXCIoXCI7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGkgPiAwKSB7XHJcblx0XHRcdHMgKz0gXCIsIFwiO1xyXG5cdFx0fVxyXG5cdFx0cyArPSB0aGlzLmFyZ3VtZW50c1tpXS50b1N0cmluZygpO1xyXG5cdH1cclxuXHRyZXR1cm4gcyArIFwiKVwiO1xyXG59O1xyXG5cclxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHR2YXIgZiA9IGMuZnVuY3Rpb25SZXNvbHZlci5nZXRGdW5jdGlvbih0aGlzLmZ1bmN0aW9uTmFtZSwgYyk7XHJcblx0aWYgKGYgPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uIFwiICsgdGhpcy5mdW5jdGlvbk5hbWUpO1xyXG5cdH1cclxuXHR2YXIgYSA9IFtjXS5jb25jYXQodGhpcy5hcmd1bWVudHMpO1xyXG5cdHJldHVybiBmLmFwcGx5KGMuZnVuY3Rpb25SZXNvbHZlci50aGlzQXJnLCBhKTtcclxufTtcclxuXHJcbi8vIFhTdHJpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhTdHJpbmc7XHJcblhTdHJpbmcuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFN0cmluZyhzKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQocyk7XHJcblx0fVxyXG59XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocykge1xyXG5cdHRoaXMuc3RyID0gcztcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc3RyO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLnN0cik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLnN0cik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ub2Rlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIG5vZGVzZXRcIik7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnN0cjtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubnVtYmVyVmFsdWUoKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmJvb2woKS5ib29sZWFuVmFsdWUoKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYm9vbCgpLmVxdWFscyhyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZXF1YWxzKHIpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhTdHJpbmcodGhpcywgT3BlcmF0b3JzLmVxdWFscyk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5zdHIgPT0gci5zdHIpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubm90ZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvb2woKS5ub3RlcXVhbChyKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKCkubm90ZXF1YWwocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aFN0cmluZyh0aGlzLCBPcGVyYXRvcnMubm90ZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuc3RyICE9IHIuc3RyKTtcclxufTtcclxuXHJcblhTdHJpbmcucHJvdG90eXBlLmxlc3N0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkubGVzc3RoYW4oci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmdyZWF0ZXJ0aGFuKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWFN0cmluZy5wcm90b3R5cGUubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5sZXNzdGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YU3RyaW5nLnByb3RvdHlwZS5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMubnVtYmVyKCksIE9wZXJhdG9ycy5sZXNzdGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmdyZWF0ZXJ0aGFub3JlcXVhbChyLm51bWJlcigpKTtcclxufTtcclxuXHJcbi8vIFhOdW1iZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YTnVtYmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhOdW1iZXI7XHJcblhOdW1iZXIuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWE51bWJlcihuKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHR0aGlzLmluaXQobik7XHJcblx0fVxyXG59XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obikge1xyXG5cdHRoaXMubnVtID0gTnVtYmVyKG4pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5udW07XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0aGlzLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm5vZGVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBudW1iZXIgdG8gbm9kZXNldFwiKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc3RyaW5nKCkuc3RyaW5nVmFsdWUoKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUuYm9vbGVhblZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuYm9vbCgpLmJvb2xlYW5WYWx1ZSgpO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKC10aGlzLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvb2woKS5lcXVhbHMocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmVxdWFscyhyLm51bWJlcigpKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtID09IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib29sKCkubm90ZXF1YWwocik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLm5vdGVxdWFsKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLm51bSAhPSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5sZXNzdGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubGVzc3RoYW4oci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPCByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ3JlYXRlcnRoYW4oci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPiByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5sZXNzdGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTm9kZVNldCkpIHtcclxuXHRcdHJldHVybiByLmNvbXBhcmVXaXRoTnVtYmVyKHRoaXMsIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pIHx8IFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubGVzc3RoYW5vcmVxdWFsKHIubnVtYmVyKCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMubnVtIDw9IHIubnVtKTtcclxufTtcclxuXHJcblhOdW1iZXIucHJvdG90eXBlLmdyZWF0ZXJ0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcywgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ncmVhdGVydGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy5udW0gPj0gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUucGx1cyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gKyByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5taW51cyA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gLSByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKHIpIHtcclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIodGhpcy5udW0gKiByLm51bSk7XHJcbn07XHJcblxyXG5YTnVtYmVyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihyKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMubnVtIC8gci5udW0pO1xyXG59O1xyXG5cclxuWE51bWJlci5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24ocikge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLm51bSAlIHIubnVtKTtcclxufTtcclxuXHJcbi8vIFhCb29sZWFuIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlID0gbmV3IEV4cHJlc3Npb24oKTtcclxuWEJvb2xlYW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWEJvb2xlYW47XHJcblhCb29sZWFuLnN1cGVyY2xhc3MgPSBFeHByZXNzaW9uLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhCb29sZWFuKGIpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHRoaXMuaW5pdChiKTtcclxuXHR9XHJcbn1cclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYikge1xyXG5cdHRoaXMuYiA9IEJvb2xlYW4oYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5iLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHRoaXMuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKHRoaXMuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm5vZGVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBib29sZWFuIHRvIG5vZGVzZXRcIik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5zdHJpbmcoKS5zdHJpbmdWYWx1ZSgpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm51bWJlclZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubnVtKCkubnVtYmVyVmFsdWUoKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5iO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oIXRoaXMuYik7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcXVhbHMoci5ib29sKCkpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhCb29sZWFuKHRoaXMsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRoaXMuYiA9PSByLmIpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykgfHwgVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5ub3RlcXVhbChyLmJvb2woKSk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aEJvb2xlYW4odGhpcywgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbih0aGlzLmIgIT0gci5iKTtcclxufTtcclxuXHJcblhCb29sZWFuLnByb3RvdHlwZS5sZXNzdGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOb2RlU2V0KSkge1xyXG5cdFx0cmV0dXJuIHIuY29tcGFyZVdpdGhOdW1iZXIodGhpcy5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLm51bWJlcigpLmxlc3N0aGFuKHIubnVtYmVyKCkpO1xyXG59O1xyXG5cclxuWEJvb2xlYW4ucHJvdG90eXBlLmdyZWF0ZXJ0aGFuID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubnVtYmVyKCkuZ3JlYXRlcnRoYW4oci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5sZXNzdGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG5YQm9vbGVhbi5wcm90b3R5cGUuZ3JlYXRlcnRoYW5vcmVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE5vZGVTZXQpKSB7XHJcblx0XHRyZXR1cm4gci5jb21wYXJlV2l0aE51bWJlcih0aGlzLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5udW1iZXIoKS5ncmVhdGVydGhhbm9yZXF1YWwoci5udW1iZXIoKSk7XHJcbn07XHJcblxyXG4vLyBBVkxUcmVlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkFWTFRyZWUucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5BVkxUcmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFWTFRyZWU7XHJcbkFWTFRyZWUuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBBVkxUcmVlKG4pIHtcclxuXHR0aGlzLmluaXQobik7XHJcbn1cclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihuKSB7XHJcblx0dGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG5cdHRoaXMubm9kZSA9IG47XHJcblx0dGhpcy5kZXB0aCA9IDE7XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbGRlcHRoID0gdGhpcy5sZWZ0ICA9PSBudWxsID8gMCA6IHRoaXMubGVmdC5kZXB0aDtcclxuICAgIHZhciByZGVwdGggPSB0aGlzLnJpZ2h0ID09IG51bGwgPyAwIDogdGhpcy5yaWdodC5kZXB0aDtcclxuXHJcblx0aWYgKGxkZXB0aCA+IHJkZXB0aCArIDEpIHtcclxuICAgICAgICAvLyBMUiBvciBMTCByb3RhdGlvblxyXG4gICAgICAgIHZhciBsbGRlcHRoID0gdGhpcy5sZWZ0LmxlZnQgID09IG51bGwgPyAwIDogdGhpcy5sZWZ0LmxlZnQuZGVwdGg7XHJcbiAgICAgICAgdmFyIGxyZGVwdGggPSB0aGlzLmxlZnQucmlnaHQgPT0gbnVsbCA/IDAgOiB0aGlzLmxlZnQucmlnaHQuZGVwdGg7XHJcblxyXG4gICAgICAgIGlmIChsbGRlcHRoIDwgbHJkZXB0aCkge1xyXG4gICAgICAgICAgICAvLyBMUiByb3RhdGlvbiBjb25zaXN0cyBvZiBhIFJSIHJvdGF0aW9uIG9mIHRoZSBsZWZ0IGNoaWxkXHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5yb3RhdGVSUigpO1xyXG4gICAgICAgICAgICAvLyBwbHVzIGEgTEwgcm90YXRpb24gb2YgdGhpcyBub2RlLCB3aGljaCBoYXBwZW5zIGFueXdheVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJvdGF0ZUxMKCk7XHJcbiAgICB9IGVsc2UgaWYgKGxkZXB0aCArIDEgPCByZGVwdGgpIHtcclxuICAgICAgICAvLyBSUiBvciBSTCByb3JhcmlvblxyXG5cdFx0dmFyIHJyZGVwdGggPSB0aGlzLnJpZ2h0LnJpZ2h0ID09IG51bGwgPyAwIDogdGhpcy5yaWdodC5yaWdodC5kZXB0aDtcclxuXHRcdHZhciBybGRlcHRoID0gdGhpcy5yaWdodC5sZWZ0ICA9PSBudWxsID8gMCA6IHRoaXMucmlnaHQubGVmdC5kZXB0aDtcclxuXHJcbiAgICAgICAgaWYgKHJsZGVwdGggPiBycmRlcHRoKSB7XHJcbiAgICAgICAgICAgIC8vIFJSIHJvdGF0aW9uIGNvbnNpc3RzIG9mIGEgTEwgcm90YXRpb24gb2YgdGhlIHJpZ2h0IGNoaWxkXHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQucm90YXRlTEwoKTtcclxuICAgICAgICAgICAgLy8gcGx1cyBhIFJSIHJvdGF0aW9uIG9mIHRoaXMgbm9kZSwgd2hpY2ggaGFwcGVucyBhbnl3YXlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3RhdGVSUigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUucm90YXRlTEwgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIHRoZSBsZWZ0IHNpZGUgaXMgdG9vIGxvbmcgPT4gcm90YXRlIGZyb20gdGhlIGxlZnQgKF9ub3RfIGxlZnR3YXJkcylcclxuICAgIHZhciBub2RlQmVmb3JlID0gdGhpcy5ub2RlO1xyXG4gICAgdmFyIHJpZ2h0QmVmb3JlID0gdGhpcy5yaWdodDtcclxuICAgIHRoaXMubm9kZSA9IHRoaXMubGVmdC5ub2RlO1xyXG4gICAgdGhpcy5yaWdodCA9IHRoaXMubGVmdDtcclxuICAgIHRoaXMubGVmdCA9IHRoaXMubGVmdC5sZWZ0O1xyXG4gICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpcy5yaWdodC5yaWdodDtcclxuICAgIHRoaXMucmlnaHQucmlnaHQgPSByaWdodEJlZm9yZTtcclxuICAgIHRoaXMucmlnaHQubm9kZSA9IG5vZGVCZWZvcmU7XHJcbiAgICB0aGlzLnJpZ2h0LnVwZGF0ZUluTmV3TG9jYXRpb24oKTtcclxuICAgIHRoaXMudXBkYXRlSW5OZXdMb2NhdGlvbigpO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUucm90YXRlUlIgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIHRoZSByaWdodCBzaWRlIGlzIHRvbyBsb25nID0+IHJvdGF0ZSBmcm9tIHRoZSByaWdodCAoX25vdF8gcmlnaHR3YXJkcylcclxuICAgIHZhciBub2RlQmVmb3JlID0gdGhpcy5ub2RlO1xyXG4gICAgdmFyIGxlZnRCZWZvcmUgPSB0aGlzLmxlZnQ7XHJcbiAgICB0aGlzLm5vZGUgPSB0aGlzLnJpZ2h0Lm5vZGU7XHJcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgdGhpcy5yaWdodCA9IHRoaXMucmlnaHQucmlnaHQ7XHJcbiAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzLmxlZnQubGVmdDtcclxuICAgIHRoaXMubGVmdC5sZWZ0ID0gbGVmdEJlZm9yZTtcclxuICAgIHRoaXMubGVmdC5ub2RlID0gbm9kZUJlZm9yZTtcclxuICAgIHRoaXMubGVmdC51cGRhdGVJbk5ld0xvY2F0aW9uKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUluTmV3TG9jYXRpb24oKTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLnVwZGF0ZUluTmV3TG9jYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZ2V0RGVwdGhGcm9tQ2hpbGRyZW4oKTtcclxufTtcclxuXHJcbkFWTFRyZWUucHJvdG90eXBlLmdldERlcHRoRnJvbUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRlcHRoID0gdGhpcy5ub2RlID09IG51bGwgPyAwIDogMTtcclxuICAgIGlmICh0aGlzLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLmxlZnQuZGVwdGggKyAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucmlnaHQgIT0gbnVsbCAmJiB0aGlzLmRlcHRoIDw9IHRoaXMucmlnaHQuZGVwdGgpIHtcclxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5yaWdodC5kZXB0aCArIDE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BVkxUcmVlLnByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uKG4xLCBuMikge1xyXG5cdGlmIChuMSA9PT0gbjIpIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHR2YXIgZDEgPSAwO1xyXG5cdHZhciBkMiA9IDA7XHJcblx0Zm9yICh2YXIgbTEgPSBuMTsgbTEgIT0gbnVsbDsgbTEgPSBtMS5wYXJlbnROb2RlKSB7XHJcblx0XHRkMSsrO1xyXG5cdH1cclxuXHRmb3IgKHZhciBtMiA9IG4yOyBtMiAhPSBudWxsOyBtMiA9IG0yLnBhcmVudE5vZGUpIHtcclxuXHRcdGQyKys7XHJcblx0fVxyXG5cdGlmIChkMSA+IGQyKSB7XHJcblx0XHR3aGlsZSAoZDEgPiBkMikge1xyXG5cdFx0XHRuMSA9IG4xLnBhcmVudE5vZGU7XHJcblx0XHRcdGQxLS07XHJcblx0XHR9XHJcblx0XHRpZiAobjEgPT0gbjIpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChkMiA+IGQxKSB7XHJcblx0XHR3aGlsZSAoZDIgPiBkMSkge1xyXG5cdFx0XHRuMiA9IG4yLnBhcmVudE5vZGU7XHJcblx0XHRcdGQyLS07XHJcblx0XHR9XHJcblx0XHRpZiAobjEgPT0gbjIpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR3aGlsZSAobjEucGFyZW50Tm9kZSAhPSBuMi5wYXJlbnROb2RlKSB7XHJcblx0XHRuMSA9IG4xLnBhcmVudE5vZGU7XHJcblx0XHRuMiA9IG4yLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHdoaWxlIChuMS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCAmJiBuMi5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCkge1xyXG5cdFx0bjEgPSBuMS5wcmV2aW91c1NpYmxpbmc7XHJcblx0XHRuMiA9IG4yLnByZXZpb3VzU2libGluZztcclxuXHR9XHJcblx0aWYgKG4xLnByZXZpb3VzU2libGluZyA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdHJldHVybiAxO1xyXG59O1xyXG5cclxuQVZMVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obikgIHtcclxuXHRpZiAobiA9PT0gdGhpcy5ub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHR2YXIgbyA9IHRoaXMub3JkZXIobiwgdGhpcy5ub2RlKTtcclxuXHJcbiAgICB2YXIgcmV0ID0gZmFsc2U7XHJcbiAgICBpZiAobyA9PSAtMSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXcgQVZMVHJlZShuKTtcclxuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXQgPSB0aGlzLmxlZnQuYWRkKG4pO1xyXG4gICAgICAgICAgICBpZiAocmV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhbGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobyA9PSAxKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmV3IEFWTFRyZWUobik7XHJcbiAgICAgICAgICAgIHJldCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0ID0gdGhpcy5yaWdodC5hZGQobik7XHJcbiAgICAgICAgICAgIGlmIChyZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFsYW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXQpIHtcclxuICAgICAgICB0aGlzLmdldERlcHRoRnJvbUNoaWxkcmVuKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuLy8gWE5vZGVTZXQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUgPSBuZXcgRXhwcmVzc2lvbigpO1xyXG5YTm9kZVNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYTm9kZVNldDtcclxuWE5vZGVTZXQuc3VwZXJjbGFzcyA9IEV4cHJlc3Npb24ucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWE5vZGVTZXQoKSB7XHJcblx0dGhpcy5pbml0KCk7XHJcbn1cclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy50cmVlID0gbnVsbDtcclxuXHR0aGlzLnNpemUgPSAwO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHAgPSB0aGlzLmZpcnN0KCk7XHJcblx0aWYgKHAgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIFwiXCI7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLnN0cmluZ0Zvck5vZGUocCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHRoaXMudG9TdHJpbmcoKSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWE51bWJlcih0aGlzLnN0cmluZygpKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5udW1iZXJWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBOdW1iZXIodGhpcy5zdHJpbmcoKSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4odGhpcy50cmVlICE9IG51bGwpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnRyZWUgIT0gbnVsbDtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ub2Rlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZSA9IGZ1bmN0aW9uKG4pIHtcclxuXHRpZiAobi5ub2RlVHlwZSA9PSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi8pIHtcclxuXHRcdG4gPSBuLmRvY3VtZW50RWxlbWVudDtcclxuXHR9XHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdHJldHVybiB0aGlzLnN0cmluZ0Zvck5vZGVSZWMobik7XHJcblx0fVxyXG5cdGlmIChuLmlzTmFtZXNwYWNlTm9kZSkge1xyXG5cdFx0cmV0dXJuIG4ubmFtZXNwYWNlO1xyXG5cdH1cclxuXHRyZXR1cm4gbi5ub2RlVmFsdWU7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZVJlYyA9IGZ1bmN0aW9uKG4pIHtcclxuXHR2YXIgcyA9IFwiXCI7XHJcblx0Zm9yICh2YXIgbjIgPSBuLmZpcnN0Q2hpbGQ7IG4yICE9IG51bGw7IG4yID0gbjIubmV4dFNpYmxpbmcpIHtcclxuXHRcdGlmIChuMi5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqLykge1xyXG5cdFx0XHRzICs9IG4yLm5vZGVWYWx1ZTtcclxuXHRcdH0gZWxzZSBpZiAobjIubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdFx0cyArPSB0aGlzLnN0cmluZ0Zvck5vZGVSZWMobjIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcztcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwID0gdGhpcy50cmVlO1xyXG5cdGlmIChwID09IG51bGwpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHR3aGlsZSAocC5sZWZ0ICE9IG51bGwpIHtcclxuXHRcdHAgPSBwLmxlZnQ7XHJcblx0fVxyXG5cdHJldHVybiBwLm5vZGU7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIGFkZGVkO1xyXG4gICAgaWYgKHRoaXMudHJlZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy50cmVlID0gbmV3IEFWTFRyZWUobik7XHJcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhZGRlZCA9IHRoaXMudHJlZS5hZGQobik7XHJcbiAgICB9XHJcbiAgICBpZiAoYWRkZWQpIHtcclxuICAgICAgICB0aGlzLnNpemUrKztcclxuICAgIH1cclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5hZGRBcnJheSA9IGZ1bmN0aW9uKG5zKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dGhpcy5hZGQobnNbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGEgPSBbXTtcclxuXHR0aGlzLnRvQXJyYXlSZWModGhpcy50cmVlLCBhKTtcclxuXHRyZXR1cm4gYTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS50b0FycmF5UmVjID0gZnVuY3Rpb24odCwgYSkge1xyXG5cdGlmICh0ICE9IG51bGwpIHtcclxuXHRcdHRoaXMudG9BcnJheVJlYyh0LmxlZnQsIGEpO1xyXG5cdFx0YS5wdXNoKHQubm9kZSk7XHJcblx0XHR0aGlzLnRvQXJyYXlSZWModC5yaWdodCwgYSk7XHJcblx0fVxyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbXBhcmVXaXRoU3RyaW5nID0gZnVuY3Rpb24ociwgbykge1xyXG5cdHZhciBhID0gdGhpcy50b0FycmF5KCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbiA9IGFbaV07XHJcblx0XHR2YXIgbCA9IG5ldyBYU3RyaW5nKHRoaXMuc3RyaW5nRm9yTm9kZShuKSk7XHJcblx0XHR2YXIgcmVzID0gbyhsLCByKTtcclxuXHRcdGlmIChyZXMuYm9vbGVhblZhbHVlKCkpIHtcclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuY29tcGFyZVdpdGhOdW1iZXIgPSBmdW5jdGlvbihyLCBvKSB7XHJcblx0dmFyIGEgPSB0aGlzLnRvQXJyYXkoKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBuID0gYVtpXTtcclxuXHRcdHZhciBsID0gbmV3IFhOdW1iZXIodGhpcy5zdHJpbmdGb3JOb2RlKG4pKTtcclxuXHRcdHZhciByZXMgPSBvKGwsIHIpO1xyXG5cdFx0aWYgKHJlcy5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKGZhbHNlKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5jb21wYXJlV2l0aEJvb2xlYW4gPSBmdW5jdGlvbihyLCBvKSB7XHJcblx0cmV0dXJuIG8odGhpcy5ib29sKCksIHIpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmNvbXBhcmVXaXRoTm9kZVNldCA9IGZ1bmN0aW9uKHIsIG8pIHtcclxuXHR2YXIgYSA9IHRoaXMudG9BcnJheSgpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG4gPSBhW2ldO1xyXG5cdFx0dmFyIGwgPSBuZXcgWFN0cmluZyh0aGlzLnN0cmluZ0Zvck5vZGUobikpO1xyXG5cdFx0dmFyIGIgPSByLnRvQXJyYXkoKTtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xyXG5cdFx0XHR2YXIgbjIgPSBiW2pdO1xyXG5cdFx0XHR2YXIgciA9IG5ldyBYU3RyaW5nKHRoaXMuc3RyaW5nRm9yTm9kZShuMikpO1xyXG5cdFx0XHR2YXIgcmVzID0gbyhsLCByKTtcclxuXHRcdFx0aWYgKHJlcy5ib29sZWFuVmFsdWUoKSkge1xyXG5cdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoU3RyaW5nKHIsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMuZXF1YWxzKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5lcXVhbHMpO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLm5vdGVxdWFsID0gZnVuY3Rpb24ocikge1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWFN0cmluZykpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoU3RyaW5nKHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLm5vdGVxdWFsKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOb2RlU2V0KHIsIE9wZXJhdG9ycy5ub3RlcXVhbCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUubGVzc3RoYW4gPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIoci5udW1iZXIoKSwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYQm9vbGVhbikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoQm9vbGVhbihyLCBPcGVyYXRvcnMubGVzc3RoYW4pO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmxlc3N0aGFuKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ncmVhdGVydGhhbiA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLm51bWJlcigpLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhOdW1iZXIpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbik7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMuZ3JlYXRlcnRoYW4pO1xyXG59O1xyXG5cclxuWE5vZGVTZXQucHJvdG90eXBlLmxlc3N0aGFub3JlcXVhbCA9IGZ1bmN0aW9uKHIpIHtcclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhTdHJpbmcpKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE51bWJlcihyLm51bWJlcigpLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxuXHR9XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYTnVtYmVyKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIociwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWEJvb2xlYW4pKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aEJvb2xlYW4ociwgT3BlcmF0b3JzLmxlc3N0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTm9kZVNldChyLCBPcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsKTtcclxufTtcclxuXHJcblhOb2RlU2V0LnByb3RvdHlwZS5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihyKSB7XHJcblx0aWYgKFV0aWxpdGllcy5pbnN0YW5jZV9vZihyLCBYU3RyaW5nKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhOdW1iZXIoci5udW1iZXIoKSwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcblx0fVxyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YociwgWE51bWJlcikpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbXBhcmVXaXRoTnVtYmVyKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRpZiAoVXRpbGl0aWVzLmluc3RhbmNlX29mKHIsIFhCb29sZWFuKSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVdpdGhCb29sZWFuKHIsIE9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5jb21wYXJlV2l0aE5vZGVTZXQociwgT3BlcmF0b3JzLmdyZWF0ZXJ0aGFub3JlcXVhbCk7XHJcbn07XHJcblxyXG5YTm9kZVNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihyKSB7XHJcblx0dmFyIG5zID0gbmV3IFhOb2RlU2V0KCk7XHJcblx0bnMudHJlZSA9IHRoaXMudHJlZTtcclxuXHRucy5zaXplID0gdGhpcy5zaXplO1xyXG5cdG5zLmFkZEFycmF5KHIudG9BcnJheSgpKTtcclxuXHRyZXR1cm4gbnM7XHJcbn07XHJcblxyXG4vLyBYUGF0aE5hbWVzcGFjZSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblhQYXRoTmFtZXNwYWNlLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoKTtcclxuWFBhdGhOYW1lc3BhY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhOYW1lc3BhY2U7XHJcblhQYXRoTmFtZXNwYWNlLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhOYW1lc3BhY2UocHJlLCBucywgcCkge1xyXG5cdHRoaXMuaXNYUGF0aE5hbWVzcGFjZSA9IHRydWU7XHJcblx0dGhpcy5vd25lckRvY3VtZW50ID0gcC5vd25lckRvY3VtZW50O1xyXG5cdHRoaXMubm9kZU5hbWUgPSBcIiNuYW1lc3BhY2VcIjtcclxuXHR0aGlzLnByZWZpeCA9IHByZTtcclxuXHR0aGlzLmxvY2FsTmFtZSA9IHByZTtcclxuXHR0aGlzLm5hbWVzcGFjZVVSSSA9IG5zO1xyXG5cdHRoaXMubm9kZVZhbHVlID0gbnM7XHJcblx0dGhpcy5vd25lckVsZW1lbnQgPSBwO1xyXG5cdHRoaXMubm9kZVR5cGUgPSBYUGF0aE5hbWVzcGFjZS5YUEFUSF9OQU1FU1BBQ0VfTk9ERTtcclxufVxyXG5cclxuWFBhdGhOYW1lc3BhY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwieyBcXFwiXCIgKyB0aGlzLnByZWZpeCArIFwiXFxcIiwgXFxcIlwiICsgdGhpcy5uYW1lc3BhY2VVUkkgKyBcIlxcXCIgfVwiO1xyXG59O1xyXG5cclxuLy8gT3BlcmF0b3JzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG52YXIgT3BlcmF0b3JzID0gbmV3IE9iamVjdCgpO1xyXG5cclxuT3BlcmF0b3JzLmVxdWFscyA9IGZ1bmN0aW9uKGwsIHIpIHtcclxuXHRyZXR1cm4gbC5lcXVhbHMocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMubm90ZXF1YWwgPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwubm90ZXF1YWwocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMubGVzc3RoYW4gPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwubGVzc3RoYW4ocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMuZ3JlYXRlcnRoYW4gPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwuZ3JlYXRlcnRoYW4ocik7XHJcbn07XHJcblxyXG5PcGVyYXRvcnMubGVzc3RoYW5vcmVxdWFsID0gZnVuY3Rpb24obCwgcikge1xyXG5cdHJldHVybiBsLmxlc3N0aGFub3JlcXVhbChyKTtcclxufTtcclxuXHJcbk9wZXJhdG9ycy5ncmVhdGVydGhhbm9yZXF1YWwgPSBmdW5jdGlvbihsLCByKSB7XHJcblx0cmV0dXJuIGwuZ3JlYXRlcnRoYW5vcmVxdWFsKHIpO1xyXG59O1xyXG5cclxuLy8gWFBhdGhDb250ZXh0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aENvbnRleHQucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5YUGF0aENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFBhdGhDb250ZXh0O1xyXG5YUGF0aENvbnRleHQuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBYUGF0aENvbnRleHQodnIsIG5yLCBmcikge1xyXG5cdHRoaXMudmFyaWFibGVSZXNvbHZlciA9IHZyICE9IG51bGwgPyB2ciA6IG5ldyBWYXJpYWJsZVJlc29sdmVyKCk7XHJcblx0dGhpcy5uYW1lc3BhY2VSZXNvbHZlciA9IG5yICE9IG51bGwgPyBuciA6IG5ldyBOYW1lc3BhY2VSZXNvbHZlcigpO1xyXG5cdHRoaXMuZnVuY3Rpb25SZXNvbHZlciA9IGZyICE9IG51bGwgPyBmciA6IG5ldyBGdW5jdGlvblJlc29sdmVyKCk7XHJcbn1cclxuXHJcbi8vIFZhcmlhYmxlUmVzb2x2ZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuVmFyaWFibGVSZXNvbHZlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcblZhcmlhYmxlUmVzb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmFyaWFibGVSZXNvbHZlcjtcclxuVmFyaWFibGVSZXNvbHZlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFZhcmlhYmxlUmVzb2x2ZXIoKSB7XHJcbn1cclxuXHJcblZhcmlhYmxlUmVzb2x2ZXIucHJvdG90eXBlLmdldFZhcmlhYmxlID0gZnVuY3Rpb24odm4sIGMpIHtcclxuXHR2YXIgcGFydHMgPSBVdGlsaXRpZXMuc3BsaXRRTmFtZSh2bik7XHJcblx0aWYgKHBhcnRzWzBdICE9IG51bGwpIHtcclxuXHRcdHBhcnRzWzBdID0gYy5uYW1lc3BhY2VSZXNvbHZlci5nZXROYW1lc3BhY2UocGFydHNbMF0sIGMuZXhwcmVzc2lvbkNvbnRleHROb2RlKTtcclxuICAgICAgICBpZiAocGFydHNbMF0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBRTmFtZSBcIiArIGZuKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLmdldFZhcmlhYmxlV2l0aE5hbWUocGFydHNbMF0sIHBhcnRzWzFdLCBjLmV4cHJlc3Npb25Db250ZXh0Tm9kZSk7XHJcbn07XHJcblxyXG5WYXJpYWJsZVJlc29sdmVyLnByb3RvdHlwZS5nZXRWYXJpYWJsZVdpdGhOYW1lID0gZnVuY3Rpb24obnMsIGxuLCBjKSB7XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvblJlc29sdmVyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlID0gbmV3IE9iamVjdCgpO1xyXG5GdW5jdGlvblJlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uUmVzb2x2ZXI7XHJcbkZ1bmN0aW9uUmVzb2x2ZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvblJlc29sdmVyKHRoaXNBcmcpIHtcclxuXHR0aGlzLnRoaXNBcmcgPSB0aGlzQXJnICE9IG51bGwgPyB0aGlzQXJnIDogRnVuY3Rpb25zO1xyXG5cdHRoaXMuZnVuY3Rpb25zID0gbmV3IE9iamVjdCgpO1xyXG5cdHRoaXMuYWRkU3RhbmRhcmRGdW5jdGlvbnMoKTtcclxufVxyXG5cclxuRnVuY3Rpb25SZXNvbHZlci5wcm90b3R5cGUuYWRkU3RhbmRhcmRGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bGFzdFwiXSA9IEZ1bmN0aW9ucy5sYXN0O1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31wb3NpdGlvblwiXSA9IEZ1bmN0aW9ucy5wb3NpdGlvbjtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y291bnRcIl0gPSBGdW5jdGlvbnMuY291bnQ7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWlkXCJdID0gRnVuY3Rpb25zLmlkO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31sb2NhbC1uYW1lXCJdID0gRnVuY3Rpb25zLmxvY2FsTmFtZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bmFtZXNwYWNlLXVyaVwiXSA9IEZ1bmN0aW9ucy5uYW1lc3BhY2VVUkk7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW5hbWVcIl0gPSBGdW5jdGlvbnMubmFtZTtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3RyaW5nXCJdID0gRnVuY3Rpb25zLnN0cmluZztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y29uY2F0XCJdID0gRnVuY3Rpb25zLmNvbmNhdDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9c3RhcnRzLXdpdGhcIl0gPSBGdW5jdGlvbnMuc3RhcnRzV2l0aDtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y29udGFpbnNcIl0gPSBGdW5jdGlvbnMuY29udGFpbnM7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN1YnN0cmluZy1iZWZvcmVcIl0gPSBGdW5jdGlvbnMuc3Vic3RyaW5nQmVmb3JlO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdWJzdHJpbmctYWZ0ZXJcIl0gPSBGdW5jdGlvbnMuc3Vic3RyaW5nQWZ0ZXI7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN1YnN0cmluZ1wiXSA9IEZ1bmN0aW9ucy5zdWJzdHJpbmc7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXN0cmluZy1sZW5ndGhcIl0gPSBGdW5jdGlvbnMuc3RyaW5nTGVuZ3RoO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31ub3JtYWxpemUtc3BhY2VcIl0gPSBGdW5jdGlvbnMubm9ybWFsaXplU3BhY2U7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXRyYW5zbGF0ZVwiXSA9IEZ1bmN0aW9ucy50cmFuc2xhdGU7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWJvb2xlYW5cIl0gPSBGdW5jdGlvbnMuYm9vbGVhbl87XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fW5vdFwiXSA9IEZ1bmN0aW9ucy5ub3Q7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fXRydWVcIl0gPSBGdW5jdGlvbnMudHJ1ZV87XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7fWZhbHNlXCJdID0gRnVuY3Rpb25zLmZhbHNlXztcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9bGFuZ1wiXSA9IEZ1bmN0aW9ucy5sYW5nO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31udW1iZXJcIl0gPSBGdW5jdGlvbnMubnVtYmVyO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31zdW1cIl0gPSBGdW5jdGlvbnMuc3VtO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31mbG9vclwiXSA9IEZ1bmN0aW9ucy5mbG9vcjtcclxuXHR0aGlzLmZ1bmN0aW9uc1tcInt9Y2VpbGluZ1wiXSA9IEZ1bmN0aW9ucy5jZWlsaW5nO1xyXG5cdHRoaXMuZnVuY3Rpb25zW1wie31yb3VuZFwiXSA9IEZ1bmN0aW9ucy5yb3VuZDtcclxufTtcclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmFkZEZ1bmN0aW9uID0gZnVuY3Rpb24obnMsIGxuLCBmKSB7XHJcblx0dGhpcy5mdW5jdGlvbnNbXCJ7XCIgKyBucyArIFwifVwiICsgbG5dID0gZjtcclxufTtcclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmdldEZ1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGMpIHtcclxuXHR2YXIgcGFydHMgPSBVdGlsaXRpZXMucmVzb2x2ZVFOYW1lKGZuLCBjLm5hbWVzcGFjZVJlc29sdmVyLCBjLmNvbnRleHROb2RlLCBmYWxzZSk7XHJcbiAgICBpZiAocGFydHNbMF0gPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIFFOYW1lIFwiICsgZm4pO1xyXG4gICAgfVxyXG5cdHJldHVybiB0aGlzLmdldEZ1bmN0aW9uV2l0aE5hbWUocGFydHNbMF0sIHBhcnRzWzFdLCBjLmNvbnRleHROb2RlKTtcclxufTtcclxuXHJcbkZ1bmN0aW9uUmVzb2x2ZXIucHJvdG90eXBlLmdldEZ1bmN0aW9uV2l0aE5hbWUgPSBmdW5jdGlvbihucywgbG4sIGMpIHtcclxuXHRyZXR1cm4gdGhpcy5mdW5jdGlvbnNbXCJ7XCIgKyBucyArIFwifVwiICsgbG5dO1xyXG59O1xyXG5cclxuLy8gTmFtZXNwYWNlUmVzb2x2ZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5OYW1lc3BhY2VSZXNvbHZlci5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KCk7XHJcbk5hbWVzcGFjZVJlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5hbWVzcGFjZVJlc29sdmVyO1xyXG5OYW1lc3BhY2VSZXNvbHZlci5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIE5hbWVzcGFjZVJlc29sdmVyKCkge1xyXG59XHJcblxyXG5OYW1lc3BhY2VSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24ocHJlZml4LCBuKSB7XHJcblx0aWYgKHByZWZpeCA9PSBcInhtbFwiKSB7XHJcblx0XHRyZXR1cm4gWFBhdGguWE1MX05BTUVTUEFDRV9VUkk7XHJcblx0fSBlbHNlIGlmIChwcmVmaXggPT0gXCJ4bWxuc1wiKSB7XHJcblx0XHRyZXR1cm4gWFBhdGguWE1MTlNfTkFNRVNQQUNFX1VSSTtcclxuXHR9XHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovKSB7XHJcblx0XHRuID0gbi5kb2N1bWVudEVsZW1lbnQ7XHJcblx0fSBlbHNlIGlmIChuLm5vZGVUeXBlID09IDIgLypOb2RlLkFUVFJJQlVURV9OT0RFKi8pIHtcclxuXHRcdG4gPSBQYXRoRXhwci5wcm90b3R5cGUuZ2V0T3duZXJFbGVtZW50KG4pO1xyXG5cdH0gZWxzZSBpZiAobi5ub2RlVHlwZSAhPSAxIC8qTm9kZS5FTEVNRU5UX05PREUqLykge1xyXG5cdFx0biA9IG4ucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0d2hpbGUgKG4gIT0gbnVsbCAmJiBuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHR2YXIgbm5tID0gbi5hdHRyaWJ1dGVzO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBubm0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGEgPSBubm0uaXRlbShpKTtcclxuXHRcdFx0dmFyIGFuYW1lID0gYS5ub2RlTmFtZTtcclxuXHRcdFx0aWYgKGFuYW1lID09IFwieG1sbnNcIiAmJiBwcmVmaXggPT0gXCJcIlxyXG5cdFx0XHRcdFx0fHwgYW5hbWUgPT0gXCJ4bWxuczpcIiArIHByZWZpeCkge1xyXG5cdFx0XHRcdHJldHVybiBTdHJpbmcoYS5ub2RlVmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRuID0gbi5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIEZ1bmN0aW9ucyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuRnVuY3Rpb25zID0gbmV3IE9iamVjdCgpO1xyXG5cclxuRnVuY3Rpb25zLmxhc3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBsYXN0IGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihjLmNvbnRleHRTaXplKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHBvc2l0aW9uIGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihjLmNvbnRleHRQb3NpdGlvbik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuY291bnQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbnM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMiB8fCAhVXRpbGl0aWVzLmluc3RhbmNlX29mKG5zID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLCBYTm9kZVNldCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNvdW50IGV4cGVjdHMgKG5vZGUtc2V0KVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYTnVtYmVyKG5zLnNpemUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmlkID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIGlkO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlkIGV4cGVjdHMgKG9iamVjdClcIik7XHJcblx0fVxyXG5cdGlkID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpO1xyXG5cdGlmIChVdGlsaXRpZXMuaW5zdGFuY2Vfb2YoaWQsIFhOb2RlU2V0KSkge1xyXG5cdFx0aWQgPSBpZC50b0FycmF5KCkuam9pbihcIiBcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlkID0gaWQuc3RyaW5nVmFsdWUoKTtcclxuXHR9XHJcblx0dmFyIGlkcyA9IGlkLnNwbGl0KC9bXFx4MGRcXHgwYVxceDA5XFx4MjBdKy8pO1xyXG5cdHZhciBjb3VudCA9IDA7XHJcblx0dmFyIG5zID0gbmV3IFhOb2RlU2V0KCk7XHJcblx0dmFyIGRvYyA9IGMuY29udGV4dE5vZGUubm9kZVR5cGUgPT0gOSAvKk5vZGUuRE9DVU1FTlRfTk9ERSovXHJcblx0XHRcdD8gYy5jb250ZXh0Tm9kZVxyXG5cdFx0XHQ6IGMuY29udGV4dE5vZGUub3duZXJEb2N1bWVudDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG47XHJcblx0XHRpZiAoZG9jLmdldEVsZW1lbnRCeUlkKSB7XHJcblx0XHRcdG4gPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWRzW2ldKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG4gPSBVdGlsaXRpZXMuZ2V0RWxlbWVudEJ5SWQoZG9jLCBpZHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG4gIT0gbnVsbCkge1xyXG5cdFx0XHRucy5hZGQobik7XHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBucztcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5sb2NhbE5hbWUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbjtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRuID0gYy5jb250ZXh0Tm9kZTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0biA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5maXJzdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBsb2NhbC1uYW1lIGV4cGVjdHMgKG5vZGUtc2V0PylcIik7XHJcblx0fVxyXG5cdGlmIChuID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubG9jYWxOYW1lID8gbi5sb2NhbE5hbWUgOiBuLmJhc2VOYW1lKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5uYW1lc3BhY2VVUkkgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbjtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRuID0gYy5jb250ZXh0Tm9kZTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0biA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5maXJzdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBuYW1lc3BhY2UtdXJpIGV4cGVjdHMgKG5vZGUtc2V0PylcIik7XHJcblx0fVxyXG5cdGlmIChuID09IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubmFtZXNwYWNlVVJJKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5uYW1lID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIG47XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0biA9IGMuY29udGV4dE5vZGU7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdG4gPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuZmlyc3QoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbmFtZSBleHBlY3RzIChub2RlLXNldD8pXCIpO1xyXG5cdH1cclxuXHRpZiAobiA9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcoXCJcIik7XHJcblx0fVxyXG5cdGlmIChuLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovIHx8IG4ubm9kZVR5cGUgPT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLykge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKG4ubm9kZU5hbWUpO1xyXG5cdH0gZWxzZSBpZiAobi5sb2NhbE5hbWUgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYU3RyaW5nKFwiXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gbmV3IFhTdHJpbmcobi5sb2NhbE5hbWUpO1xyXG5cdH1cclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHRyZXR1cm4gWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUoYy5jb250ZXh0Tm9kZSk7XHJcblx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuXHRcdHJldHVybiBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nKCk7XHJcblx0fVxyXG5cdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN0cmluZyBleHBlY3RzIChvYmplY3Q/KVwiKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5jb25jYXQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNvbmNhdCBleHBlY3RzIChzdHJpbmcsIHN0cmluZywgc3RyaW5nKilcIik7XHJcblx0fVxyXG5cdHZhciBzID0gXCJcIjtcclxuXHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0cyArPSBhcmd1bWVudHNbaV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN0YXJ0c1dpdGggPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdGFydHNXaXRoIGV4cGVjdHMgKHN0cmluZywgc3RyaW5nKVwiKTtcclxuXHR9XHJcblx0dmFyIHMxID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIHMyID0gYXJndW1lbnRzWzJdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihzMS5zdWJzdHJpbmcoMCwgczIubGVuZ3RoKSA9PSBzMik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuY29udGFpbnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBjb250YWlucyBleHBlY3RzIChzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oczEuaW5kZXhPZihzMikgIT0gLTEpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN1YnN0cmluZ0JlZm9yZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDMpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN1YnN0cmluZy1iZWZvcmUgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRyZXR1cm4gbmV3IFhTdHJpbmcoczEuc3Vic3RyaW5nKDAsIHMxLmluZGV4T2YoczIpKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3Vic3RyaW5nQWZ0ZXIgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdWJzdHJpbmctYWZ0ZXIgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcpXCIpO1xyXG5cdH1cclxuXHR2YXIgczEgPSBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHR2YXIgczIgPSBhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykuc3RyaW5nVmFsdWUoKTtcclxuXHRpZiAoczIubGVuZ3RoID09IDApIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhzMSk7XHJcblx0fVxyXG5cdHZhciBpID0gczEuaW5kZXhPZihzMik7XHJcblx0aWYgKGkgPT0gLTEpIHtcclxuXHRcdHJldHVybiBuZXcgWFN0cmluZyhcIlwiKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMxLnN1YnN0cmluZyhpICsgczIubGVuZ3RoKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuc3Vic3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKCEoYXJndW1lbnRzLmxlbmd0aCA9PSAzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gNCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHN1YnN0cmluZyBleHBlY3RzIChzdHJpbmcsIG51bWJlciwgbnVtYmVyPylcIik7XHJcblx0fVxyXG5cdHZhciBzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0dmFyIG4xID0gTWF0aC5yb3VuZChhcmd1bWVudHNbMl0uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkgLSAxO1xyXG5cdHZhciBuMiA9IGFyZ3VtZW50cy5sZW5ndGggPT0gNCA/IG4xICsgTWF0aC5yb3VuZChhcmd1bWVudHNbM10uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkgOiB1bmRlZmluZWQ7XHJcblx0cmV0dXJuIG5ldyBYU3RyaW5nKHMuc3Vic3RyaW5nKG4xLCBuMikpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdHZhciBzO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHRcdHMgPSBYTm9kZVNldC5wcm90b3R5cGUuc3RyaW5nRm9yTm9kZShjLmNvbnRleHROb2RlKTtcclxuXHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0cyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzdHJpbmctbGVuZ3RoIGV4cGVjdHMgKHN0cmluZz8pXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIocy5sZW5ndGgpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLm5vcm1hbGl6ZVNwYWNlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0dmFyIHM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0cyA9IFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKGMuY29udGV4dE5vZGUpO1xyXG5cdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG5vcm1hbGl6ZS1zcGFjZSBleHBlY3RzIChzdHJpbmc/KVwiKTtcclxuXHR9XHJcblx0dmFyIGkgPSAwO1xyXG5cdHZhciBqID0gcy5sZW5ndGggLSAxO1xyXG5cdHdoaWxlIChVdGlsaXRpZXMuaXNTcGFjZShzLmNoYXJDb2RlQXQoaikpKSB7XHJcblx0XHRqLS07XHJcblx0fVxyXG5cdHZhciB0ID0gXCJcIjtcclxuXHR3aGlsZSAoaSA8PSBqICYmIFV0aWxpdGllcy5pc1NwYWNlKHMuY2hhckNvZGVBdChpKSkpIHtcclxuXHRcdGkrKztcclxuXHR9XHJcblx0d2hpbGUgKGkgPD0gaikge1xyXG5cdFx0aWYgKFV0aWxpdGllcy5pc1NwYWNlKHMuY2hhckNvZGVBdChpKSkpIHtcclxuXHRcdFx0dCArPSBcIiBcIjtcclxuXHRcdFx0d2hpbGUgKGkgPD0gaiAmJiBVdGlsaXRpZXMuaXNTcGFjZShzLmNoYXJDb2RlQXQoaSkpKSB7XHJcblx0XHRcdFx0aSsrO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ICs9IHMuY2hhckF0KGkpO1xyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0KTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy50cmFuc2xhdGUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSA0KSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiB0cmFuc2xhdGUgZXhwZWN0cyAoc3RyaW5nLCBzdHJpbmcsIHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBzMSA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMiA9IGFyZ3VtZW50c1syXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBzMyA9IGFyZ3VtZW50c1szXS5ldmFsdWF0ZShjKS5zdHJpbmdWYWx1ZSgpO1xyXG5cdHZhciBtYXAgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHMyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaiA9IHMyLmNoYXJDb2RlQXQoaSk7XHJcblx0XHRpZiAobWFwW2pdID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR2YXIgayA9IGkgPiBzMy5sZW5ndGggPyBcIlwiIDogczMuY2hhckF0KGkpO1xyXG5cdFx0XHRtYXBbal0gPSBrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgdCA9IFwiXCI7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzMS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGMgPSBzMS5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0dmFyIHIgPSBtYXBbY107XHJcblx0XHRpZiAociA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dCArPSBzMS5jaGFyQXQoaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ICs9IHI7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWFN0cmluZyh0KTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5ib29sZWFuXyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGJvb2xlYW4gZXhwZWN0cyAob2JqZWN0KVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5ib29sKCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubm90ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gbm90IGV4cGVjdHMgKG9iamVjdClcIik7XHJcblx0fVxyXG5cdHJldHVybiBhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykuYm9vbCgpLm5vdCgpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLnRydWVfID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gdHJ1ZSBleHBlY3RzICgpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhCb29sZWFuKHRydWUpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmZhbHNlXyA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGZhbHNlIGV4cGVjdHMgKClcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWEJvb2xlYW4oZmFsc2UpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmxhbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBsYW5nIGV4cGVjdHMgKHN0cmluZylcIik7XHJcblx0fVxyXG5cdHZhciBsYW5nO1xyXG5cdGZvciAodmFyIG4gPSBjLmNvbnRleHROb2RlOyBuICE9IG51bGwgJiYgbi5ub2RlVHlwZSAhPSA5IC8qTm9kZS5ET0NVTUVOVF9OT0RFKi87IG4gPSBuLnBhcmVudE5vZGUpIHtcclxuXHRcdHZhciBhID0gbi5nZXRBdHRyaWJ1dGVOUyhYUGF0aC5YTUxfTkFNRVNQQUNFX1VSSSwgXCJsYW5nXCIpO1xyXG5cdFx0aWYgKGEgIT0gbnVsbCkge1xyXG5cdFx0XHRsYW5nID0gU3RyaW5nKGEpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhbmcgPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBYQm9vbGVhbihmYWxzZSk7XHJcblx0fVxyXG5cdHZhciBzID0gYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLnN0cmluZ1ZhbHVlKCk7XHJcblx0cmV0dXJuIG5ldyBYQm9vbGVhbihsYW5nLnN1YnN0cmluZygwLCBzLmxlbmd0aCkgPT0gc1xyXG5cdFx0XHRcdCYmIChsYW5nLmxlbmd0aCA9PSBzLmxlbmd0aCB8fCBsYW5nLmNoYXJBdChzLmxlbmd0aCkgPT0gJy0nKSk7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMubnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGMgPSBhcmd1bWVudHNbMF07XHJcblx0aWYgKCEoYXJndW1lbnRzLmxlbmd0aCA9PSAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMikpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIG51bWJlciBleHBlY3RzIChvYmplY3Q/KVwiKTtcclxuXHR9XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0cmV0dXJuIG5ldyBYTnVtYmVyKFhOb2RlU2V0LnByb3RvdHlwZS5zdHJpbmdGb3JOb2RlKGMuY29udGV4dE5vZGUpKTtcclxuXHR9XHJcblx0cmV0dXJuIGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5udW1iZXIoKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5zdW0gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHR2YXIgbnM7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMiB8fCAhVXRpbGl0aWVzLmluc3RhbmNlX29mKChucyA9IGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKSksIFhOb2RlU2V0KSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc3VtIGV4cGVjdHMgKG5vZGUtc2V0KVwiKTtcclxuXHR9XHJcblx0bnMgPSBucy50b0FycmF5KCk7XHJcblx0dmFyIG4gPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdG4gKz0gbmV3IFhOdW1iZXIoWE5vZGVTZXQucHJvdG90eXBlLnN0cmluZ0Zvck5vZGUobnNbaV0pKS5udW1iZXJWYWx1ZSgpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIobik7XHJcbn07XHJcblxyXG5GdW5jdGlvbnMuZmxvb3IgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBmbG9vciBleHBlY3RzIChudW1iZXIpXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFhOdW1iZXIoTWF0aC5mbG9vcihhcmd1bWVudHNbMV0uZXZhbHVhdGUoYykubnVtYmVyVmFsdWUoKSkpO1xyXG59O1xyXG5cclxuRnVuY3Rpb25zLmNlaWxpbmcgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYyA9IGFyZ3VtZW50c1swXTtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBjZWlsaW5nIGV4cGVjdHMgKG51bWJlcilcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihNYXRoLmNlaWwoYXJndW1lbnRzWzFdLmV2YWx1YXRlKGMpLm51bWJlclZhbHVlKCkpKTtcclxufTtcclxuXHJcbkZ1bmN0aW9ucy5yb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjID0gYXJndW1lbnRzWzBdO1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHJvdW5kIGV4cGVjdHMgKG51bWJlcilcIik7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgWE51bWJlcihNYXRoLnJvdW5kKGFyZ3VtZW50c1sxXS5ldmFsdWF0ZShjKS5udW1iZXJWYWx1ZSgpKSk7XHJcbn07XHJcblxyXG4vLyBVdGlsaXRpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblV0aWxpdGllcyA9IG5ldyBPYmplY3QoKTtcclxuXHJcblV0aWxpdGllcy5zcGxpdFFOYW1lID0gZnVuY3Rpb24ocW4pIHtcclxuXHR2YXIgaSA9IHFuLmluZGV4T2YoXCI6XCIpO1xyXG5cdGlmIChpID09IC0xKSB7XHJcblx0XHRyZXR1cm4gWyBudWxsLCBxbiBdO1xyXG5cdH1cclxuXHRyZXR1cm4gWyBxbi5zdWJzdHJpbmcoMCwgaSksIHFuLnN1YnN0cmluZyhpICsgMSkgXTtcclxufTtcclxuXHJcblV0aWxpdGllcy5yZXNvbHZlUU5hbWUgPSBmdW5jdGlvbihxbiwgbnIsIG4sIHVzZURlZmF1bHQpIHtcclxuXHR2YXIgcGFydHMgPSBVdGlsaXRpZXMuc3BsaXRRTmFtZShxbik7XHJcblx0aWYgKHBhcnRzWzBdICE9IG51bGwpIHtcclxuXHRcdHBhcnRzWzBdID0gbnIuZ2V0TmFtZXNwYWNlKHBhcnRzWzBdLCBuKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKHVzZURlZmF1bHQpIHtcclxuXHRcdFx0cGFydHNbMF0gPSBuci5nZXROYW1lc3BhY2UoXCJcIiwgbik7XHJcblx0XHRcdGlmIChwYXJ0c1swXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0cGFydHNbMF0gPSBcIlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYXJ0c1swXSA9IFwiXCI7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBwYXJ0cztcclxufTtcclxuXHJcblV0aWxpdGllcy5pc1NwYWNlID0gZnVuY3Rpb24oYykge1xyXG5cdHJldHVybiBjID09IDB4OSB8fCBjID09IDB4ZCB8fCBjID09IDB4YSB8fCBjID09IDB4MjA7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuaXNMZXR0ZXIgPSBmdW5jdGlvbihjKSB7XHJcblx0cmV0dXJuIGMgPj0gMHgwMDQxICYmIGMgPD0gMHgwMDVBIHx8XHJcblx0XHRjID49IDB4MDA2MSAmJiBjIDw9IDB4MDA3QSB8fFxyXG5cdFx0YyA+PSAweDAwQzAgJiYgYyA8PSAweDAwRDYgfHxcclxuXHRcdGMgPj0gMHgwMEQ4ICYmIGMgPD0gMHgwMEY2IHx8XHJcblx0XHRjID49IDB4MDBGOCAmJiBjIDw9IDB4MDBGRiB8fFxyXG5cdFx0YyA+PSAweDAxMDAgJiYgYyA8PSAweDAxMzEgfHxcclxuXHRcdGMgPj0gMHgwMTM0ICYmIGMgPD0gMHgwMTNFIHx8XHJcblx0XHRjID49IDB4MDE0MSAmJiBjIDw9IDB4MDE0OCB8fFxyXG5cdFx0YyA+PSAweDAxNEEgJiYgYyA8PSAweDAxN0UgfHxcclxuXHRcdGMgPj0gMHgwMTgwICYmIGMgPD0gMHgwMUMzIHx8XHJcblx0XHRjID49IDB4MDFDRCAmJiBjIDw9IDB4MDFGMCB8fFxyXG5cdFx0YyA+PSAweDAxRjQgJiYgYyA8PSAweDAxRjUgfHxcclxuXHRcdGMgPj0gMHgwMUZBICYmIGMgPD0gMHgwMjE3IHx8XHJcblx0XHRjID49IDB4MDI1MCAmJiBjIDw9IDB4MDJBOCB8fFxyXG5cdFx0YyA+PSAweDAyQkIgJiYgYyA8PSAweDAyQzEgfHxcclxuXHRcdGMgPT0gMHgwMzg2IHx8XHJcblx0XHRjID49IDB4MDM4OCAmJiBjIDw9IDB4MDM4QSB8fFxyXG5cdFx0YyA9PSAweDAzOEMgfHxcclxuXHRcdGMgPj0gMHgwMzhFICYmIGMgPD0gMHgwM0ExIHx8XHJcblx0XHRjID49IDB4MDNBMyAmJiBjIDw9IDB4MDNDRSB8fFxyXG5cdFx0YyA+PSAweDAzRDAgJiYgYyA8PSAweDAzRDYgfHxcclxuXHRcdGMgPT0gMHgwM0RBIHx8XHJcblx0XHRjID09IDB4MDNEQyB8fFxyXG5cdFx0YyA9PSAweDAzREUgfHxcclxuXHRcdGMgPT0gMHgwM0UwIHx8XHJcblx0XHRjID49IDB4MDNFMiAmJiBjIDw9IDB4MDNGMyB8fFxyXG5cdFx0YyA+PSAweDA0MDEgJiYgYyA8PSAweDA0MEMgfHxcclxuXHRcdGMgPj0gMHgwNDBFICYmIGMgPD0gMHgwNDRGIHx8XHJcblx0XHRjID49IDB4MDQ1MSAmJiBjIDw9IDB4MDQ1QyB8fFxyXG5cdFx0YyA+PSAweDA0NUUgJiYgYyA8PSAweDA0ODEgfHxcclxuXHRcdGMgPj0gMHgwNDkwICYmIGMgPD0gMHgwNEM0IHx8XHJcblx0XHRjID49IDB4MDRDNyAmJiBjIDw9IDB4MDRDOCB8fFxyXG5cdFx0YyA+PSAweDA0Q0IgJiYgYyA8PSAweDA0Q0MgfHxcclxuXHRcdGMgPj0gMHgwNEQwICYmIGMgPD0gMHgwNEVCIHx8XHJcblx0XHRjID49IDB4MDRFRSAmJiBjIDw9IDB4MDRGNSB8fFxyXG5cdFx0YyA+PSAweDA0RjggJiYgYyA8PSAweDA0RjkgfHxcclxuXHRcdGMgPj0gMHgwNTMxICYmIGMgPD0gMHgwNTU2IHx8XHJcblx0XHRjID09IDB4MDU1OSB8fFxyXG5cdFx0YyA+PSAweDA1NjEgJiYgYyA8PSAweDA1ODYgfHxcclxuXHRcdGMgPj0gMHgwNUQwICYmIGMgPD0gMHgwNUVBIHx8XHJcblx0XHRjID49IDB4MDVGMCAmJiBjIDw9IDB4MDVGMiB8fFxyXG5cdFx0YyA+PSAweDA2MjEgJiYgYyA8PSAweDA2M0EgfHxcclxuXHRcdGMgPj0gMHgwNjQxICYmIGMgPD0gMHgwNjRBIHx8XHJcblx0XHRjID49IDB4MDY3MSAmJiBjIDw9IDB4MDZCNyB8fFxyXG5cdFx0YyA+PSAweDA2QkEgJiYgYyA8PSAweDA2QkUgfHxcclxuXHRcdGMgPj0gMHgwNkMwICYmIGMgPD0gMHgwNkNFIHx8XHJcblx0XHRjID49IDB4MDZEMCAmJiBjIDw9IDB4MDZEMyB8fFxyXG5cdFx0YyA9PSAweDA2RDUgfHxcclxuXHRcdGMgPj0gMHgwNkU1ICYmIGMgPD0gMHgwNkU2IHx8XHJcblx0XHRjID49IDB4MDkwNSAmJiBjIDw9IDB4MDkzOSB8fFxyXG5cdFx0YyA9PSAweDA5M0QgfHxcclxuXHRcdGMgPj0gMHgwOTU4ICYmIGMgPD0gMHgwOTYxIHx8XHJcblx0XHRjID49IDB4MDk4NSAmJiBjIDw9IDB4MDk4QyB8fFxyXG5cdFx0YyA+PSAweDA5OEYgJiYgYyA8PSAweDA5OTAgfHxcclxuXHRcdGMgPj0gMHgwOTkzICYmIGMgPD0gMHgwOUE4IHx8XHJcblx0XHRjID49IDB4MDlBQSAmJiBjIDw9IDB4MDlCMCB8fFxyXG5cdFx0YyA9PSAweDA5QjIgfHxcclxuXHRcdGMgPj0gMHgwOUI2ICYmIGMgPD0gMHgwOUI5IHx8XHJcblx0XHRjID49IDB4MDlEQyAmJiBjIDw9IDB4MDlERCB8fFxyXG5cdFx0YyA+PSAweDA5REYgJiYgYyA8PSAweDA5RTEgfHxcclxuXHRcdGMgPj0gMHgwOUYwICYmIGMgPD0gMHgwOUYxIHx8XHJcblx0XHRjID49IDB4MEEwNSAmJiBjIDw9IDB4MEEwQSB8fFxyXG5cdFx0YyA+PSAweDBBMEYgJiYgYyA8PSAweDBBMTAgfHxcclxuXHRcdGMgPj0gMHgwQTEzICYmIGMgPD0gMHgwQTI4IHx8XHJcblx0XHRjID49IDB4MEEyQSAmJiBjIDw9IDB4MEEzMCB8fFxyXG5cdFx0YyA+PSAweDBBMzIgJiYgYyA8PSAweDBBMzMgfHxcclxuXHRcdGMgPj0gMHgwQTM1ICYmIGMgPD0gMHgwQTM2IHx8XHJcblx0XHRjID49IDB4MEEzOCAmJiBjIDw9IDB4MEEzOSB8fFxyXG5cdFx0YyA+PSAweDBBNTkgJiYgYyA8PSAweDBBNUMgfHxcclxuXHRcdGMgPT0gMHgwQTVFIHx8XHJcblx0XHRjID49IDB4MEE3MiAmJiBjIDw9IDB4MEE3NCB8fFxyXG5cdFx0YyA+PSAweDBBODUgJiYgYyA8PSAweDBBOEIgfHxcclxuXHRcdGMgPT0gMHgwQThEIHx8XHJcblx0XHRjID49IDB4MEE4RiAmJiBjIDw9IDB4MEE5MSB8fFxyXG5cdFx0YyA+PSAweDBBOTMgJiYgYyA8PSAweDBBQTggfHxcclxuXHRcdGMgPj0gMHgwQUFBICYmIGMgPD0gMHgwQUIwIHx8XHJcblx0XHRjID49IDB4MEFCMiAmJiBjIDw9IDB4MEFCMyB8fFxyXG5cdFx0YyA+PSAweDBBQjUgJiYgYyA8PSAweDBBQjkgfHxcclxuXHRcdGMgPT0gMHgwQUJEIHx8XHJcblx0XHRjID09IDB4MEFFMCB8fFxyXG5cdFx0YyA+PSAweDBCMDUgJiYgYyA8PSAweDBCMEMgfHxcclxuXHRcdGMgPj0gMHgwQjBGICYmIGMgPD0gMHgwQjEwIHx8XHJcblx0XHRjID49IDB4MEIxMyAmJiBjIDw9IDB4MEIyOCB8fFxyXG5cdFx0YyA+PSAweDBCMkEgJiYgYyA8PSAweDBCMzAgfHxcclxuXHRcdGMgPj0gMHgwQjMyICYmIGMgPD0gMHgwQjMzIHx8XHJcblx0XHRjID49IDB4MEIzNiAmJiBjIDw9IDB4MEIzOSB8fFxyXG5cdFx0YyA9PSAweDBCM0QgfHxcclxuXHRcdGMgPj0gMHgwQjVDICYmIGMgPD0gMHgwQjVEIHx8XHJcblx0XHRjID49IDB4MEI1RiAmJiBjIDw9IDB4MEI2MSB8fFxyXG5cdFx0YyA+PSAweDBCODUgJiYgYyA8PSAweDBCOEEgfHxcclxuXHRcdGMgPj0gMHgwQjhFICYmIGMgPD0gMHgwQjkwIHx8XHJcblx0XHRjID49IDB4MEI5MiAmJiBjIDw9IDB4MEI5NSB8fFxyXG5cdFx0YyA+PSAweDBCOTkgJiYgYyA8PSAweDBCOUEgfHxcclxuXHRcdGMgPT0gMHgwQjlDIHx8XHJcblx0XHRjID49IDB4MEI5RSAmJiBjIDw9IDB4MEI5RiB8fFxyXG5cdFx0YyA+PSAweDBCQTMgJiYgYyA8PSAweDBCQTQgfHxcclxuXHRcdGMgPj0gMHgwQkE4ICYmIGMgPD0gMHgwQkFBIHx8XHJcblx0XHRjID49IDB4MEJBRSAmJiBjIDw9IDB4MEJCNSB8fFxyXG5cdFx0YyA+PSAweDBCQjcgJiYgYyA8PSAweDBCQjkgfHxcclxuXHRcdGMgPj0gMHgwQzA1ICYmIGMgPD0gMHgwQzBDIHx8XHJcblx0XHRjID49IDB4MEMwRSAmJiBjIDw9IDB4MEMxMCB8fFxyXG5cdFx0YyA+PSAweDBDMTIgJiYgYyA8PSAweDBDMjggfHxcclxuXHRcdGMgPj0gMHgwQzJBICYmIGMgPD0gMHgwQzMzIHx8XHJcblx0XHRjID49IDB4MEMzNSAmJiBjIDw9IDB4MEMzOSB8fFxyXG5cdFx0YyA+PSAweDBDNjAgJiYgYyA8PSAweDBDNjEgfHxcclxuXHRcdGMgPj0gMHgwQzg1ICYmIGMgPD0gMHgwQzhDIHx8XHJcblx0XHRjID49IDB4MEM4RSAmJiBjIDw9IDB4MEM5MCB8fFxyXG5cdFx0YyA+PSAweDBDOTIgJiYgYyA8PSAweDBDQTggfHxcclxuXHRcdGMgPj0gMHgwQ0FBICYmIGMgPD0gMHgwQ0IzIHx8XHJcblx0XHRjID49IDB4MENCNSAmJiBjIDw9IDB4MENCOSB8fFxyXG5cdFx0YyA9PSAweDBDREUgfHxcclxuXHRcdGMgPj0gMHgwQ0UwICYmIGMgPD0gMHgwQ0UxIHx8XHJcblx0XHRjID49IDB4MEQwNSAmJiBjIDw9IDB4MEQwQyB8fFxyXG5cdFx0YyA+PSAweDBEMEUgJiYgYyA8PSAweDBEMTAgfHxcclxuXHRcdGMgPj0gMHgwRDEyICYmIGMgPD0gMHgwRDI4IHx8XHJcblx0XHRjID49IDB4MEQyQSAmJiBjIDw9IDB4MEQzOSB8fFxyXG5cdFx0YyA+PSAweDBENjAgJiYgYyA8PSAweDBENjEgfHxcclxuXHRcdGMgPj0gMHgwRTAxICYmIGMgPD0gMHgwRTJFIHx8XHJcblx0XHRjID09IDB4MEUzMCB8fFxyXG5cdFx0YyA+PSAweDBFMzIgJiYgYyA8PSAweDBFMzMgfHxcclxuXHRcdGMgPj0gMHgwRTQwICYmIGMgPD0gMHgwRTQ1IHx8XHJcblx0XHRjID49IDB4MEU4MSAmJiBjIDw9IDB4MEU4MiB8fFxyXG5cdFx0YyA9PSAweDBFODQgfHxcclxuXHRcdGMgPj0gMHgwRTg3ICYmIGMgPD0gMHgwRTg4IHx8XHJcblx0XHRjID09IDB4MEU4QSB8fFxyXG5cdFx0YyA9PSAweDBFOEQgfHxcclxuXHRcdGMgPj0gMHgwRTk0ICYmIGMgPD0gMHgwRTk3IHx8XHJcblx0XHRjID49IDB4MEU5OSAmJiBjIDw9IDB4MEU5RiB8fFxyXG5cdFx0YyA+PSAweDBFQTEgJiYgYyA8PSAweDBFQTMgfHxcclxuXHRcdGMgPT0gMHgwRUE1IHx8XHJcblx0XHRjID09IDB4MEVBNyB8fFxyXG5cdFx0YyA+PSAweDBFQUEgJiYgYyA8PSAweDBFQUIgfHxcclxuXHRcdGMgPj0gMHgwRUFEICYmIGMgPD0gMHgwRUFFIHx8XHJcblx0XHRjID09IDB4MEVCMCB8fFxyXG5cdFx0YyA+PSAweDBFQjIgJiYgYyA8PSAweDBFQjMgfHxcclxuXHRcdGMgPT0gMHgwRUJEIHx8XHJcblx0XHRjID49IDB4MEVDMCAmJiBjIDw9IDB4MEVDNCB8fFxyXG5cdFx0YyA+PSAweDBGNDAgJiYgYyA8PSAweDBGNDcgfHxcclxuXHRcdGMgPj0gMHgwRjQ5ICYmIGMgPD0gMHgwRjY5IHx8XHJcblx0XHRjID49IDB4MTBBMCAmJiBjIDw9IDB4MTBDNSB8fFxyXG5cdFx0YyA+PSAweDEwRDAgJiYgYyA8PSAweDEwRjYgfHxcclxuXHRcdGMgPT0gMHgxMTAwIHx8XHJcblx0XHRjID49IDB4MTEwMiAmJiBjIDw9IDB4MTEwMyB8fFxyXG5cdFx0YyA+PSAweDExMDUgJiYgYyA8PSAweDExMDcgfHxcclxuXHRcdGMgPT0gMHgxMTA5IHx8XHJcblx0XHRjID49IDB4MTEwQiAmJiBjIDw9IDB4MTEwQyB8fFxyXG5cdFx0YyA+PSAweDExMEUgJiYgYyA8PSAweDExMTIgfHxcclxuXHRcdGMgPT0gMHgxMTNDIHx8XHJcblx0XHRjID09IDB4MTEzRSB8fFxyXG5cdFx0YyA9PSAweDExNDAgfHxcclxuXHRcdGMgPT0gMHgxMTRDIHx8XHJcblx0XHRjID09IDB4MTE0RSB8fFxyXG5cdFx0YyA9PSAweDExNTAgfHxcclxuXHRcdGMgPj0gMHgxMTU0ICYmIGMgPD0gMHgxMTU1IHx8XHJcblx0XHRjID09IDB4MTE1OSB8fFxyXG5cdFx0YyA+PSAweDExNUYgJiYgYyA8PSAweDExNjEgfHxcclxuXHRcdGMgPT0gMHgxMTYzIHx8XHJcblx0XHRjID09IDB4MTE2NSB8fFxyXG5cdFx0YyA9PSAweDExNjcgfHxcclxuXHRcdGMgPT0gMHgxMTY5IHx8XHJcblx0XHRjID49IDB4MTE2RCAmJiBjIDw9IDB4MTE2RSB8fFxyXG5cdFx0YyA+PSAweDExNzIgJiYgYyA8PSAweDExNzMgfHxcclxuXHRcdGMgPT0gMHgxMTc1IHx8XHJcblx0XHRjID09IDB4MTE5RSB8fFxyXG5cdFx0YyA9PSAweDExQTggfHxcclxuXHRcdGMgPT0gMHgxMUFCIHx8XHJcblx0XHRjID49IDB4MTFBRSAmJiBjIDw9IDB4MTFBRiB8fFxyXG5cdFx0YyA+PSAweDExQjcgJiYgYyA8PSAweDExQjggfHxcclxuXHRcdGMgPT0gMHgxMUJBIHx8XHJcblx0XHRjID49IDB4MTFCQyAmJiBjIDw9IDB4MTFDMiB8fFxyXG5cdFx0YyA9PSAweDExRUIgfHxcclxuXHRcdGMgPT0gMHgxMUYwIHx8XHJcblx0XHRjID09IDB4MTFGOSB8fFxyXG5cdFx0YyA+PSAweDFFMDAgJiYgYyA8PSAweDFFOUIgfHxcclxuXHRcdGMgPj0gMHgxRUEwICYmIGMgPD0gMHgxRUY5IHx8XHJcblx0XHRjID49IDB4MUYwMCAmJiBjIDw9IDB4MUYxNSB8fFxyXG5cdFx0YyA+PSAweDFGMTggJiYgYyA8PSAweDFGMUQgfHxcclxuXHRcdGMgPj0gMHgxRjIwICYmIGMgPD0gMHgxRjQ1IHx8XHJcblx0XHRjID49IDB4MUY0OCAmJiBjIDw9IDB4MUY0RCB8fFxyXG5cdFx0YyA+PSAweDFGNTAgJiYgYyA8PSAweDFGNTcgfHxcclxuXHRcdGMgPT0gMHgxRjU5IHx8XHJcblx0XHRjID09IDB4MUY1QiB8fFxyXG5cdFx0YyA9PSAweDFGNUQgfHxcclxuXHRcdGMgPj0gMHgxRjVGICYmIGMgPD0gMHgxRjdEIHx8XHJcblx0XHRjID49IDB4MUY4MCAmJiBjIDw9IDB4MUZCNCB8fFxyXG5cdFx0YyA+PSAweDFGQjYgJiYgYyA8PSAweDFGQkMgfHxcclxuXHRcdGMgPT0gMHgxRkJFIHx8XHJcblx0XHRjID49IDB4MUZDMiAmJiBjIDw9IDB4MUZDNCB8fFxyXG5cdFx0YyA+PSAweDFGQzYgJiYgYyA8PSAweDFGQ0MgfHxcclxuXHRcdGMgPj0gMHgxRkQwICYmIGMgPD0gMHgxRkQzIHx8XHJcblx0XHRjID49IDB4MUZENiAmJiBjIDw9IDB4MUZEQiB8fFxyXG5cdFx0YyA+PSAweDFGRTAgJiYgYyA8PSAweDFGRUMgfHxcclxuXHRcdGMgPj0gMHgxRkYyICYmIGMgPD0gMHgxRkY0IHx8XHJcblx0XHRjID49IDB4MUZGNiAmJiBjIDw9IDB4MUZGQyB8fFxyXG5cdFx0YyA9PSAweDIxMjYgfHxcclxuXHRcdGMgPj0gMHgyMTJBICYmIGMgPD0gMHgyMTJCIHx8XHJcblx0XHRjID09IDB4MjEyRSB8fFxyXG5cdFx0YyA+PSAweDIxODAgJiYgYyA8PSAweDIxODIgfHxcclxuXHRcdGMgPj0gMHgzMDQxICYmIGMgPD0gMHgzMDk0IHx8XHJcblx0XHRjID49IDB4MzBBMSAmJiBjIDw9IDB4MzBGQSB8fFxyXG5cdFx0YyA+PSAweDMxMDUgJiYgYyA8PSAweDMxMkMgfHxcclxuXHRcdGMgPj0gMHhBQzAwICYmIGMgPD0gMHhEN0EzIHx8XHJcblx0XHRjID49IDB4NEUwMCAmJiBjIDw9IDB4OUZBNSB8fFxyXG5cdFx0YyA9PSAweDMwMDcgfHxcclxuXHRcdGMgPj0gMHgzMDIxICYmIGMgPD0gMHgzMDI5O1xyXG59O1xyXG5cclxuVXRpbGl0aWVzLmlzTkNOYW1lQ2hhciA9IGZ1bmN0aW9uKGMpIHtcclxuXHRyZXR1cm4gYyA+PSAweDAwMzAgJiYgYyA8PSAweDAwMzlcclxuXHRcdHx8IGMgPj0gMHgwNjYwICYmIGMgPD0gMHgwNjY5XHJcblx0XHR8fCBjID49IDB4MDZGMCAmJiBjIDw9IDB4MDZGOVxyXG5cdFx0fHwgYyA+PSAweDA5NjYgJiYgYyA8PSAweDA5NkZcclxuXHRcdHx8IGMgPj0gMHgwOUU2ICYmIGMgPD0gMHgwOUVGXHJcblx0XHR8fCBjID49IDB4MEE2NiAmJiBjIDw9IDB4MEE2RlxyXG5cdFx0fHwgYyA+PSAweDBBRTYgJiYgYyA8PSAweDBBRUZcclxuXHRcdHx8IGMgPj0gMHgwQjY2ICYmIGMgPD0gMHgwQjZGXHJcblx0XHR8fCBjID49IDB4MEJFNyAmJiBjIDw9IDB4MEJFRlxyXG5cdFx0fHwgYyA+PSAweDBDNjYgJiYgYyA8PSAweDBDNkZcclxuXHRcdHx8IGMgPj0gMHgwQ0U2ICYmIGMgPD0gMHgwQ0VGXHJcblx0XHR8fCBjID49IDB4MEQ2NiAmJiBjIDw9IDB4MEQ2RlxyXG5cdFx0fHwgYyA+PSAweDBFNTAgJiYgYyA8PSAweDBFNTlcclxuXHRcdHx8IGMgPj0gMHgwRUQwICYmIGMgPD0gMHgwRUQ5XHJcblx0XHR8fCBjID49IDB4MEYyMCAmJiBjIDw9IDB4MEYyOVxyXG5cdFx0fHwgYyA9PSAweDAwMkVcclxuXHRcdHx8IGMgPT0gMHgwMDJEXHJcblx0XHR8fCBjID09IDB4MDA1RlxyXG5cdFx0fHwgVXRpbGl0aWVzLmlzTGV0dGVyKGMpXHJcblx0XHR8fCBjID49IDB4MDMwMCAmJiBjIDw9IDB4MDM0NVxyXG5cdFx0fHwgYyA+PSAweDAzNjAgJiYgYyA8PSAweDAzNjFcclxuXHRcdHx8IGMgPj0gMHgwNDgzICYmIGMgPD0gMHgwNDg2XHJcblx0XHR8fCBjID49IDB4MDU5MSAmJiBjIDw9IDB4MDVBMVxyXG5cdFx0fHwgYyA+PSAweDA1QTMgJiYgYyA8PSAweDA1QjlcclxuXHRcdHx8IGMgPj0gMHgwNUJCICYmIGMgPD0gMHgwNUJEXHJcblx0XHR8fCBjID09IDB4MDVCRlxyXG5cdFx0fHwgYyA+PSAweDA1QzEgJiYgYyA8PSAweDA1QzJcclxuXHRcdHx8IGMgPT0gMHgwNUM0XHJcblx0XHR8fCBjID49IDB4MDY0QiAmJiBjIDw9IDB4MDY1MlxyXG5cdFx0fHwgYyA9PSAweDA2NzBcclxuXHRcdHx8IGMgPj0gMHgwNkQ2ICYmIGMgPD0gMHgwNkRDXHJcblx0XHR8fCBjID49IDB4MDZERCAmJiBjIDw9IDB4MDZERlxyXG5cdFx0fHwgYyA+PSAweDA2RTAgJiYgYyA8PSAweDA2RTRcclxuXHRcdHx8IGMgPj0gMHgwNkU3ICYmIGMgPD0gMHgwNkU4XHJcblx0XHR8fCBjID49IDB4MDZFQSAmJiBjIDw9IDB4MDZFRFxyXG5cdFx0fHwgYyA+PSAweDA5MDEgJiYgYyA8PSAweDA5MDNcclxuXHRcdHx8IGMgPT0gMHgwOTNDXHJcblx0XHR8fCBjID49IDB4MDkzRSAmJiBjIDw9IDB4MDk0Q1xyXG5cdFx0fHwgYyA9PSAweDA5NERcclxuXHRcdHx8IGMgPj0gMHgwOTUxICYmIGMgPD0gMHgwOTU0XHJcblx0XHR8fCBjID49IDB4MDk2MiAmJiBjIDw9IDB4MDk2M1xyXG5cdFx0fHwgYyA+PSAweDA5ODEgJiYgYyA8PSAweDA5ODNcclxuXHRcdHx8IGMgPT0gMHgwOUJDXHJcblx0XHR8fCBjID09IDB4MDlCRVxyXG5cdFx0fHwgYyA9PSAweDA5QkZcclxuXHRcdHx8IGMgPj0gMHgwOUMwICYmIGMgPD0gMHgwOUM0XHJcblx0XHR8fCBjID49IDB4MDlDNyAmJiBjIDw9IDB4MDlDOFxyXG5cdFx0fHwgYyA+PSAweDA5Q0IgJiYgYyA8PSAweDA5Q0RcclxuXHRcdHx8IGMgPT0gMHgwOUQ3XHJcblx0XHR8fCBjID49IDB4MDlFMiAmJiBjIDw9IDB4MDlFM1xyXG5cdFx0fHwgYyA9PSAweDBBMDJcclxuXHRcdHx8IGMgPT0gMHgwQTNDXHJcblx0XHR8fCBjID09IDB4MEEzRVxyXG5cdFx0fHwgYyA9PSAweDBBM0ZcclxuXHRcdHx8IGMgPj0gMHgwQTQwICYmIGMgPD0gMHgwQTQyXHJcblx0XHR8fCBjID49IDB4MEE0NyAmJiBjIDw9IDB4MEE0OFxyXG5cdFx0fHwgYyA+PSAweDBBNEIgJiYgYyA8PSAweDBBNERcclxuXHRcdHx8IGMgPj0gMHgwQTcwICYmIGMgPD0gMHgwQTcxXHJcblx0XHR8fCBjID49IDB4MEE4MSAmJiBjIDw9IDB4MEE4M1xyXG5cdFx0fHwgYyA9PSAweDBBQkNcclxuXHRcdHx8IGMgPj0gMHgwQUJFICYmIGMgPD0gMHgwQUM1XHJcblx0XHR8fCBjID49IDB4MEFDNyAmJiBjIDw9IDB4MEFDOVxyXG5cdFx0fHwgYyA+PSAweDBBQ0IgJiYgYyA8PSAweDBBQ0RcclxuXHRcdHx8IGMgPj0gMHgwQjAxICYmIGMgPD0gMHgwQjAzXHJcblx0XHR8fCBjID09IDB4MEIzQ1xyXG5cdFx0fHwgYyA+PSAweDBCM0UgJiYgYyA8PSAweDBCNDNcclxuXHRcdHx8IGMgPj0gMHgwQjQ3ICYmIGMgPD0gMHgwQjQ4XHJcblx0XHR8fCBjID49IDB4MEI0QiAmJiBjIDw9IDB4MEI0RFxyXG5cdFx0fHwgYyA+PSAweDBCNTYgJiYgYyA8PSAweDBCNTdcclxuXHRcdHx8IGMgPj0gMHgwQjgyICYmIGMgPD0gMHgwQjgzXHJcblx0XHR8fCBjID49IDB4MEJCRSAmJiBjIDw9IDB4MEJDMlxyXG5cdFx0fHwgYyA+PSAweDBCQzYgJiYgYyA8PSAweDBCQzhcclxuXHRcdHx8IGMgPj0gMHgwQkNBICYmIGMgPD0gMHgwQkNEXHJcblx0XHR8fCBjID09IDB4MEJEN1xyXG5cdFx0fHwgYyA+PSAweDBDMDEgJiYgYyA8PSAweDBDMDNcclxuXHRcdHx8IGMgPj0gMHgwQzNFICYmIGMgPD0gMHgwQzQ0XHJcblx0XHR8fCBjID49IDB4MEM0NiAmJiBjIDw9IDB4MEM0OFxyXG5cdFx0fHwgYyA+PSAweDBDNEEgJiYgYyA8PSAweDBDNERcclxuXHRcdHx8IGMgPj0gMHgwQzU1ICYmIGMgPD0gMHgwQzU2XHJcblx0XHR8fCBjID49IDB4MEM4MiAmJiBjIDw9IDB4MEM4M1xyXG5cdFx0fHwgYyA+PSAweDBDQkUgJiYgYyA8PSAweDBDQzRcclxuXHRcdHx8IGMgPj0gMHgwQ0M2ICYmIGMgPD0gMHgwQ0M4XHJcblx0XHR8fCBjID49IDB4MENDQSAmJiBjIDw9IDB4MENDRFxyXG5cdFx0fHwgYyA+PSAweDBDRDUgJiYgYyA8PSAweDBDRDZcclxuXHRcdHx8IGMgPj0gMHgwRDAyICYmIGMgPD0gMHgwRDAzXHJcblx0XHR8fCBjID49IDB4MEQzRSAmJiBjIDw9IDB4MEQ0M1xyXG5cdFx0fHwgYyA+PSAweDBENDYgJiYgYyA8PSAweDBENDhcclxuXHRcdHx8IGMgPj0gMHgwRDRBICYmIGMgPD0gMHgwRDREXHJcblx0XHR8fCBjID09IDB4MEQ1N1xyXG5cdFx0fHwgYyA9PSAweDBFMzFcclxuXHRcdHx8IGMgPj0gMHgwRTM0ICYmIGMgPD0gMHgwRTNBXHJcblx0XHR8fCBjID49IDB4MEU0NyAmJiBjIDw9IDB4MEU0RVxyXG5cdFx0fHwgYyA9PSAweDBFQjFcclxuXHRcdHx8IGMgPj0gMHgwRUI0ICYmIGMgPD0gMHgwRUI5XHJcblx0XHR8fCBjID49IDB4MEVCQiAmJiBjIDw9IDB4MEVCQ1xyXG5cdFx0fHwgYyA+PSAweDBFQzggJiYgYyA8PSAweDBFQ0RcclxuXHRcdHx8IGMgPj0gMHgwRjE4ICYmIGMgPD0gMHgwRjE5XHJcblx0XHR8fCBjID09IDB4MEYzNVxyXG5cdFx0fHwgYyA9PSAweDBGMzdcclxuXHRcdHx8IGMgPT0gMHgwRjM5XHJcblx0XHR8fCBjID09IDB4MEYzRVxyXG5cdFx0fHwgYyA9PSAweDBGM0ZcclxuXHRcdHx8IGMgPj0gMHgwRjcxICYmIGMgPD0gMHgwRjg0XHJcblx0XHR8fCBjID49IDB4MEY4NiAmJiBjIDw9IDB4MEY4QlxyXG5cdFx0fHwgYyA+PSAweDBGOTAgJiYgYyA8PSAweDBGOTVcclxuXHRcdHx8IGMgPT0gMHgwRjk3XHJcblx0XHR8fCBjID49IDB4MEY5OSAmJiBjIDw9IDB4MEZBRFxyXG5cdFx0fHwgYyA+PSAweDBGQjEgJiYgYyA8PSAweDBGQjdcclxuXHRcdHx8IGMgPT0gMHgwRkI5XHJcblx0XHR8fCBjID49IDB4MjBEMCAmJiBjIDw9IDB4MjBEQ1xyXG5cdFx0fHwgYyA9PSAweDIwRTFcclxuXHRcdHx8IGMgPj0gMHgzMDJBICYmIGMgPD0gMHgzMDJGXHJcblx0XHR8fCBjID09IDB4MzA5OVxyXG5cdFx0fHwgYyA9PSAweDMwOUFcclxuXHRcdHx8IGMgPT0gMHgwMEI3XHJcblx0XHR8fCBjID09IDB4MDJEMFxyXG5cdFx0fHwgYyA9PSAweDAyRDFcclxuXHRcdHx8IGMgPT0gMHgwMzg3XHJcblx0XHR8fCBjID09IDB4MDY0MFxyXG5cdFx0fHwgYyA9PSAweDBFNDZcclxuXHRcdHx8IGMgPT0gMHgwRUM2XHJcblx0XHR8fCBjID09IDB4MzAwNVxyXG5cdFx0fHwgYyA+PSAweDMwMzEgJiYgYyA8PSAweDMwMzVcclxuXHRcdHx8IGMgPj0gMHgzMDlEICYmIGMgPD0gMHgzMDlFXHJcblx0XHR8fCBjID49IDB4MzBGQyAmJiBjIDw9IDB4MzBGRTtcclxufTtcclxuXHJcblV0aWxpdGllcy5jb2FsZXNjZVRleHQgPSBmdW5jdGlvbihuKSB7XHJcblx0Zm9yICh2YXIgbSA9IG4uZmlyc3RDaGlsZDsgbSAhPSBudWxsOyBtID0gbS5uZXh0U2libGluZykge1xyXG5cdFx0aWYgKG0ubm9kZVR5cGUgPT0gMyAvKk5vZGUuVEVYVF9OT0RFKi8gfHwgbS5ub2RlVHlwZSA9PSA0IC8qTm9kZS5DREFUQV9TRUNUSU9OX05PREUqLykge1xyXG5cdFx0XHR2YXIgcyA9IG0ubm9kZVZhbHVlO1xyXG5cdFx0XHR2YXIgZmlyc3QgPSBtO1xyXG5cdFx0XHRtID0gbS5uZXh0U2libGluZztcclxuXHRcdFx0d2hpbGUgKG0gIT0gbnVsbCAmJiAobS5ub2RlVHlwZSA9PSAzIC8qTm9kZS5URVhUX05PREUqLyB8fCBtLm5vZGVUeXBlID09IDQgLypOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSovKSkge1xyXG5cdFx0XHRcdHMgKz0gbS5ub2RlVmFsdWU7XHJcblx0XHRcdFx0dmFyIGRlbCA9IG07XHJcblx0XHRcdFx0bSA9IG0ubmV4dFNpYmxpbmc7XHJcblx0XHRcdFx0ZGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGVsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZmlyc3Qubm9kZVR5cGUgPT0gNCAvKk5vZGUuQ0RBVEFfU0VDVElPTl9OT0RFKi8pIHtcclxuXHRcdFx0XHR2YXIgcCA9IGZpcnN0LnBhcmVudE5vZGU7XHJcblx0XHRcdFx0aWYgKGZpcnN0Lm5leHRTaWJsaW5nID09IG51bGwpIHtcclxuXHRcdFx0XHRcdHAucmVtb3ZlQ2hpbGQoZmlyc3QpO1xyXG5cdFx0XHRcdFx0cC5hcHBlbmRDaGlsZChwLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocykpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgbmV4dCA9IGZpcnN0Lm5leHRTaWJsaW5nO1xyXG5cdFx0XHRcdFx0cC5yZW1vdmVDaGlsZChmaXJzdCk7XHJcblx0XHRcdFx0XHRwLmluc2VydEJlZm9yZShwLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyksIG5leHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmaXJzdC5ub2RlVmFsdWUgPSBzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtID09IG51bGwpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChtLm5vZGVUeXBlID09IDEgLypOb2RlLkVMRU1FTlRfTk9ERSovKSB7XHJcblx0XHRcdFV0aWxpdGllcy5jb2FsZXNjZVRleHQobSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuVXRpbGl0aWVzLmluc3RhbmNlX29mID0gZnVuY3Rpb24obywgYykge1xyXG5cdHdoaWxlIChvICE9IG51bGwpIHtcclxuXHRcdGlmIChvLmNvbnN0cnVjdG9yID09PSBjKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG8gPT09IE9iamVjdCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRvID0gby5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5VdGlsaXRpZXMuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbihuLCBpZCkge1xyXG5cdC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNoZWNrIHRoZSBEVEQgdG8gY2hlY2sgZm9yIGFjdHVhbFxyXG5cdC8vIGF0dHJpYnV0ZXMgb2YgdHlwZSBJRCwgc28gdGhpcyBtYXkgYmUgYSBiaXQgd3JvbmcuXHJcblx0aWYgKG4ubm9kZVR5cGUgPT0gMSAvKk5vZGUuRUxFTUVOVF9OT0RFKi8pIHtcclxuXHRcdGlmIChuLmdldEF0dHJpYnV0ZShcImlkXCIpID09IGlkXHJcblx0XHRcdFx0fHwgbi5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIpID09IGlkKSB7XHJcblx0XHRcdHJldHVybiBuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IgKHZhciBtID0gbi5maXJzdENoaWxkOyBtICE9IG51bGw7IG0gPSBtLm5leHRTaWJsaW5nKSB7XHJcblx0XHR2YXIgcmVzID0gVXRpbGl0aWVzLmdldEVsZW1lbnRCeUlkKG0sIGlkKTtcclxuXHRcdGlmIChyZXMgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIFhQYXRoRXhjZXB0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhFeGNlcHRpb24ucHJvdG90eXBlID0ge307XHJcblhQYXRoRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoRXhjZXB0aW9uO1xyXG5YUGF0aEV4Y2VwdGlvbi5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoRXhjZXB0aW9uKGMsIGUpIHtcclxuXHR0aGlzLmNvZGUgPSBjO1xyXG5cdHRoaXMuZXhjZXB0aW9uID0gZTtcclxufVxyXG5cclxuWFBhdGhFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIG1zZyA9IHRoaXMuZXhjZXB0aW9uID8gXCI6IFwiICsgdGhpcy5leGNlcHRpb24udG9TdHJpbmcoKSA6IFwiXCI7XHJcblx0c3dpdGNoICh0aGlzLmNvZGUpIHtcclxuXHRcdGNhc2UgWFBhdGhFeGNlcHRpb24uSU5WQUxJRF9FWFBSRVNTSU9OX0VSUjpcclxuXHRcdFx0cmV0dXJuIFwiSW52YWxpZCBleHByZXNzaW9uXCIgKyBtc2c7XHJcblx0XHRjYXNlIFhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSOlxyXG5cdFx0XHRyZXR1cm4gXCJUeXBlIGVycm9yXCIgKyBtc2c7XHJcblx0fVxyXG59O1xyXG5cclxuWFBhdGhFeGNlcHRpb24uSU5WQUxJRF9FWFBSRVNTSU9OX0VSUiA9IDUxO1xyXG5YUGF0aEV4Y2VwdGlvbi5UWVBFX0VSUiA9IDUyO1xyXG5cclxuLy8gWFBhdGhFeHByZXNzaW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5YUGF0aEV4cHJlc3Npb24ucHJvdG90eXBlID0ge307XHJcblhQYXRoRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aEV4cHJlc3Npb247XHJcblhQYXRoRXhwcmVzc2lvbi5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoRXhwcmVzc2lvbihlLCByLCBwKSB7XHJcblx0dGhpcy54cGF0aCA9IHAucGFyc2UoZSk7XHJcblx0dGhpcy5jb250ZXh0ID0gbmV3IFhQYXRoQ29udGV4dCgpO1xyXG5cdHRoaXMuY29udGV4dC5uYW1lc3BhY2VSZXNvbHZlciA9IG5ldyBYUGF0aE5TUmVzb2x2ZXJXcmFwcGVyKHIpO1xyXG59XHJcblxyXG5YUGF0aEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24obiwgdCwgcmVzKSB7XHJcblx0dGhpcy5jb250ZXh0LmV4cHJlc3Npb25Db250ZXh0Tm9kZSA9IG47XHJcblx0dmFyIHJlc3VsdCA9IHRoaXMueHBhdGguZXZhbHVhdGUodGhpcy5jb250ZXh0KTtcclxuXHRyZXR1cm4gbmV3IFhQYXRoUmVzdWx0KHJlc3VsdCwgdCk7XHJcbn1cclxuXHJcbi8vIFhQYXRoTlNSZXNvbHZlcldyYXBwZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhOU1Jlc29sdmVyV3JhcHBlci5wcm90b3R5cGUgPSB7fTtcclxuWFBhdGhOU1Jlc29sdmVyV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYUGF0aE5TUmVzb2x2ZXJXcmFwcGVyO1xyXG5YUGF0aE5TUmVzb2x2ZXJXcmFwcGVyLnN1cGVyY2xhc3MgPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gWFBhdGhOU1Jlc29sdmVyV3JhcHBlcihyKSB7XHJcblx0dGhpcy54cGF0aE5TUmVzb2x2ZXIgPSByO1xyXG59XHJcblxyXG5YUGF0aE5TUmVzb2x2ZXJXcmFwcGVyLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbihwcmVmaXgsIG4pIHtcclxuICAgIGlmICh0aGlzLnhwYXRoTlNSZXNvbHZlciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblx0cmV0dXJuIHRoaXMueHBhdGhOU1Jlc29sdmVyLmxvb2t1cE5hbWVzcGFjZVVSSShwcmVmaXgpO1xyXG59O1xyXG5cclxuLy8gTm9kZVhQYXRoTlNSZXNvbHZlciAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5Ob2RlWFBhdGhOU1Jlc29sdmVyLnByb3RvdHlwZSA9IHt9O1xyXG5Ob2RlWFBhdGhOU1Jlc29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vZGVYUGF0aE5TUmVzb2x2ZXI7XHJcbk5vZGVYUGF0aE5TUmVzb2x2ZXIuc3VwZXJjbGFzcyA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBOb2RlWFBhdGhOU1Jlc29sdmVyKG4pIHtcclxuXHR0aGlzLm5vZGUgPSBuO1xyXG5cdHRoaXMubmFtZXNwYWNlUmVzb2x2ZXIgPSBuZXcgTmFtZXNwYWNlUmVzb2x2ZXIoKTtcclxufVxyXG5cclxuTm9kZVhQYXRoTlNSZXNvbHZlci5wcm90b3R5cGUubG9va3VwTmFtZXNwYWNlVVJJID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcblx0cmV0dXJuIHRoaXMubmFtZXNwYWNlUmVzb2x2ZXIuZ2V0TmFtZXNwYWNlKHByZWZpeCwgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbi8vIFhQYXRoUmVzdWx0IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuWFBhdGhSZXN1bHQucHJvdG90eXBlID0ge307XHJcblhQYXRoUmVzdWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhQYXRoUmVzdWx0O1xyXG5YUGF0aFJlc3VsdC5zdXBlcmNsYXNzID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIFhQYXRoUmVzdWx0KHYsIHQpIHtcclxuXHRpZiAodCA9PSBYUGF0aFJlc3VsdC5BTllfVFlQRSkge1xyXG5cdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhTdHJpbmcpIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0LlNUUklOR19UWVBFO1xyXG5cdFx0fSBlbHNlIGlmICh2LmNvbnN0cnVjdG9yID09PSBYTnVtYmVyKSB7XHJcblx0XHRcdHQgPSBYUGF0aFJlc3VsdC5OVU1CRVJfVFlQRTtcclxuXHRcdH0gZWxzZSBpZiAodi5jb25zdHJ1Y3RvciA9PT0gWEJvb2xlYW4pIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRTtcclxuXHRcdH0gZWxzZSBpZiAodi5jb25zdHJ1Y3RvciA9PT0gWE5vZGVTZXQpIHtcclxuXHRcdFx0dCA9IFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU7XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMucmVzdWx0VHlwZSA9IHQ7XHJcblx0c3dpdGNoICh0KSB7XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0Lk5VTUJFUl9UWVBFOlxyXG5cdFx0XHR0aGlzLm51bWJlclZhbHVlID0gdi5udW1iZXJWYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LlNUUklOR19UWVBFOlxyXG5cdFx0XHR0aGlzLnN0cmluZ1ZhbHVlID0gdi5zdHJpbmdWYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRTpcclxuXHRcdFx0dGhpcy5ib29sZWFuVmFsdWUgPSB2LmJvb2xlYW5WYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjYXNlIFhQYXRoUmVzdWx0LkFOWV9VTk9SREVSRURfTk9ERV9UWVBFOlxyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRTpcclxuXHRcdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhOb2RlU2V0KSB7XHJcblx0XHRcdFx0dGhpcy5zaW5nbGVOb2RlVmFsdWUgPSB2LmZpcnN0KCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFOlxyXG5cdFx0Y2FzZSBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRTpcclxuXHRcdFx0aWYgKHYuY29uc3RydWN0b3IgPT09IFhOb2RlU2V0KSB7XHJcblx0XHRcdFx0dGhpcy5pbnZhbGlkSXRlcmF0b3JTdGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMubm9kZXMgPSB2LnRvQXJyYXkoKTtcclxuXHRcdFx0XHR0aGlzLml0ZXJhdG9ySW5kZXggPSAwO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRTpcclxuXHRcdGNhc2UgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU6XHJcblx0XHRcdGlmICh2LmNvbnN0cnVjdG9yID09PSBYTm9kZVNldCkge1xyXG5cdFx0XHRcdHRoaXMubm9kZXMgPSB2LnRvQXJyYXkoKTtcclxuXHRcdFx0XHR0aGlzLnNuYXBzaG90TGVuZ3RoID0gdGhpcy5ub2Rlcy5sZW5ndGg7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uVFlQRV9FUlIpO1xyXG59O1xyXG5cclxuWFBhdGhSZXN1bHQucHJvdG90eXBlLml0ZXJhdGVOZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKHRoaXMucmVzdWx0VHlwZSAhPSBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFXHJcblx0XHRcdCYmIHRoaXMucmVzdWx0VHlwZSAhPSBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSkge1xyXG5cdFx0dGhyb3cgbmV3IFhQYXRoRXhjZXB0aW9uKFhQYXRoRXhjZXB0aW9uLlRZUEVfRVJSKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXMubm9kZXNbdGhpcy5pdGVyYXRvckluZGV4KytdO1xyXG59O1xyXG5cclxuWFBhdGhSZXN1bHQucHJvdG90eXBlLnNuYXBzaG90SXRlbSA9IGZ1bmN0aW9uKGkpIHtcclxuXHRpZiAodGhpcy5yZXN1bHRUeXBlICE9IFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEVcclxuXHRcdFx0JiYgdGhpcy5yZXN1bHRUeXBlICE9IFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFKSB7XHJcblx0XHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uVFlQRV9FUlIpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5ub2Rlc1tpXTtcclxufTtcclxuXHJcblhQYXRoUmVzdWx0LkFOWV9UWVBFID0gMDtcclxuWFBhdGhSZXN1bHQuTlVNQkVSX1RZUEUgPSAxO1xyXG5YUGF0aFJlc3VsdC5TVFJJTkdfVFlQRSA9IDI7XHJcblhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSA9IDM7XHJcblhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUgPSA0O1xyXG5YUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSA9IDU7XHJcblhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUgPSA2O1xyXG5YUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSA9IDc7XHJcblhQYXRoUmVzdWx0LkFOWV9VTk9SREVSRURfTk9ERV9UWVBFID0gODtcclxuWFBhdGhSZXN1bHQuRklSU1RfT1JERVJFRF9OT0RFX1RZUEUgPSA5O1xyXG5cclxuLy8gRE9NIDMgWFBhdGggc3VwcG9ydCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5mdW5jdGlvbiBpbnN0YWxsRE9NM1hQYXRoU3VwcG9ydChkb2MsIHApIHtcclxuXHRkb2MuY3JlYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGUsIHIpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHJldHVybiBuZXcgWFBhdGhFeHByZXNzaW9uKGUsIHIsIHApO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgWFBhdGhFeGNlcHRpb24oWFBhdGhFeGNlcHRpb24uSU5WQUxJRF9FWFBSRVNTSU9OX0VSUiwgZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRkb2MuY3JlYXRlTlNSZXNvbHZlciA9IGZ1bmN0aW9uKG4pIHtcclxuXHRcdHJldHVybiBuZXcgTm9kZVhQYXRoTlNSZXNvbHZlcihuKTtcclxuXHR9O1xyXG5cdGRvYy5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGUsIGNuLCByLCB0LCByZXMpIHtcclxuXHRcdGlmICh0IDwgMCB8fCB0ID4gOSkge1xyXG5cdFx0XHR0aHJvdyB7IGNvZGU6IDAsIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiUmVxdWVzdCB0eXBlIG5vdCBzdXBwb3J0ZWRcIjsgfSB9O1xyXG5cdFx0fVxyXG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlRXhwcmVzc2lvbihlLCByLCBwKS5ldmFsdWF0ZShjbiwgdCwgcmVzKTtcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBJbnN0YWxsIERPTSAzIFhQYXRoIHN1cHBvcnQgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxyXG50cnkge1xyXG5cdHZhciBzaG91bGRJbnN0YWxsID0gdHJ1ZTtcclxuXHR0cnkge1xyXG5cdFx0aWYgKGRvY3VtZW50LmltcGxlbWVudGF0aW9uXHJcblx0XHRcdFx0JiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZVxyXG5cdFx0XHRcdCYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJYUGF0aFwiLCBudWxsKSkge1xyXG5cdFx0XHRzaG91bGRJbnN0YWxsID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHRpZiAoc2hvdWxkSW5zdGFsbCkge1xyXG5cdFx0aW5zdGFsbERPTTNYUGF0aFN1cHBvcnQoZG9jdW1lbnQsIG5ldyBYUGF0aFBhcnNlcigpKTtcclxuXHR9XHJcbn0gY2F0Y2ggKGUpIHtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIGV4cG9ydHMgZm9yIG5vZGUuanNcclxuXHJcbmluc3RhbGxET00zWFBhdGhTdXBwb3J0KGV4cG9ydHMsIG5ldyBYUGF0aFBhcnNlcigpKTtcclxuXHJcbmV4cG9ydHMuWFBhdGhSZXN1bHQgPSBYUGF0aFJlc3VsdDtcclxuXHJcbi8vIGhlbHBlclxyXG5leHBvcnRzLnNlbGVjdCA9IGZ1bmN0aW9uKGUsIGRvYywgc2luZ2xlKSB7XHJcblx0cmV0dXJuIGV4cG9ydHMuc2VsZWN0V2l0aFJlc29sdmVyKGUsIGRvYywgbnVsbCwgc2luZ2xlKTtcclxufTtcclxuXHJcbmV4cG9ydHMudXNlTmFtZXNwYWNlcyA9IGZ1bmN0aW9uKG1hcHBpbmdzKSB7XHJcblx0dmFyIHJlc29sdmVyID0ge1xyXG5cdFx0bWFwcGluZ3M6IG1hcHBpbmdzIHx8IHt9LFxyXG5cdFx0bG9va3VwTmFtZXNwYWNlVVJJOiBmdW5jdGlvbihwcmVmaXgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubWFwcGluZ3NbcHJlZml4XTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24oZSwgZG9jLCBzaW5nbGUpIHtcclxuXHRcdHJldHVybiBleHBvcnRzLnNlbGVjdFdpdGhSZXNvbHZlcihlLCBkb2MsIHJlc29sdmVyLCBzaW5nbGUpO1xyXG5cdH07XHJcbn07XHJcblxyXG5leHBvcnRzLnNlbGVjdFdpdGhSZXNvbHZlciA9IGZ1bmN0aW9uKGUsIGRvYywgcmVzb2x2ZXIsIHNpbmdsZSkge1xyXG5cdHZhciBleHByZXNzaW9uID0gbmV3IFhQYXRoRXhwcmVzc2lvbihlLCByZXNvbHZlciwgbmV3IFhQYXRoUGFyc2VyKCkpO1xyXG5cdHZhciB0eXBlID0gWFBhdGhSZXN1bHQuQU5ZX1RZUEU7XHJcblxyXG5cdHZhciByZXN1bHQgPSBleHByZXNzaW9uLmV2YWx1YXRlKGRvYywgdHlwZSwgbnVsbCk7XHJcblxyXG5cdGlmIChyZXN1bHQucmVzdWx0VHlwZSA9PSBYUGF0aFJlc3VsdC5TVFJJTkdfVFlQRSkge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0LnN0cmluZ1ZhbHVlO1xyXG5cdH1cclxuXHRlbHNlIGlmIChyZXN1bHQucmVzdWx0VHlwZSA9PSBYUGF0aFJlc3VsdC5OVU1CRVJfVFlQRSkge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0Lm51bWJlclZhbHVlO1xyXG5cdH1cclxuXHRlbHNlIGlmIChyZXN1bHQucmVzdWx0VHlwZSA9PSBYUGF0aFJlc3VsdC5CT09MRUFOX1RZUEUpIHtcclxuXHRcdHJlc3VsdCA9IHJlc3VsdC5ib29sZWFuVmFsdWU7XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0cmVzdWx0ID0gcmVzdWx0Lm5vZGVzO1xyXG5cdFx0aWYgKHNpbmdsZSkge1xyXG5cdFx0XHRyZXN1bHQgPSByZXN1bHRbMF07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuZXhwb3J0cy5zZWxlY3QxID0gZnVuY3Rpb24oZSwgZG9jKSB7XHJcblx0cmV0dXJuIGV4cG9ydHMuc2VsZWN0KGUsIGRvYywgdHJ1ZSk7XHJcbn07XHJcblxyXG4vLyBlbmQgbm9uLW5vZGUgd3JhcHBlclxyXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogeHBhdGgpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiZXhwb3J0IHZhciBodG1sVGFncyA9IFtcblx0J2EnLFxuXHQnYWJicicsXG5cdCdhZGRyZXNzJyxcblx0J2FyZWEnLFxuXHQnYXJ0aWNsZScsXG5cdCdhc2lkZScsXG5cdCdhdWRpbycsXG5cdCdiJyxcblx0J2Jhc2UnLFxuXHQnYmRpJyxcblx0J2JkbycsXG5cdCdibG9ja3F1b3RlJyxcblx0J2JvZHknLFxuXHQnYnInLFxuXHQnYnV0dG9uJyxcblx0J2NhbnZhcycsXG5cdCdjYXB0aW9uJyxcblx0J2NpdGUnLFxuXHQnY29kZScsXG5cdCdjb2wnLFxuXHQnY29sZ3JvdXAnLFxuXHQnZGF0YScsXG5cdCdkYXRhbGlzdCcsXG5cdCdkZCcsXG5cdCdkZWwnLFxuXHQnZGV0YWlscycsXG5cdCdkZm4nLFxuXHQnZGlhbG9nJyxcblx0J2RpdicsXG5cdCdkbCcsXG5cdCdkdCcsXG5cdCdlbScsXG5cdCdlbWJlZCcsXG5cdCdmaWVsZHNldCcsXG5cdCdmaWdjYXB0aW9uJyxcblx0J2ZpZ3VyZScsXG5cdCdmb290ZXInLFxuXHQnZm9ybScsXG5cdCdoMScsXG5cdCdoMicsXG5cdCdoMycsXG5cdCdoNCcsXG5cdCdoNScsXG5cdCdoNicsXG5cdCdoZWFkJyxcblx0J2hlYWRlcicsXG5cdCdoZ3JvdXAnLFxuXHQnaHInLFxuXHQnaHRtbCcsXG5cdCdpJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQnaW5zJyxcblx0J2tiZCcsXG5cdCdrZXlnZW4nLFxuXHQnbGFiZWwnLFxuXHQnbGVnZW5kJyxcblx0J2xpJyxcblx0J2xpbmsnLFxuXHQnbWFpbicsXG5cdCdtYXAnLFxuXHQnbWFyaycsXG5cdCdtZW51Jyxcblx0J21lbnVpdGVtJyxcblx0J21ldGEnLFxuXHQnbWV0ZXInLFxuXHQnbmF2Jyxcblx0J25vc2NyaXB0Jyxcblx0J29iamVjdCcsXG5cdCdvbCcsXG5cdCdvcHRncm91cCcsXG5cdCdvcHRpb24nLFxuXHQnb3V0cHV0Jyxcblx0J3AnLFxuXHQncGFyYW0nLFxuXHQncHJlJyxcblx0J3Byb2dyZXNzJyxcblx0J3EnLFxuXHQncmInLFxuXHQncnAnLFxuXHQncnQnLFxuXHQncnRjJyxcblx0J3J1YnknLFxuXHQncycsXG5cdCdzYW1wJyxcblx0J3NjcmlwdCcsXG5cdCdzZWN0aW9uJyxcblx0J3NlbGVjdCcsXG5cdCdzbWFsbCcsXG5cdCdzb3VyY2UnLFxuXHQnc3BhbicsXG5cdCdzdHJvbmcnLFxuXHQnc3R5bGUnLFxuXHQnc3ViJyxcblx0J3N1bW1hcnknLFxuXHQnc3VwJyxcblx0J3RhYmxlJyxcblx0J3Rib2R5Jyxcblx0J3RkJyxcblx0J3RlbXBsYXRlJyxcblx0J3RleHRhcmVhJyxcblx0J3Rmb290Jyxcblx0J3RoJyxcblx0J3RoZWFkJyxcblx0J3RpbWUnLFxuXHQndGl0bGUnLFxuXHQndHInLFxuXHQndHJhY2snLFxuXHQndScsXG5cdCd1bCcsXG5cdCd2YXInLFxuXHQndmlkZW8nLFxuXHQnd2JyJyxcbl07XG4iLCJjb25zdCBzZWxlY3RvcnNSZWdleCA9IC8oXlxccyp8fVxccyp8XFxzKikoW0AqLiNcXHdcXGRcXHMtOlxcW1xcXVxcKFxcKT1cIic+K35dKykoLHx7W159XSt9KS9nO1xuY29uc3QgY29tbWVudHNSZWdleCA9IC9cXC9cXCooW14qXXxbXFxyXFxuXXwoXFwqKyhbXiovXXxbXFxyXFxuXSkpKSpcXCpcXC8rL2c7IC8vIGh0dHA6Ly9vc3Rlcm1pbGxlci5vcmcvZmluZGNvbW1lbnQuaHRtbFxuXG5leHBvcnQgZGVmYXVsdCAoc3R5bGVzLCBzZWxlY3RvcikgPT4ge1xuXHRsZXQgc2VsZWN0b3JQYXR0ZXJuID0gc2VsZWN0b3IucmVwbGFjZSgvKFtcXFtcXF1cXChcXCleJCorLixcXHtcXH18PyE6XSkvZywgJ1xcXFwkMScpO1xuXHRsZXQgcHJlZml4UmVnZXggPSBuZXcgUmVnRXhwKHNlbGVjdG9yUGF0dGVybiArICdcXFxccycsICdnJyk7XG5cblx0Ly8g0KLQsNC6INC60LDQuiDQv9GA0LXRhNC40LrRgSDQv9GA0L7RgdGC0LDQstC70Y/QtdGC0YHRjyDQsNCx0YHQvtC70Y7RgtC90L4g0LLRgdC10LzRgyDRgyDRh9C10LPQviDQuNC80LXQtdGC0YHRjyDRgdC70LXQtNGD0Y7RidCw0Y8gXG5cdC8vINC60L7RgdGC0YDRg9C60YbQuNGPIGBhYWFbLCBiYmJdIHt9YCDQtNC70Y8g0L/QvtC70L3QvtCz0L4g0Lgg0L/RgNCw0LLQuNC70YzQvdC+0LPQviDQv9GA0L7RgdGC0LDQstC70LXQvdC40Y8g0L/RgNC10YTQuNC60YHQvtCyIFxuXHQvLyDQvtC/0LXRgNCw0YbQuNGPINGA0LDQt9Cx0LjQstCw0LXRgtGB0Y8g0L3QsCDQvdC10YHQutC+0LvRjNC60L4g0YjQsNCz0L7Qsjpcblx0Ly8gXG5cdC8vIDEuINCj0LTQsNC70Y/QtdC8INC60L7QvNC10L3RgtCw0YDQuNC4INC40Lcg0LjRgdGF0L7QtNC90L7Qs9C+INC60L7QtNCwLiDQlNC70Y8g0YDQsNCx0L7RgtGLINGB0YLQuNC70LXQuSDRjdGC0L4g0L3QtSDQstCw0LbQvdC+LCDQvdC+INGB0LjQu9GM0L3QviBcblx0Ly8gICAg0L/QvtC80L7QttC10YIg0LjQt9Cx0LXQttCw0YLRjCDQv9GA0L7QsdC70LXQvCDRgSDQvdC10L/RgNCw0LLQuNC70YzQvdGL0Lwg0YHRgNCw0LHQsNGC0YvQstCw0L3QuNC10Lwg0L/RgNC10YTQuNC60YHQtdGA0LAuXG5cdC8vIDIuINCf0YDQvtGB0YLQsNCy0LvRj9C10Lwg0L/RgNC10YTQuNC60YHRiy5cblx0Ly8gMy4g0J7QsdGA0LDQsdCw0YLRi9Cy0LDQtdC8INC60LXQudGBLCDQutC+0LPQtNCwINGDIGF0LdGB0LXQu9C10LrRgtC+0YDQvtCyINC90LUg0LzQvtC20LXRgiDQsdGL0YLRjCDQvdC40LrQsNC60LjRhSDQv9GA0LXRhNC40LrRgdC+0LIuIFxuXHQvLyAgICDQkdC+0LvQtdC1INC/0L7QtNGA0L7QsdC90L4g0L7QsSDRjdGC0L7QvCDQvtC/0LjRgdCw0L3QviDRgtGD0YI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9AZm9udC1mYWNlXG5cdC8vIDQuINCe0LHRgNCw0LHQsNGC0YvQstCw0LXQvCDQutC10LnRgSwg0LrQvtCz0LTQsCDQv9C10YDQstCw0Y8g0YDQtdCz0YPQu9GP0YDQutCwINC80L7Qs9C70LAg0LfQsNC80LXQvdC40YLRjCDQv9GD0YLRjCBcblx0Ly8gICAg0LIg0LrQvtC90YHRgtGA0YPQutGG0LjQuCBgdXJsKClgINCy0L7RgdGC0LDQvdCw0LLQu9C40LLQsNGPINC10LPQviDQsiDQv9C10YDQstC+0L3QsNGH0LDQu9GM0L3QvtC1INC30L3QsNGH0LXQvdC40LUuXG5cdC8vIDUuINCi0LDQuiDQutCw0Log0YHRh9C40YLQsNC10YLRgdGPINGH0YLQviDRjdC70LXQvNC10L3RgiDRgSDQv9GA0LXRhNC40LrRgS3RgdC10LvQtdC60YLQvtGA0L7QvCDRgyDQvdCw0YEg0LHRg9C00LXRgiDQutC+0YDQvdC10LLRi9C8IFxuXHQvLyAgICDRjdC70LXQvNC10L3RgtC+0LwsINGC0L4g0LLRgdC1INGB0LXQu9C10LrRgtC+0YDRiyA6aG9zdCDQt9Cw0LzQtdC90Y/QtdC8INC90LAg0YHQtdC70LXQutGC0L7RgCDQv9GA0LXRhNC40LrRgdCwLlxuXHRyZXR1cm4gKHN0eWxlcyB8fCAnJylcblx0XHQucmVwbGFjZShjb21tZW50c1JlZ2V4LCAnJylcblx0XHQucmVwbGFjZShzZWxlY3RvcnNSZWdleCwgYCQxJHtzZWxlY3Rvcn0gJDIkM2ApXG5cblx0XHQvLyDQmtC+0YDQtdC60YLQuNGA0YPRjtGJ0LjQtSDQv9C+0YHRgi3QvtCx0YDQsNCx0L7RgtC60Lhcblx0XHQucmVwbGFjZShuZXcgUmVnRXhwKHNlbGVjdG9yUGF0dGVybiArICdcXFxccyhAKGNoYXJzZXR8ZG9jdW1lbnR8Zm9udC1mYWNlfGltcG9ydHxrZXlmcmFtZXN8bWVkaWF8cGFnZXxzdXBwb3J0cykpJywgJ2cnKSwgJyQxJylcblx0XHQucmVwbGFjZSgvdXJsXFwoW14pXStcXCkvZywgKG1hdGNoKSA9PiBtYXRjaC5yZXBsYWNlKHByZWZpeFJlZ2V4LCAnJykpXG5cdFx0LnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBzZWxlY3RvclBhdHRlcm4gKyAnKVxcXFxzKDpob3N0KScsICdnJyksICckMScpXG5cdFx0LnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBzZWxlY3RvclBhdHRlcm4gKyAnKShbXnssXSspKDpob3N0KShbXnssXStbeyxdKScsICdnJyksICckMiQxJDQnKTtcbn1cbiIsImltcG9ydCB7aHRtbFRhZ3N9IGZyb20gJy4vZW50aXRpZXMnO1xuXG5pZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XG5cdHZhciBqc2RvbSA9IHJlcXVpcmUoJ2pzZG9tJykuanNkb207XG5cdHZhciBqc1dpbmRvdyA9IGpzZG9tKCkuZGVmYXVsdFZpZXc7XG59XG5cbnZhciB7SFRNTENvbGxlY3Rpb24sIE5vZGVMaXN0LCBkb2N1bWVudCwgYnRvYX0gPSAoanNXaW5kb3cgfHwgd2luZG93KTtcbnZhciBjb3VudGVyID0gMDtcblxuZXhwb3J0IGNvbnN0IGV2ZW50TmFtZVJlZ2V4ID0gL15vbihbYS16XSspJC87XG5leHBvcnQgY29uc3QgZG9tVGFnTmFtZVJlZ2V4ID0gL14oW2Etel0rOik/KGhbMS02XXxbYS16XSspJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc1RvQXJyYXkobm9kZXMpIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHRpZiAobm9kZXMgaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbiB8fCBub2RlcyBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG5cdFx0bGlzdCA9IGxpc3QuY29uY2F0KHRvQXJyYXkobm9kZXMpKTtcblx0fSBlbHNlIGlmIChub2Rlcykge1xuXHRcdGxpc3QucHVzaChub2Rlcyk7XG5cdH1cblx0cmV0dXJuIGxpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luRE9NKG5vZGUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmJvZHkuY29udGFpbnMobm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGFyciA9IFtdKSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZShuYW1lID0gJ3NwYW4nKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCA9ICcnKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVUlEKCkge1xuXHRyZXR1cm4gKytjb3VudGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZSh3b3JkKSB7XG5cdHdvcmQgPSAnJyArIHdvcmQ7XG5cdHJldHVybiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKTtcbn1cblxuLy8g0KHRgtCw0L3QtNCw0YDRgtC90YvQtSBodG1sINCw0YLRgNC40LHRg9GC0Ysg0LrQvtGC0L7RgNGL0LUg0L/QuNGI0YPRgtGB0Y8g0YfQtdGA0LXQtyBgLWAuXG52YXIgYXR0clRyYW5zZm9ybUV4ZXB0aW9uTGlzdCA9IFtcblx0J2h0dHAtZXF1aXYnLCBcblx0J2FjY2VwdC1jaGFyc2V0Jyxcbl07XG5cbi8vINCa0LDRgdGC0L7QvNC90YvQtSDQsNGC0YDQuNCx0YPRgtGLINGB0L/QtdGG0LjRhNC40YfQvdGL0LUg0LTQu9GPIGRzbCwg0LrQvtGC0L7RgNGL0LUg0L3QtSDQtNC+0LvQttC90Ysg0YLRgNCw0L3RgdGE0L7RgNC80LjRgNC+0LLQsNGC0YzRgdGPLlxuLy8gW1RPRE9dINCd0YPQttC90L4g0L7RgiDRjdGC0L7Qs9C+INC40LfQsdCw0LLQuNGC0YzRgdGPLlxuYXR0clRyYW5zZm9ybUV4ZXB0aW9uTGlzdCA9IGF0dHJUcmFuc2Zvcm1FeGVwdGlvbkxpc3QuY29uY2F0KFtcblx0J2JpbmQtdG8tbm9kZScsXG5dKTtcblxudmFyIGF0dHJzTWFwcGluZyA9IHtcblx0J2NsYXNzJzogJ2NsYXNzTmFtZSdcbn07XG52YXIgcmV2ZXJzZUF0dHJzTWFwcGluZyA9IHt9O1xuXG5PYmplY3Qua2V5cyhhdHRyc01hcHBpbmcpLmZvckVhY2goKGF0dHIpID0+IHJldmVyc2VBdHRyc01hcHBpbmdbYXR0cnNNYXBwaW5nW2F0dHJdXSA9IGF0dHIpO1xuXG5leHBvcnQgZnVuY3Rpb24gSHRtbEF0dHJUb1V2ZG9tQXR0cihuYW1lKSB7XG5cdGlmICh+bmFtZS5pbmRleE9mKCctJykgJiYgIS9eZGF0YS0uKyQvLnRlc3QobmFtZSkgJiYgYXR0clRyYW5zZm9ybUV4ZXB0aW9uTGlzdC5pbmRleE9mKG5hbWUpIDwgMCkge1xuXHRcdG5hbWUgPSBuYW1lLnNwbGl0KCctJykubWFwKChwYXJ0LCBpKSA9PiAhaSA/IHBhcnQgOiBjYXBpdGFsaXplKHBhcnQpKS5qb2luKCcnKTtcblx0fVxuXHRyZXR1cm4gYXR0cnNNYXBwaW5nW25hbWVdIHx8IG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBVdmRvbUF0dHJUb0h0bWxBdHRyKG5hbWUpIHtcblx0aWYgKHJldmVyc2VBdHRyc01hcHBpbmdbbmFtZV0pIHtcblx0XHRyZXR1cm4gcmV2ZXJzZUF0dHJzTWFwcGluZ1tuYW1lXTtcblx0fVxuXG5cdGlmICghfm5hbWUuaW5kZXhPZignLScpKSB7XG5cdFx0bmFtZSA9IG5hbWUuc3BsaXQoLyhbQS1aXXsyLH18W0EtWl1bXkEtWl0rKS8pLmZpbHRlcihCb29sZWFuKS5tYXAoKGl0ZW0pID0+IGl0ZW0udG9Mb3dlckNhc2UoKSkuam9pbignLScpO1xuXHR9XG5cdHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb21tb25FbGVtZW50KHRhZ05hbWUpIHtcblx0cmV0dXJuIGRvbVRhZ05hbWVSZWdleC50ZXN0KHRhZ05hbWUpICYmICh0YWdOYW1lLmluZGV4T2YoJzonKSA+IDAgfHwgaHRtbFRhZ3MuaW5kZXhPZih0YWdOYW1lKSA+PSAwKTtcbn1cblxuZnVuY3Rpb24gcnVsZXNGb3JDc3NUZXh0KHN0eWxlQ29udGVudCkge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuXHRzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBzdHlsZUNvbnRlbnQ7XG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblxuXHRyZXR1cm4gc3R5bGVFbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VOb2RlU3R5bGVzKG5vZGVOYW1lLCBzdHlsZXMpIHtcblx0dmFyIENTU1N0eWxlRGVjbGFyYXRpb24gPSB7fTtcblx0dmFyIHN0eWxlRGVjbGFyYXRpb247XG5cblx0aWYgKGpzV2luZG93KSB7XG5cdFx0dmFyIHJ1bGVzID0gcnVsZXNGb3JDc3NUZXh0KGAke25vZGVOYW1lfSB7ICR7c3R5bGVzfSB9YCk7XG5cdFx0c3R5bGVEZWNsYXJhdGlvbiA9IHJ1bGVzWzBdLnN0eWxlO1xuXHR9IGVsc2Uge1xuXHRcdHZhciB0YXJnZXROb2RlID0gY3JlYXRlTm9kZShub2RlTmFtZSk7XG5cdFx0dGFyZ2V0Tm9kZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGVzO1xuXHRcdHN0eWxlRGVjbGFyYXRpb24gPSB0YXJnZXROb2RlLnN0eWxlO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZURlY2xhcmF0aW9uLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIG5hbWUgPSBzdHlsZURlY2xhcmF0aW9uW2ldO1xuXG5cdFx0Q1NTU3R5bGVEZWNsYXJhdGlvbltjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKV0gPSBzdHlsZURlY2xhcmF0aW9uLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gQ1NTU3R5bGVEZWNsYXJhdGlvbjtcbn1cblxuY29uc3QgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5jb25zdCBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIChfLCBjaGFyYWN0ZXIpID0+IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpKTtcbn1cblxuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG5cdHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHN0ciA9ICcnKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJycpLnJlZHVjZSgocHJldiwgdmFsdWUpID0+IHtcblx0XHRwcmV2ID0gKChwcmV2IDw8IDUpIC0gcHJldikgKyB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHRcdHJldHVybiBwcmV2ICYgcHJldjtcblx0fSwgMCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIga2V5cztcblx0dmFyIHRvID0gVG9PYmplY3QodGFyZ2V0KTtcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBhcmd1bWVudHNbc107XG5cdFx0a2V5cyA9IE9iamVjdC5rZXlzKE9iamVjdChmcm9tKSk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRvW2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwidmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuaW1wb3J0IHtcblx0aGFzaCxcblx0bm9kZXNUb0FycmF5LCBcblx0dG9BcnJheSwgXG5cdGNyZWF0ZU5vZGUsIFxuXHRwYXJzZU5vZGVTdHlsZXMsIFxuXHRnZW5lcmF0ZVVJRCxcblx0SHRtbEF0dHJUb1V2ZG9tQXR0cixcblx0ZXZlbnROYW1lUmVnZXgsXG5cdGlzQ29tbW9uRWxlbWVudFxufSBmcm9tICcuL2xpYi91dGlscyc7XG5pbXBvcnQgdG9SZWFjdCBmcm9tICcuL3RyYW5zZm9ybXMvcmVhY3QnO1xuaW1wb3J0IHRvSFRNTCBmcm9tICcuL3RyYW5zZm9ybXMvaHRtbCc7XG5pbXBvcnQgcHJlZml4IGZyb20gJy4vbGliL3ByZWZpeC1zdHlsZXMnO1xuXG5jb25zdCBub2RlVHlwZXMgPSB7XG5cdEVMRU1FTlRfTk9ERTogMSxcblx0QVRUUklCVVRFX05PREU6IDIsXG5cdFRFWFRfTk9ERTogMyxcblx0Q0RBVEFfU0VDVElPTl9OT0RFOiA0LFxuXHRFTlRJVFlfUkVGRVJFTkNFX05PREU6IDUsXG5cdEVOVElUWV9OT0RFOiA2LFxuXHRQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6IDcsXG5cdENPTU1FTlRfTk9ERTogOCxcblx0RE9DVU1FTlRfTk9ERTogOSxcblx0RE9DVU1FTlRfVFlQRV9OT0RFOiAxMCxcblx0RE9DVU1FTlRfRlJBR01FTlRfTk9ERTogMTEsXG5cdE5PVEFUSU9OX05PREU6IDEyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VyKHRhcmdldCA9IHt9LCBwYXJhbXMgPSB7fSkge1xuXHRpZiAodHlwZW9mKHRhcmdldCkgPT09ICdzdHJpbmcnICYmIHRhcmdldCkge1xuXHRcdHZhciBjb250ZW50ID0gdGFyZ2V0O1xuXG5cdFx0dGFyZ2V0ID0gY3JlYXRlTm9kZSgpO1xuXHRcdHRhcmdldC5pbm5lckhUTUwgPSBjb250ZW50O1xuXHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaXMtdXZkb29tLXdyYXBwZXInLCB0cnVlKTtcblx0fSBlbHNlIGlmICh0eXBlb2YodGFyZ2V0LmNsb25lTm9kZSkgIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRyZXR1cm4gcGFyc2VOb2Rlcyhub2Rlc1RvQXJyYXkodGFyZ2V0LmNsb25lTm9kZSh0cnVlKSksIHBhcmFtcyk7XG59XG5cbmFzc2lnbihwYXJzZXIsIHtcblx0dXZkb21Ub1JlYWN0OiB0b1JlYWN0LFxuXHR1dmRvbVRvSFRNTDogdG9IVE1MXG59KTtcblxuZnVuY3Rpb24gcGFyc2VOb2Rlcyhub2RlcyA9IFtdLCBwYXJhbXMgPSB7fSkge1xuXHR2YXIgdk5vZGVzID0gW107XG5cblx0bm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuXHRcdGxldCB2Tm9kZSA9IHt9O1xuXG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGVUeXBlcy5FTEVNRU5UX05PREUpIHtcblx0XHRcdGxldCB0YWdOYW1lID0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICh0eXBlb2YocGFyYW1zLm9uVGFnTmFtZVJlc29sdmUpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRhZ05hbWUgPSBwYXJhbXMub25UYWdOYW1lUmVzb2x2ZShub2RlKSB8fCB0YWdOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNDb21tb25FbGVtZW50KHRhZ05hbWUpKSB7XG5cdFx0XHRcdHZOb2RlLnRhZyA9IHRhZ05hbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2Tm9kZS5jb21wb25lbnQgPSB0YWdOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcblx0XHRcdFx0dG9BcnJheShub2RlLmF0dHJpYnV0ZXMpLmZvckVhY2goKGF0dHIpID0+IHtcblx0XHRcdFx0XHRsZXQge25hbWUsIHZhbHVlfSA9IGF0dHI7XG5cblx0XHRcdFx0XHQvLyDQn9GA0LXQvtCx0YDQsNC30L7QstGL0LLQsNC10Lwg0L3QsNC30LLQsNC90LjQtSDQsNGC0YDQuNCx0YPRgtCwINCyINC90L7RgtCw0YbQuNGOIFVWRE9NLlxuXHRcdFx0XHRcdG5hbWUgPSBIdG1sQXR0clRvVXZkb21BdHRyKG5hbWUpO1xuXG5cdFx0XHRcdFx0aWYgKHZOb2RlLmNvbXBvbmVudCAmJiBuYW1lID09PSAnaXMnKSB7XG5cdFx0XHRcdFx0XHR2Tm9kZS5leHRlbmRzID0gdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChbJ2tleScsICdyZWYnXS5pbmRleE9mKG5hbWUpID49IDApIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lID09PSAna2V5Jykge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cdFx0XHRcdFx0XHRcdGlzTmFOKHZhbHVlKSAmJiAodmFsdWUgPSBudWxsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlICE9IG51bGwgJiYgKHZOb2RlW25hbWVdID0gdmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnROYW1lUmVnZXgudGVzdChuYW1lKSkge1xuXHRcdFx0XHRcdFx0bGV0IG1hdGNoID0gbmFtZS5tYXRjaChldmVudE5hbWVSZWdleCk7XG5cblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHR2Tm9kZS5ldmVudHMgfHwgKHZOb2RlLmV2ZW50cyA9IHt9KTtcblx0XHRcdFx0XHRcdFx0dk5vZGUuZXZlbnRzW21hdGNoWzFdXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXG5cdFx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gJ2Nzc1RleHQnO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2Tm9kZS5hdHRycyB8fCAodk5vZGUuYXR0cnMgPSB7fSk7XG5cdFx0XHRcdFx0XHR2Tm9kZS5hdHRyc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHByb2Nlc3NOb2RlQ2hpbGRyZW4obm9kZSwgdk5vZGUsIHBhcmFtcyk7XG5cblx0XHRcdHZOb2Rlcy5wdXNoKGFzc2lnbihPYmplY3QuY3JlYXRlKHtcblx0XHRcdFx0dG9SZWFjdDogdG9SZWFjdC5iaW5kKHRoaXMsIHZOb2RlKSxcblx0XHRcdFx0dG9IVE1MOiB0b0hUTUwuYmluZCh0aGlzLCB2Tm9kZSlcblx0XHRcdH0pLCB2Tm9kZSkpO1xuXHRcdH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZVR5cGVzLlRFWFRfTk9ERSkge1xuXHRcdFx0bGV0IHRleHQgPSBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoL1tcXHRcXG5cXHJdKy9nLCAnJyk7XG5cblx0XHRcdHRleHQgJiYgdk5vZGVzLnB1c2godGV4dCk7XG5cdFx0fSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlVHlwZXMuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXHRcdFx0dk5vZGUudGFnID0gJ2RvY3VtZW50LWZyYWdtZW50Jztcblx0XHRcdHByb2Nlc3NOb2RlQ2hpbGRyZW4obm9kZSwgdk5vZGUsIHBhcmFtcyk7XG5cdFx0XHR2Tm9kZXMucHVzaCh2Tm9kZSk7XG5cdFx0fSBlbHNlIGlmIChbXG5cdFx0XHRub2RlVHlwZXMuQ09NTUVOVF9OT0RFLFxuXHRcdFx0bm9kZVR5cGVzLkNEQVRBX1NFQ1RJT05fTk9ERSxcblx0XHRdLmluZGV4T2Yobm9kZS5ub2RlVHlwZSkgPCAwKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VuaGFuZGxlZCBub2RlIHR5cGU6ICcgKyBub2RlLm5vZGVUeXBlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmICghdk5vZGVzLmxlbmd0aCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHZOb2Rlcy5sZW5ndGggPiAxID8gdk5vZGVzIDogdk5vZGVzWzBdO1xufVxuXG52YXIgc2hhZG93Um9vdElkcyA9IFtdO1xudmFyIHNoYWRvd1Jvb3RzQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tJZk5vZGVJc1RleHQobm9kZSkge1xuXHRyZXR1cm4gbm9kZS50YWcgPT09ICdzcGFuJyBcblx0XHQmJiB0eXBlb2Yobm9kZS5jaGlsZHJlbikgPT09ICdzdHJpbmcnIFxuXHRcdCYmIChub2RlLmF0dHJzID09IG51bGwgfHwgIU9iamVjdC5rZXlzKG5vZGUuYXR0cnMpLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NOb2RlQ2hpbGRyZW4obm9kZSwgdk5vZGUsIHBhcmFtcyA9IHt9KSB7XG5cdGlmIChub2RlLmNoaWxkTm9kZXMpIHtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHBhcnNlTm9kZXMobm9kZXNUb0FycmF5KG5vZGUuY2hpbGROb2RlcyksIHBhcmFtcyk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcykge1xuXHRcdFx0Ly8g0JIg0JjQlSDQtdGB0LvQuCDQsiDRgtC10LrRgdGC0LUg0LXRgdGC0Ywg0L/QtdGA0LXQvdC+0YHRiyDRgdGC0YDQvtC6LCDRgtC+INGC0LXQutGB0YIg0YDQsNC30LHQuNCy0LDQtdGC0YHRjyDQvdCwINC90L7QtNGLLiBcblx0XHRcdC8vINCU0LvRjyDRg9C90LjRhNC40LrQsNGG0LjQuCDQvNC10YDQtNC20LjQvCDRgtC10LrRgdGC0L7QstGL0LUg0L3QvtC00YsuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGVzKSkge1xuXHRcdFx0XHRpZiAoY2hpbGROb2Rlcy5zb21lKChub2RlKSA9PiAhY2hlY2tJZk5vZGVJc1RleHQobm9kZSkpKSB7XG5cdFx0XHRcdFx0dmFyIG1lcmdlZENoaWxkTm9kZXMgPSBbXTtcblxuXHRcdFx0XHRcdGNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGNoZWNrSWZOb2RlSXNUZXh0KG5vZGUpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcmV2SW5kZXggPSBtZXJnZWRDaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdHZhciBwcmV2ID0gbWVyZ2VkQ2hpbGROb2Rlc1twcmV2SW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YocHJldikgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWVyZ2VkQ2hpbGROb2Rlc1twcmV2SW5kZXhdICs9IG5vZGUuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bWVyZ2VkQ2hpbGROb2Rlcy5wdXNoKG5vZGUuY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRtZXJnZWRDaGlsZE5vZGVzLnB1c2gobm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRjaGlsZE5vZGVzID0gbWVyZ2VkQ2hpbGROb2Rlcztcblx0XHRcdFx0XHRtZXJnZWRDaGlsZE5vZGVzID0gdm9pZCgwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiAocHJldi5jaGlsZHJlbiB8fCBwcmV2KSArIG5leHQuY2hpbGRyZW47XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dk5vZGUuY2hpbGRyZW4gPSBjaGlsZE5vZGVzO1xuXG5cdFx0XHR2YXIgc3R5bGVzID0gW10uY29uY2F0KGNoaWxkTm9kZXMpLmZpbHRlcigoY2hpbGQpID0+IHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkLnRhZyA9PT0gJ3N0eWxlJztcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIXN0eWxlcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHZOb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXMgPSBzdHlsZXMubWFwKHVuaWZ5U3R5bGVzQ29udGVudCkucmVkdWNlKChwcmV2LCBuZXh0KSA9PiB7XG5cdFx0XHRcdHZhciBuZXh0SW5kZXggPSBjaGlsZE5vZGVzLmluZGV4T2YobmV4dCk7XG5cblx0XHRcdFx0aWYgKH5uZXh0SW5kZXgpIHtcblx0XHRcdFx0XHRjaGlsZE5vZGVzLnNwbGljZShuZXh0SW5kZXgsIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldi5jaGlsZHJlbiArPSBuZXh0LmNoaWxkcmVuO1xuXHRcdFx0XHRyZXR1cm4gcHJldjtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoc3R5bGVzICYmICFPYmplY3Qua2V5cyhzaGFkb3dSb290c0NhY2hlKS5zb21lKChzaGFkb3dSb290SWQpID0+IHtcblx0XHRcdFx0cmV0dXJuIHN0eWxlcy5jaGlsZHJlbiA9PT0gc2hhZG93Um9vdHNDYWNoZVtzaGFkb3dSb290SWRdO1xuXHRcdFx0fSkpIHtcblx0XHRcdFx0dmFyIHNoYWRvd1Jvb3RTdHlsZXNIYXNoID0gaGFzaChzdHlsZXMuY2hpbGRyZW4pO1xuXHRcdFx0XHR2YXIgc2hhZG93Um9vdElkID0gc2hhZG93Um9vdElkcy5pbmRleE9mKHNoYWRvd1Jvb3RTdHlsZXNIYXNoKTtcblxuXHRcdFx0XHRpZiAoIX5zaGFkb3dSb290SWQpIHtcblx0XHRcdFx0XHRzaGFkb3dSb290SWQgPSBzaGFkb3dSb290SWRzLnB1c2goc2hhZG93Um9vdFN0eWxlc0hhc2gpIC0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0eWxlcy5jaGlsZHJlbiA9IHByZWZpeChzdHlsZXMuY2hpbGRyZW4sIGBbZGF0YS1zaGFkb3ctcm9vdC1pZD1cIiR7c2hhZG93Um9vdElkfVwiXWApO1xuXHRcdFx0XHRzaGFkb3dSb290c0NhY2hlW3NoYWRvd1Jvb3RJZF0gPSBzdHlsZXMuY2hpbGRyZW47XG5cblx0XHRcdFx0Ly8g0JXRgdC70Lgg0YMg0L3QvtC00Ysg0LXRgdGC0Ywgc2hhZG93LXJvb3QgaWQsINGC0L4g0YHQvtC30LTQsNC10Lwg0LLRgNCw0L/Qv9C10YAg0YEg0Y3RgtC40Lwg0LDQudC00LgsINC90LAg0LrQvtGC0L7RgNGL0Lkg0Lgg0LHRg9C00YPRgiBcblx0XHRcdFx0Ly8g0LfQsNCy0Y/Qt9Cw0L3RiyDRgdGC0LjQu9C4LlxuXHRcdFx0XHR2Tm9kZS5jaGlsZHJlbiA9IHtcblx0XHRcdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdFx0XHRhdHRyczoge1xuXHRcdFx0XHRcdFx0J2RhdGEtc2hhZG93LXJvb3QtaWQnOiBzaGFkb3dSb290SWRcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNoaWxkcmVuOiB2Tm9kZS5jaGlsZHJlblxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdk5vZGU7XG59XG5cbi8vIElFINC/0L4g0L3QtdC60L7RgtC+0YDRi9C8INC/0YDQuNGH0LjQvdCw0Lwg0LzQvtC20LXRgiDQtNGA0L7QsdC40YLRjCDRgtC10LrRgdGC0L7QstGL0LUg0L3QvtC00Ysg0L3QsCDQvNC90L7QttC10YHRgtCy0L4g0L3QvtC0LlxuLy8g0KfRgtC+0LEg0L3QtdCx0YvQu9C+INC/0YDQvtCx0LvQtdC8INC00LXQu9Cw0LXQvCDQuNGFINC+0LHRitC10LTQuNC90LXQvdC40LUg0LIg0L7QtNC90YMg0YHRgtGA0L7QutGDLlxuZnVuY3Rpb24gdW5pZnlTdHlsZXNDb250ZW50KG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcblx0XHRub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5qb2luKCcnKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn1cbiIsInZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmltcG9ydCB7XG5cdGNyZWF0ZU5vZGUsIFxuXHRjcmVhdGVUZXh0Tm9kZSwgXG5cdFV2ZG9tQXR0clRvSHRtbEF0dHJcbn0gZnJvbSAnLi4vbGliL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgKHV2ZG9tLCBwYXJhbXMpID0+IHtcblx0aWYgKHR5cGVvZih1dmRvbSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHV2ZG9tKSkge1xuXHRcdGxldCB0eXBlID0gdXZkb20udGFnIHx8IHV2ZG9tLmNvbXBvbmVudDtcblxuXHRcdGlmICh0eXBlb2YodHlwZSkgPT09ICdzdHJpbmcnICYmIHR5cGUpIHtcblx0XHRcdHJldHVybiB0b0hUTUwocGFyYW1zLCB1dmRvbSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hUTUwocGFyYW1zID0ge30sIHV2ZG9tKSB7XG5cdHZhciBwcm9jZXNzTm9kZXMgPSB0b0hUTUwuYmluZCh0aGlzLCBwYXJhbXMpO1xuXG5cdGlmIChBcnJheS5pc0FycmF5KHV2ZG9tKSkge1xuXHRcdGlmICh1dmRvbS5sZW5ndGggPT09IDEpIHtcblx0XHRcdHJldHVybiBwcm9jZXNzTm9kZXModXZkb21bMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdXZkb20ubWFwKHByb2Nlc3NOb2Rlcyk7XG5cdH0gZWxzZSBpZiAodXZkb20gIT0gbnVsbCAmJiB0eXBlb2YodXZkb20pID09PSAnb2JqZWN0Jykge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mKHBhcmFtcy5vblR5cGVOYW1lUmVzb2x2ZSkgPT09ICdmdW5jdGlvbicgXG5cdFx0XHQ/IHBhcmFtcy5vblR5cGVOYW1lUmVzb2x2ZSh1dmRvbSkgXG5cdFx0XHQ6ICh1dmRvbS50YWcgfHwgdXZkb20uY29tcG9uZW50KTtcblx0XHR2YXIgY2hpbGRyZW4gPSBwcm9jZXNzTm9kZXModXZkb20uY2hpbGRyZW4pO1xuXHRcdHZhciBub2RlID0gY3JlYXRlTm9kZSh0eXBlKTtcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0Y2hpbGRyZW4ubWFwKHByb2Nlc3NUZXh0Tm9kZSkuZm9yRWFjaCgoY2hpbGQpID0+IHtcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQocHJvY2Vzc1RleHROb2RlKGNoaWxkcmVuKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHV2ZG9tLmV2ZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXModXZkb20uZXZlbnRzKS5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoYG9uJHtldmVudE5hbWV9YCwgdXZkb20uZXZlbnRzW2V2ZW50TmFtZV0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHV2ZG9tLmF0dHJzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyh1dmRvbS5hdHRycykuZm9yRWFjaCgoYXR0cikgPT4ge1xuXHRcdFx0XHRpZiAoYXR0ciA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmIChhdHRyID09PSAnY3NzVGV4dCcpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdXZkb20uYXR0cnNbYXR0cl0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKFV2ZG9tQXR0clRvSHRtbEF0dHIoYXR0ciksIHV2ZG9tLmF0dHJzW2F0dHJdKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdFsna2V5JywgJ3JlZiddLmZvckVhY2goKHByb3ApID0+IHtcblx0XHRcdHByb3AgaW4gdXZkb20gJiYgbm9kZS5zZXRBdHRyaWJ1dGUocHJvcCwgdXZkb21bcHJvcF0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblx0cmV0dXJuIHV2ZG9tO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dE5vZGUobm9kZSkge1xuXHRpZiAodHlwZW9mKG5vZGUpID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBjcmVhdGVUZXh0Tm9kZShub2RlKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn1cbiIsInZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmltcG9ydCB7ZXZlbnRzTWFwfSBmcm9tICcuL3JlYWN0L2V2ZW50cyc7XG5pbXBvcnQge3BhcnNlTm9kZVN0eWxlc30gZnJvbSAnLi4vbGliL3V0aWxzJztcblxuY29uc3QgdGFnc01hcHBpbmcgPSB7XG5cdCdkb2N1bWVudC1mcmFnbWVudCc6ICdzcGFuJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKHV2ZG9tLCBwYXJhbXMpID0+IHtcblx0aWYgKHR5cGVvZih1dmRvbSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHV2ZG9tKSkge1xuXHRcdGxldCB0eXBlID0gdXZkb20udGFnIHx8IHV2ZG9tLmNvbXBvbmVudDtcblxuXHRcdGlmICh0eXBlb2YodHlwZSkgPT09ICdzdHJpbmcnICYmIHR5cGUpIHtcblx0XHRcdHJldHVybiB0b1JlYWN0KHBhcmFtcywgdXZkb20pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVQcm9wcygpIHtcblx0bGV0IHByb3BzID0ge307XG5cdGFzc2lnbihwcm9wcywgLi4uYXJndW1lbnRzKTtcblxuXHRsZXQgZXhjbHVkZUxpc3QgPSBbJ2V4dGVuZHMnLCAnY2hpbGRyZW4nXTtcblx0bGV0IHJlc3VsdCA9IGFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMpLCB0aGlzLCB7XG5cdFx0cHJvcHM6IGFzc2lnbih7fSwgdGhpcy5wcm9wcylcblx0fSk7XG5cblx0T2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goKHByb3BOYW1lKSA9PiB7XG5cdFx0aWYgKHByb3BzW3Byb3BOYW1lXSAmJiBleGNsdWRlTGlzdC5pbmRleE9mKHByb3BOYW1lKSA8IDApIHtcblx0XHRcdHJlc3VsdC5wcm9wc1twcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV07XG5cdFx0fVxuXHR9KTtcblxuXHRsZXQgcHJvcHNDaGlsZHJlbk1hcCA9IHt9O1xuXG5cdFtdLmNvbmNhdChwcm9wcy5jaGlsZHJlbikuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQpLmZvckVhY2goKGNoaWxkKSA9PiB7XG5cdFx0Y2hpbGQudHlwZSAmJiAocHJvcHNDaGlsZHJlbk1hcFtjaGlsZC50eXBlXSA9IGNoaWxkKTtcblx0fSk7XG5cblx0bGV0IGNoaWxkcmVuID0gW10uY29uY2F0KHRoaXMucHJvcHMuY2hpbGRyZW4pLm1hcCgoY2hpbGQpID0+IHtcblx0XHRsZXQgcHJvcHNDaGlsZCA9IHByb3BzQ2hpbGRyZW5NYXBbY2hpbGQudHlwZV07XG5cdFx0bGV0IHJlc3VsdDtcblxuXHRcdGlmIChwcm9wc0NoaWxkKSB7XG5cdFx0XHRyZXN1bHQgPSBhc3NpZ24oe30sIGNoaWxkLCBwcm9wc0NoaWxkKTtcblx0XHRcdGRlbGV0ZSBwcm9wc0NoaWxkcmVuTWFwW2NoaWxkLnR5cGVdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQgfHwgY2hpbGQ7XG5cdH0pO1xuXG5cdGxldCBuZXdDaGlsZExpc3QgPSBPYmplY3Qua2V5cyhwcm9wc0NoaWxkcmVuTWFwKTtcblxuXHRpZiAobmV3Q2hpbGRMaXN0Lmxlbmd0aCkge1xuXHRcdGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KG5ld0NoaWxkTGlzdC5tYXAoKG5hbWUpID0+IHByb3BzQ2hpbGRyZW5NYXBbbmFtZV0pKTtcblx0fVxuXG5cdGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0LnByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHRvUmVhY3QocGFyYW1zID0ge30sIHV2ZG9tKSB7XG5cdHZhciB7bWFwcGVyLCBvd25lcn0gPSBwYXJhbXM7XG5cdHZhciBwcm9jZXNzTm9kZXMgPSB0b1JlYWN0LmJpbmQodGhpcywgcGFyYW1zKTtcblxuXHQvLyDQp9GC0L7QsSDQvtGC0YDQuNGB0L7QstCw0YLRjCDRgNC10LDQutGC0L7QstGB0LrQuNC5INC60L7QvNC/0L7QvdC10L3RgiDQvdC10L7QsdGF0L7QtNC40LzQviDQvdGD0LbQvdC+INGDIFJlYWN0RWxlbWVudCDQv9C+0LvRg9GH0LjRgtGMINC10LPQviBgdHlwZWAgXG5cdC8vINC60L7RgtC+0YDRi9C5INC4INC/0LXRgNC10LTQsNC10YLRgdGPINCyINGA0LXQvdC00LXRgNC40L3Qsy5cblx0Ly8g0JXRgdC70Lgg0YMg0L/QtdGA0LXQtNCw0L3QvdC+0LPQviDQutC+0LzQv9C+0L3QtdC90YLQsCDQvdC10YIg0YHQstC+0LnRgdGC0LLQsCBgdHlwZWAsINGC0L4g0YHRh9C40YLQsNC10Lwg0YfRgtC+INGN0YLQviDQvdC1INCy0LDQu9C40LTQvdGL0LkgXG5cdC8vIFJlYWN0RWxlbWVudC4g0JTRgNGD0LPQuNC1INC/0YDQvtCy0LXRgNC60Lgg0LTQtdC70LDRgtGMINC90LXRgiDRgdC80YvRgdC70LAuXG5cdGlmICh0eXBlb2YobWFwcGVyKSA9PT0gJ29iamVjdCcpIHtcblx0XHRtYXBwZXIgPSAoKG1hcHBpbmcpID0+IChuYW1lKSA9PiAobWFwcGluZ1tuYW1lXSB8fCB7fSkudHlwZSkobWFwcGVyKTtcblx0fSBlbHNlIGlmICh0eXBlb2YobWFwcGVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdG1hcHBlciA9ICgob3JpZ2luYWxNYXBwZXIpID0+IChuYW1lLCBub2RlKSA9PiAob3JpZ2luYWxNYXBwZXIobmFtZSwgbm9kZSkgfHwge30pLnR5cGUpKG1hcHBlcik7XG5cdH0gZWxzZSBpZiAodHlwZW9mKG1hcHBlcikgIT09ICdmdW5jdGlvbicpIHtcblx0XHRtYXBwZXIgPSAoKSA9PiBudWxsO1xuXHR9XG5cblx0aWYgKEFycmF5LmlzQXJyYXkodXZkb20pKSB7XG5cdFx0aWYgKHV2ZG9tLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIHByb2Nlc3NOb2Rlcyh1dmRvbVswXSk7XG5cdFx0fVxuXHRcdHJldHVybiB1dmRvbS5tYXAocHJvY2Vzc05vZGVzKTtcblx0fSBlbHNlIGlmICh1dmRvbSAhPSBudWxsICYmIHR5cGVvZih1dmRvbSkgPT09ICdvYmplY3QnKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YocGFyYW1zLm9uVHlwZU5hbWVSZXNvbHZlKSA9PT0gJ2Z1bmN0aW9uJyBcblx0XHRcdD8gcGFyYW1zLm9uVHlwZU5hbWVSZXNvbHZlKHV2ZG9tKSBcblx0XHRcdDogKHRhZ3NNYXBwaW5nW3V2ZG9tLnRhZ10gfHwgdXZkb20udGFnIHx8IG1hcHBlcih1dmRvbS5jb21wb25lbnQsIHV2ZG9tKSB8fCB1dmRvbS5jb21wb25lbnQpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHByb2Nlc3NOb2Rlcyh1dmRvbS5jaGlsZHJlbik7XG5cdFx0dmFyIHByb3BzID0ge307XG5cblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cdFx0fVxuXG5cdFx0aWYgKHV2ZG9tLmV4dGVuZHMpIHtcblx0XHRcdHByb3BzLmV4dGVuZHMgPSB1dmRvbS5leHRlbmRzO1xuXHRcdH1cblxuXHRcdHZhciBldmVudHMgPSB7fTtcblxuXHRcdGlmICh1dmRvbS5ldmVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzKHV2ZG9tLmV2ZW50cykuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG5cdFx0XHRcdGxldCBuYXRpdmVFdmVudE5hbWUgPSBgb24ke2V2ZW50TmFtZX1gO1xuXHRcdFx0XHRsZXQgcmVhY3RFdmVudCA9IGV2ZW50c01hcFtuYXRpdmVFdmVudE5hbWVdO1xuXG5cdFx0XHRcdGV2ZW50c1tyZWFjdEV2ZW50IHx8IG5hdGl2ZUV2ZW50TmFtZV0gPSB1dmRvbS5ldmVudHNbZXZlbnROYW1lXTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBhdHRycyA9IGFzc2lnbih7fSwgdXZkb20uYXR0cnMpO1xuXG5cdFx0Ly8g0KHRgtC40LvQuCDQtNC+0LvQttC90Ysg0LHRi9GC0Ywg0L/RgNC10LTRgdGC0LDQstC70LXQvdGLINCyINCy0LjQtNC1IENTU1N0eWxlRGVjbGFyYXRpb24uXG5cdFx0aWYgKHR5cGVvZih0eXBlKSA9PT0gJ3N0cmluZycgJiYgYXR0cnMuY3NzVGV4dCkge1xuXHRcdFx0YXR0cnMuc3R5bGUgPSBwYXJzZU5vZGVTdHlsZXModHlwZSwgYXR0cnMuY3NzVGV4dCk7XG5cdFx0XHRkZWxldGUgYXR0cnMuY3NzVGV4dDtcblx0XHR9XG5cblx0XHQvLyDQnNC40L3QuNC80LDQu9GM0L3Ri9C5INC60L7QvdGC0YDQsNC60YIg0LrQvtC80L/QvtC90LXQvdGC0LAsINC60L7RgtC+0YDRi9C5INCx0YPQtNC10YIg0L/RgNC40L3Rj9GCIHJlYWN0LmpzINCx0LXQtyDQvtGI0LjQsdC+0Log0Y3RgtC+OlxuXHRcdC8vIHtcblx0XHQvLyAgICAgdHlwZTogJ3NwYW4nLFxuXHRcdC8vICAgICBwcm9wczoge30sXG5cdFx0Ly8gICAgIF9zdG9yZToge30sXG5cdFx0Ly8gICAgIF9vd25lcjoge30sIC8vINCd0LXQvtCx0YXQvtC00LjQvCDQtNC70Y8g0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0YDQtdGE0LXRgNC10L3RgdCwXG5cdFx0Ly8gICAgIF9pc1JlYWN0RWxlbWVudDogdHJ1ZVxuXHRcdC8vIH1cblx0XHR2YXIgY29tcG9uZW50ID0ge1xuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdHByb3BzOiBhc3NpZ24ocHJvcHMsIGV2ZW50cywgYXR0cnMpLFxuXHRcdFx0X3N0b3JlOiB7fSxcblx0XHRcdF9vd25lcjoge30sXG5cdFx0XHRfaXNSZWFjdEVsZW1lbnQ6IHRydWUsXG5cdFx0fTtcblxuXHRcdFsna2V5JywgJ3JlZiddLmZvckVhY2goKHByb3ApID0+IHByb3AgaW4gdXZkb20gJiYgKGNvbXBvbmVudFtwcm9wXSA9IHV2ZG9tW3Byb3BdKSk7XG5cblx0XHRpZiAoY29tcG9uZW50LnJlZiAmJiAhb3duZXIpIHtcblx0XHRcdGNvbnNvbGUud2FybignWW91IHNob3VsZCBwYXNzIGNvbXBvbmVudCBhcyBcIm93bmVyXCIgcGFyYW0gdG8gYmUgYWJsZSB0byB1c2VyIHJlZmVyZW5jZXMnKTtcblx0XHR9XG5cblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGNvbXBvbmVudC5fb3duZXIgPSBvd25lcjtcblx0XHR9XG5cblx0XHRpZiAoY29tcG9uZW50LnR5cGUgPT09ICdzdHlsZScpIHtcblx0XHRcdGNvbXBvbmVudC5wcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHtcblx0XHRcdFx0X19odG1sOiBjb21wb25lbnQucHJvcHMuY2hpbGRyZW5cblx0XHRcdH07XG5cdFx0XHRkZWxldGUgY29tcG9uZW50LnByb3BzLmNoaWxkcmVuO1xuXHRcdH1cblxuXHRcdHJldHVybiBhc3NpZ24oT2JqZWN0LmNyZWF0ZSh7XG5cdFx0XHRvdmVycmlkZVByb3BzOiBvdmVycmlkZVByb3BzXG5cdFx0fSksIGNvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHV2ZG9tO1xufVxuIiwiZXhwb3J0IHZhciBldmVudHNNYXAgPSB7XG5cdG9uY29weTogJ29uQ29weScsXG5cdG9uY3V0OiAnb25DdXQnLFxuXHRvbnBhc3RlOiAnb25QYXN0ZScsXG5cdG9ua2V5ZG93bjogJ29uS2V5RG93bicsXG5cdG9ua2V5cHJlc3M6ICdvbktleVByZXNzJyxcblx0b25rZXl1cDogJ29uS2V5VXAnLFxuXHRvbmZvY3VzOiAnb25Gb2N1cycsXG5cdG9uYmx1cjogJ29uQmx1cicsXG5cdG9uY2hhbmdlOiAnb25DaGFuZ2UnLFxuXHRvbmlucHV0OiAnb25JbnB1dCcsXG5cdG9uc3VibWl0OiAnb25TdWJtaXQnLFxuXHRvbmNsaWNrOiAnb25DbGljaycsXG5cdG9uY29udGV4dG1lbnU6ICdvbkNvbnRleHRNZW51Jyxcblx0b25kb3VibGVjbGljazogJ29uRG91YmxlQ2xpY2snLFxuXHRvbmRyYWc6ICdvbkRyYWcnLFxuXHRvbmRyYWdlbmQ6ICdvbkRyYWdFbmQnLFxuXHRvbmRyYWdlbnRlcjogJ29uRHJhZ0VudGVyJyxcblx0b25kcmFnZXhpdDogJ29uRHJhZ0V4aXQnLFxuXHRvbmRyYWdsZWF2ZTogJ29uRHJhZ0xlYXZlJyxcblx0b25kcmFnb3ZlcjogJ29uRHJhZ092ZXInLFxuXHRvbmRyYWdzdGFydDogJ29uRHJhZ1N0YXJ0Jyxcblx0b25kcm9wOiAnb25Ecm9wJyxcblx0b25tb3VzZWRvd246ICdvbk1vdXNlRG93bicsXG5cdG9ubW91c2VlbnRlcjogJ29uTW91c2VFbnRlcicsXG5cdG9ubW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZScsXG5cdG9ubW91c2Vtb3ZlOiAnb25Nb3VzZU1vdmUnLFxuXHRvbm1vdXNlb3V0OiAnb25Nb3VzZU91dCcsXG5cdG9ubW91c2VvdmVyOiAnb25Nb3VzZU92ZXInLFxuXHRvbm1vdXNldXA6ICdvbk1vdXNlVXAnLFxuXHRvbnRvdWNoY2FuY2VsOiAnb25Ub3VjaENhbmNlbCcsXG5cdG9udG91Y2hlbmQ6ICdvblRvdWNoRW5kJyxcblx0b250b3VjaG1vdmU6ICdvblRvdWNoTW92ZScsXG5cdG9udG91Y2hzdGFydDogJ29uVG91Y2hTdGFydCcsXG5cdG9uc2Nyb2xsOiAnb25TY3JvbGwnLFxuXHRvbndoZWVsOiAnb25XaGVlbCcsXG59O1xuIiwiaW1wb3J0IHNrYXRlIGZyb20gJ3NrYXRlanMvc3JjL3NrYXRlJztcbmltcG9ydCB7bm9kZXNUb0FycmF5fSBmcm9tICd1dmRvb20vbGliL3V0aWxzJztcbmltcG9ydCBNdXRhdGlvbk9ic2VydmVyIGZyb20gJ3NrYXRlanMvc3JjL211dGF0aW9uLW9ic2VydmVyJztcblxuaW1wb3J0IHtcblx0YXNzaWduLFxuXHR3YXJuaW5nLFxuXHRkZWVwQ29weSxcblx0SFRNTHRvTW9kZWwsXG5cdGZpbmRSb290UHJvcGVydHlOb2RlLFxuXHRNb2RlbEF0dHJUb0hUTUwsXG5cdHJlc29sdmVNb2RlbFJlZnNcbn0gZnJvbSAnLi9saWIvdXRpbHMnO1xuaW1wb3J0IHJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXInO1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vdGVtcGxhdGUnO1xuaW1wb3J0IGNyZWF0ZU1vZGVsRm9yIGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHtyZXNvbHZlfSBmcm9tICcuL2RlcGVuZGVuY3lSZXNvbHZlcic7XG5pbXBvcnQge2RlZmF1bHRzfSBmcm9tICcuL2NvbXBvbmVudC9zcGVjaWZpY2F0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgKHBhcmFtcywgc2NyaXB0cyA9IFtdKSA9PiB7XG5cdGlmICh0eXBlb2Yoc2NyaXB0cykgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzY3JpcHRzID0gW3NjcmlwdHNdO1xuXHR9XG5cblx0cmV0dXJuIHJlc29sdmUoYXNzaWduKGRlZXBDb3B5KGRlZmF1bHRzKSwgcGFyYW1zKSkudGhlbigoaW5zdGFuY2UpID0+IHtcblx0XHRzY3JpcHRzLmZvckVhY2goKHNjcmlwdCkgPT4gc2NyaXB0LmNhbGwoaW5zdGFuY2UpKTtcblxuXHRcdHZhciBjb21wb25lbnRQcm90byA9IGdhdGhlclVzZXJDb250cmFjdChpbnN0YW5jZSwgZGVmYXVsdHMpO1xuXHRcdHZhciBNb2RlbCA9IGNyZWF0ZU1vZGVsRm9yKGluc3RhbmNlLm5hbWUpO1xuXHRcdHZhciBhdHRyaWJ1dGVzID0ge307XG5cblx0XHRpbnN0YW5jZS5ob3N0QXR0cmlidXRlcy5mb3JFYWNoKChhdHRyTmFtZSkgPT4ge1xuXHRcdFx0YXR0cmlidXRlc1thdHRyTmFtZV0gPSAoZWxlbWVudCwgY2hhbmdlKSA9PiB7XG5cdFx0XHRcdC8vINCV0YHQu9C4INC/0L4g0LrQsNC60LjQvC3RgtC+INC/0YDQuNGH0LjQvdCw0Lwg0LzQvtC00LXQu9GMINC90LUg0LHRi9C70LAg0LPQvtGC0L7QstCwLCDRgtC+INC00LDQttC1INC90LUg0L/Ri9GC0LDQtdC80YHRjyBcblx0XHRcdFx0Ly8g0L7QsdGA0LDQsdCw0YLRi9Cy0LDRgtGMINCw0YLRgNC40LHRg9GC0YsuXG5cdFx0XHRcdGlmIChlbGVtZW50Lm1vZGVsTm9kZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHtuYW1lLCBuZXdWYWx1ZX0gPSBjaGFuZ2U7XG5cdFx0XHRcdHZhciBwcm9wZXJ0eSA9IGVsZW1lbnQubW9kZWxOb2RlLnF1ZXJ5U2VsZWN0b3IoYGNvbnRlbnRbbmFtZT1cIiR7bmFtZX1cIl1gKTtcblxuXHRcdFx0XHRpZiAocHJvcGVydHkgJiYgcHJvcGVydHkudGV4dENvbnRlbnQgIT0gbmV3VmFsdWUpIHtcblx0XHRcdFx0XHRwcm9wZXJ0eS50ZXh0Q29udGVudCA9IG5ld1ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgSFRNTEN1c3RvbUVsZW1lbnQgPSBza2F0ZShpbnN0YW5jZS5uYW1lLCB7XG5cdFx0XHRwcm90b3R5cGU6IGFzc2lnbih7XG5cdFx0XHRcdHRlbXBsYXRlOiBpbnN0YW5jZS50ZW1wbGF0ZVxuXHRcdFx0fSwgY29tcG9uZW50UHJvdG8sIHtcblx0XHRcdFx0X2F0dGFjaGVkOiBmYWxzZSxcblx0XHRcdFx0X3JlYWR5OiBmYWxzZSxcblxuXHRcdFx0XHRyZW5kZXJOb2RlOiBudWxsLFxuXHRcdFx0XHRtb2RlbE5vZGU6IG51bGwsXG5cdFx0XHRcdHJlbmRlcjogbnVsbCxcblxuXHRcdFx0XHRyZW5kZXJNb2RlbChmb3JjZSkge1xuXHRcdFx0XHRcdHZhciByZW5kZXJpbmdUcmVlO1xuXG5cdFx0XHRcdFx0Ly8g0JXRgdC70Lgg0LzRiyDQvNGLINC/0L7QvNC10L3Rj9C70Lgg0LIg0LzQvtC00LXQu9C4INGC0L4g0YfRgtC+INC90LUg0L7RgtGB0LvQtdC20LjQstCw0LXRgtGB0Y8gXG5cdFx0XHRcdFx0Ly8gTXV0YXRpb25PYnNlcnZlciAo0L3QsNC/0YDQuNC80LXRgCDQsNGC0YDQuNCx0YPRgtGLINGDINC/0L7RgtC+0LzQutC+0LIpLCDRgtC+IGZvcmNlINC/0L7QvNC+0LbQtdGCIFxuXHRcdFx0XHRcdC8vINC/0YDQuCDRgNC10L3QtNC10YDQuNC90LPQtSDRgdCx0YDQvtGB0LjRgtGMINC60LXRiCDQsiDQvNC+0LTQtdC70LguXG5cdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vZGVsTm9kZS5mbHVzaER1bXAoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyDQqNCw0LHQu9C+0L0g0LzQvtC20LXRgiDQsdGL0YLRjCDQutCw0Log0YTRg9C90LrRhtC40LXQuSDRgtCw0Log0LggVVZET00g0LTQtdGA0LXQstC+0LwuXG5cdFx0XHRcdFx0Ly8g0JXRgdC70Lgg0YjQsNCx0LvQvtC9IOKAkyDRhNGD0L3QutGG0LjRjywg0YLQviDQv9C10YDQtdC00LDQtdC8INC10LzRgyDQvNC+0LTQtdC70Ywg0Lgg0LbQtNC10Lwg0L3QsCDQstGL0YXQvtC00LUgXG5cdFx0XHRcdFx0Ly8g0L/RgNC10L7QsdGA0LDQt9C+0LLQsNC90L3QvtC1IFVWRE9NINC00LXRgNC10LLQvi5cblx0XHRcdFx0XHQvLyDQldGB0LvQuCDRiNCw0LHQu9C+0L0g4oCTIFVWRE9NINC00LXRgNC10LLQviwg0YLQviDQvtGC0L/RgNCw0LLQu9GP0LXQvCDQtdCz0L4g0Lgg0LzQvtC00LXQu9GMINC90LAg0L/RgNC10L7QsdGA0LDQt9C+0LLQsNC90LjQtSBcblx0XHRcdFx0XHQvLyDQsiBYU0wg0YjQsNCx0LvQvtC90LjQt9Cw0YLQvtGALlxuXHRcdFx0XHRcdGlmICh0aGlzLnRlbXBsYXRlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiB3YXJuaW5nKFxuXHRcdFx0XHRcdFx0XHQnVW5hYmxlIHRvIGxvY2F0ZSB0ZW1wbGF0ZSBmb3IgXCIlc1wiIGNvbXBvbmVudCcsXG5cdFx0XHRcdFx0XHRcdGluc3RhbmNlLm5hbWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodGhpcy50ZW1wbGF0ZSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdHJlbmRlcmluZ1RyZWUgPSB0aGlzLnRlbXBsYXRlKHJlc29sdmVNb2RlbFJlZnModGhpcy5tb2RlbE5vZGUuZHVtcCgpKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnRlbXBsYXRlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHJlbmRlcmluZ1RyZWUgPSB0ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCByZXNvbHZlTW9kZWxSZWZzKHRoaXMubW9kZWxOb2RlLmR1bXAoKSkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vINCe0YLQv9GA0LDQstC70Y/QtdC8INC/0L7Qu9GD0YfQtdC90L3QvtC1IFVWRE9NINC00LXRgNC10LLQviDQvdCwINC+0YLRgNC40YHQvtCy0LrRgy5cblx0XHRcdFx0XHRyZW5kZXJpbmdUcmVlICYmIHRoaXMucmVuZGVyKHJlbmRlcmluZ1RyZWUsICgpID0+IHtcblx0XHRcdFx0XHRcdHR5cGVvZihpbnN0YW5jZS5yZW5kZXJlZCkgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UucmVuZGVyZWQuY2FsbCh0aGlzKTtcblx0XHRcdFx0XHRcdCF0aGlzLl9yZWFkeSAmJiB0eXBlb2YoaW5zdGFuY2UucmVhZHkpID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLnJlYWR5LmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZWFkeSA9IHRydWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLFxuXG5cdFx0XHRhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuXG5cdFx0XHRldmVudHM6IGluc3RhbmNlLmV2ZW50cyxcblxuXHRcdFx0dGVtcGxhdGUoZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5tb2RlbE5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvdXRlck1vZGVsID0gSFRNTHRvTW9kZWwoZWxlbWVudCk7XG5cdFx0XHRcdHZhciBhdHRyTW9kZWwgPSB7fTtcblxuXHRcdFx0XHQvLyDQodC+0LHQuNGA0LDQtdC8INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjNGB0LrQuNC1INCw0YLRgNC40LHRg9GC0YsuXG5cdFx0XHRcdGluc3RhbmNlLmhvc3RBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJOYW1lKSA9PiB7XG5cdFx0XHRcdFx0dmFyIGF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuXHRcdFx0XHRcdGlmIChhdHRyVmFsdWUpIHtcblx0XHRcdFx0XHRcdGF0dHJNb2RlbFthdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR2YXIgbW9kZWwgPSBhc3NpZ24oe30sIGluc3RhbmNlLm1vZGVsLCBvdXRlck1vZGVsLCBhdHRyTW9kZWwpO1xuXG5cdFx0XHRcdGVsZW1lbnQubW9kZWxOb2RlID0gbmV3IE1vZGVsKCk7XG5cdFx0XHRcdGVsZW1lbnQubW9kZWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVsLWNoYW5nZWQnLCBvbk1vZGVsQ2hhbmdlLmJpbmQoZWxlbWVudCwgaW5zdGFuY2UpKTtcblx0XHRcdFx0ZWxlbWVudC5tb2RlbE5vZGUuZmlsbChtb2RlbCk7XG5cdFx0XHRcdGVsZW1lbnQubW9kZWxOb2RlLnJlc3VtZSgpO1xuXG5cdFx0XHRcdC8vINCU0LXQu9Cw0LXQvCDQsNCy0YLQvtCx0LjQvdC0INC60L7QvdGC0LXQutGB0YLQsCDQuiDQv9C+0LvRjNC30L7QstCw0YLQtdC70YzRgdC60LjQvCDQvNC10YLQvtC00LDQvC5cblx0XHRcdFx0T2JqZWN0LmtleXMoY29tcG9uZW50UHJvdG8pLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcblx0XHRcdFx0XHRlbGVtZW50W21ldGhvZE5hbWVdID0gZWxlbWVudFttZXRob2ROYW1lXS5iaW5kKGVsZW1lbnQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0eXBlb2YoaW5zdGFuY2UucHJlcGFyZSkgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UucHJlcGFyZS5jYWxsKGVsZW1lbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0Y3JlYXRlZChlbGVtZW50KSB7XG5cdFx0XHRcdC8vINCf0YDQuCDQutC70L7QvdC40YDQvtCy0LDQvdC40Lgg0Y3Qu9C10LzQtdC90YLQsCDQstGL0LfRi9Cy0LDQtdGCINGF0YPQuiBgY3JlYXRlZGAg0L3QviDQvdC1INCy0YvQt9GL0LLQsNC10YLRgdGPIGB0ZW1wbGF0ZWAsIFxuXHRcdFx0XHQvLyDQv9C+0Y3RgtC+0LzRgyDQtNC10LvQsNC10Lwg0Y3RgtC+INGB0LDQvNC+0YHRgtC+0Y/RgtC10LvRjNC90L4uXG5cdFx0XHRcdGlmIChlbGVtZW50Lm1vZGVsTm9kZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy50ZW1wbGF0ZShlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vINCV0YHQu9C4INGN0YLQviDQv9C+0LLRgtC+0YDQvdGL0Lkg0LLRi9C30L7QsiDQvNC10YLQvtC00LAg0LjQty3Qt9CwINC90LUg0LrQvtC90YHQuNGB0YLQtdC90YLQvdC+0YHRgtC4INC/0L7QstC10LTQtdC90LjRjyDQsiDRgNCw0LfQvdGL0YUgXG5cdFx0XHRcdC8vINCx0YDQsNGD0LfQtdGA0LDRhSwg0YLQviDQv9GA0L7QstC10YDRj9C10Lwg0YPRgdC70L7QstC40Y8g0L3QtdC+0LHRhdC+0LTQuNC80YvQtSDQtNC70Y8g0L/RgNCw0LLQuNC70YzQvdC+0Lkg0YPRgdC70L7QstC40Lgg0LXRgdC70Lgg0L7QvdC4IFxuXHRcdFx0XHQvLyDQstGL0L/QvtC70L3Rj9GO0YLRgdGPLCDRgtC+INCy0YvRhdC+0LTQuNC8INC40YUg0LzQtdGC0L7QtNCwLlxuXHRcdFx0XHRpZiAoZWxlbWVudC5yZW5kZXJOb2RlICYmIGVsZW1lbnQuY29udGFpbnMoZWxlbWVudC5yZW5kZXJOb2RlKSAmJiBlbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQubW9kZWxOb2RlKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFyQ29udGVudChlbGVtZW50KTtcblxuXHRcdFx0XHRlbGVtZW50LnJlbmRlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGAke2luc3RhbmNlLm5hbWV9LXZpZXdgKTtcblx0XHRcdFx0ZWxlbWVudC5yZW5kZXIgPSByZW5kZXJlcihlbGVtZW50LnJlbmRlck5vZGUpO1xuXG5cdFx0XHRcdGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5yZW5kZXJOb2RlKTtcblx0XHRcdFx0ZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50Lm1vZGVsTm9kZSk7XG5cblx0XHRcdFx0Ly8g0KDQtdCw0LvQuNC30L7QstGL0LLQsNC10Lwg0YHQv9C10YbQuNCw0LvRjNC90L7QtSDQv9C+0LLQtdC00LXQvdC40LUg0YMg0LrQvtC80L/QvtC90LXQvdGC0L7Qsi4g0JIg0LrQsNGH0LXRgdGC0LLQtSBjaGlsZE5vZGVzIFxuXHRcdFx0XHQvLyDQutC+0LzQv9C+0L3QtdC90YIg0LzQvtC20LXRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCy0YzRjiDQuCDQvNC+0LTQtdC70YwuINCU0LvRjyDQvtGB0YLQsNC70YzQvdGL0YUg0Y3Qu9C10LzQtdC90YLQvtCyIFxuXHRcdFx0XHQvLyDQv9GA0LjQvNC10L3Rj9GO0YLRgdGPINGB0LvQtdC00YPRjtGJ0LjQtSDQv9GA0LDQstC40LvQsDpcblx0XHRcdFx0Ly8gMS4g0JXRgdC70Lgg0L3QvtC00LAg0Y/QstC70Y/QtdGC0YHRjyDRgtC10LPQvtC8LCDQuNC80LXQtdGCIGBub2RlTmFtZWAgPT0gJ2NvbnRlbnQnINC4INCw0YLRgNC40LHRg9GCIGBuYW1lYCwgXG5cdFx0XHRcdC8vICAgINGC0L4g0LXQtSDQv9C10YDQtdC90L7RgdC40Lwg0LIg0LzQvtC00LXQu9GMO1xuXHRcdFx0XHQvLyAyLiDQkiDQvtGB0YLQsNC70YzQvdGL0YUg0YHQu9GD0YfQsNGP0YUg0LLRi9C90L7RgdC40Lwg0L3QvtC00YMg0LfQsCDQv9GA0LXQtNC10LvRiyDQutC+0LzQv9C+0L3QtdC90YLQsC4g0J/QvtC80LXRidCw0Y8g0LXQtSDRgdGA0LDQt9GDIFxuXHRcdFx0XHQvLyAgICDQv9C+0YHQu9C1INC60L7QvNC/0L7QvdC10L3RgtCwIChgbmV4dFNpYmxpbmdgKS5cblx0XHRcdFx0dmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuXHRcdFx0XHRcdG11dGF0aW9ucy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgobXV0YXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGZvciAobGV0IG5vZGUgb2YgbXV0YXRpb24uYWRkZWROb2Rlcykge1xuXHRcdFx0XHRcdFx0XHRpZiAobm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudCcpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgcHJvcE5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHByb3BOYW1lID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBtb3ZlQ2hpbGRBd2F5RnJvbU5vZGUobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG1vZGVsUHJvcCA9IGVsZW1lbnQubW9kZWxOb2RlLnF1ZXJ5U2VsZWN0b3IoYGNvbnRlbnRbbmFtZT1cIiR7cHJvcE5hbWV9XCJdYCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAobW9kZWxQcm9wKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50Lm1vZGVsTm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbW9kZWxQcm9wKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC5tb2RlbE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtb3ZlQ2hpbGRBd2F5RnJvbU5vZGUobm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuXHRcdFx0XHRcdGNoaWxkTGlzdDogdHJ1ZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0eXBlb2YoaW5zdGFuY2UuY3JlYXRlZCkgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY3JlYXRlZC5jYWxsKGVsZW1lbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0YXR0YWNoZWQoZWxlbWVudCkge1xuXHRcdFx0XHQvLyDQkdGL0LLQsNC10YIg0YfRgtC+INCyINC90LXQutC+0YLQvtGA0YvRhSDQsdGA0LDRg9C30LXRgNCw0YUgYXR0YWNoINC/0YDQvtC40YHRhdC+0LTQuNGCINGA0LDQvdGM0YjQtSBjcmVhdGUsINC/0L7RjdGC0L7QvNGDIFxuXHRcdFx0XHQvLyDRg9Cx0LXQttC00LDQtdC80YHRjyDRh9GC0L4g0L/QsNC50L/Qu9Cw0LnQvSDRgdC+0LfQtNCw0L3QuNGPINC60L7QvNC/0L7QvdC10L3RgtCwINC90LUg0L3QsNGA0YPRiNC10L0uXG5cdFx0XHRcdGlmIChlbGVtZW50Lm1vZGVsTm9kZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5jcmVhdGVkKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbWVudC5fYXR0YWNoZWQgPSB0cnVlO1xuXHRcdFx0XHRlbGVtZW50LnJlbmRlck1vZGVsKCk7XG5cdFx0XHRcdHR5cGVvZihpbnN0YW5jZS5hdHRhY2hlZCkgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuYXR0YWNoZWQuY2FsbChlbGVtZW50KTtcblx0XHRcdH0sXG5cblx0XHRcdGRldGFjaGVkKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudC5fYXR0YWNoZWQgPSBmYWxzZTtcblx0XHRcdFx0dHlwZW9mKGluc3RhbmNlLmRldGFjaGVkKSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5kZXRhY2hlZC5jYWxsKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dHlwZW9mKGluc3RhbmNlLnJlZ2lzdGVyZWQpID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLnJlZ2lzdGVyZWQoSFRNTEN1c3RvbUVsZW1lbnQpO1xuXHR9KVxuXHQuY2F0Y2goKGVycm9yKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKSk7XG59O1xuXG5mdW5jdGlvbiBvbk1vZGVsQ2hhbmdlKGluc3RhbmNlLCBldmVudCkge1xuXHR0aGlzLl9hdHRhY2hlZCAmJiB0aGlzLnJlbmRlck1vZGVsKCk7XG5cblx0aWYgKHR5cGVvZihpbnN0YW5jZS5tb2RlbENoYW5nZWQpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHtwcmV2U25hcHNob3QsIG5ld1NuYXBzaG90fSA9IGV2ZW50LmRldGFpbDtcblx0XHR2YXIge3N0cmluZ2lmeX0gPSBKU09OO1xuXG5cdFx0T2JqZWN0LmtleXMobmV3U25hcHNob3QpLm1hcCgocHJvcE5hbWUpID0+IHtcblx0XHRcdGlmIChzdHJpbmdpZnkocHJldlNuYXBzaG90W3Byb3BOYW1lXSkgIT0gc3RyaW5naWZ5KG5ld1NuYXBzaG90W3Byb3BOYW1lXSkpIHtcblx0XHRcdFx0cmV0dXJuIHByb3BOYW1lO1xuXHRcdFx0fVxuXHRcdH0pLmZpbHRlcihCb29sZWFuKS5tYXAoKHByb3BOYW1lKSA9PiB7XG5cdFx0XHR2YXIgcHJldlZhbHVlID0gTW9kZWxBdHRyVG9IVE1MKHByZXZTbmFwc2hvdCwgcHJvcE5hbWUpO1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5tb2RlbE5vZGUucXVlcnlTZWxlY3RvcihgY29udGVudFtuYW1lPVwiJHtwcm9wTmFtZX1cIl1gKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cHJvcE5hbWU6IHByb3BOYW1lLFxuXHRcdFx0XHRwcmV2VmFsdWU6IHByZXZWYWx1ZSxcblx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHR9O1xuXHRcdH0pLmZvckVhY2goKHBheWxvYWQpID0+IHtcblx0XHRcdHZhciB7cHJvcE5hbWUsIHByZXZWYWx1ZSwgdmFsdWV9ID0gcGF5bG9hZDtcblxuXHRcdFx0aW5zdGFuY2UubW9kZWxDaGFuZ2VkLmNhbGwodGhpcywgcHJvcE5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdhdGhlclVzZXJDb250cmFjdChpbnN0YW5jZSwgZGVmYXVsdHMpIHtcblx0dmFyIHVzZXJDb250cmFjdCA9IHt9O1xuXG5cdE9iamVjdC5rZXlzKGluc3RhbmNlKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRpZiAoIShrZXkgaW4gZGVmYXVsdHMpKSB7XG5cdFx0XHR1c2VyQ29udHJhY3Rba2V5XSA9IGluc3RhbmNlW2tleV07XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gdXNlckNvbnRyYWN0O1xufVxuXG5mdW5jdGlvbiBjbGVhckNvbnRlbnQobm9kZSkge1xuXHRub2Rlc1RvQXJyYXkobm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZCkgPT4gbm9kZS5yZW1vdmVDaGlsZChjaGlsZCkpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGRBd2F5RnJvbU5vZGUoY2hpbGQpIHtcblx0dmFyIHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG5cblx0aWYgKHBhcmVudC5uZXh0U2libGluZykge1xuXHRcdHBhcmVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgcGFyZW50Lm5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHRwYXJlbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdH1cbn1cbiIsImltcG9ydCB7YXNzaWduLCBkZWZlcn0gZnJvbSAnLi4vbGliL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRzID0ge1xuXHRuYW1lOiBudWxsLFxuXHRleHRlbmRzOiBudWxsLFxuXHRldmVudHM6IHt9LFxuXHRob3N0QXR0cmlidXRlczogW10sXG5cdG1vZGVsOiBudWxsLFxuXHR0ZW1wbGF0ZTogbnVsbCxcblx0cHJlcGFyZTogbnVsbCxcblx0Y3JlYXRlZDogbnVsbCxcblx0YXR0YWNoZWQ6IG51bGwsXG5cdHJlbmRlcmVkOiBudWxsLFxuXHRyZWFkeTogbnVsbCxcblx0ZGV0YWNoZWQ6IG51bGwsXG5cdG1vZGVsQ2hhbmdlZDogbnVsbCxcblxuXHRfYWRkRXZlbnQoZXZlbnQsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG5cdFx0dGhpcy5ldmVudHMgfHwgKHRoaXMuZXZlbnRzID0ge30pO1xuXHRcdHRoaXMuZXZlbnRzW1tldmVudCwgc2VsZWN0b3JdLmpvaW4oJyAnKV0gPSBoYW5kbGVyO1xuXHR9LFxuXG5cdF9hZGRGZWF0dXJlKGZlYXR1cmUpIHtcblx0XHRhc3NpZ24odGhpcywgZmVhdHVyZSk7XG5cdH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbmFjdGl2ZUNvbXBvbmVudFBvc3RmaXggPSAnLWRlZmluaXRpb24nO1xuZXhwb3J0IGNvbnN0IGluYWN0aXZlQ29tcG9uZW50TmFtZVJlZ2V4cCA9IG5ldyBSZWdFeHAoYCR7aW5hY3RpdmVDb21wb25lbnRQb3N0Zml4fSRgKTtcbmV4cG9ydCBjb25zdCBpbmFjdGl2ZUNvbXBvbmVudFJlZkRhdGFBdHRyID0gJ2RhdGEtcmVmZXJlbmNlLW5hbWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UoYmFzZSwgdGFyZ2V0KSB7XG5cdHZhciBldmVudHMgPSBiYXRjaEhhbmRsZXJzKGJhc2UuZXZlbnRzLCB0YXJnZXQuZXZlbnRzLCBPYmplY3Qua2V5cyhhc3NpZ24oe30sIGJhc2UuZXZlbnRzLCB0YXJnZXQuZXZlbnRzKSkpO1xuXHR2YXIgbGlmZWN5Y2xlTWV0aG9kcyA9IGJhdGNoSGFuZGxlcnMoYmFzZSwgdGFyZ2V0LCBbXG5cdFx0J3ByZXBhcmUnLFxuXHRcdCdjcmVhdGVkJyxcblx0XHQnYXR0YWNoZWQnLFxuXHRcdCdyZW5kZXJlZCcsXG5cdFx0J3JlYWR5Jyxcblx0XHQnZGV0YWNoZWQnLFxuXHRcdCdtb2RlbENoYW5nZWQnXG5cdF0pO1xuXHR2YXIgZHVwbGljYXRlcyA9IFtdO1xuXHR2YXIgaG9zdEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQoYmFzZS5ob3N0QXR0cmlidXRlcywgdGFyZ2V0Lmhvc3RBdHRyaWJ1dGVzKS5maWx0ZXIoQm9vbGVhbikuZmlsdGVyKChhdHRyTmFtZSkgPT4ge1xuXHRcdGlmICghfmR1cGxpY2F0ZXMuaW5kZXhPZihhdHRyTmFtZSkpIHtcblx0XHRcdGR1cGxpY2F0ZXMucHVzaChhdHRyTmFtZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBhc3NpZ24oe30sIGJhc2UsIHRhcmdldCwge1xuXHRcdGV2ZW50czogZXZlbnRzLFxuXHRcdGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcblx0XHRtb2RlbDogYXNzaWduKHt9LCBiYXNlLm1vZGVsLCB0YXJnZXQubW9kZWwpLFxuXHRcdHRlbXBsYXRlOiBiYXNlLnRlbXBsYXRlXG5cdH0sIGxpZmVjeWNsZU1ldGhvZHMpO1xufVxuXG5mdW5jdGlvbiBiYXRjaEhhbmRsZXJzKGJhc2UsIHRhcmdldCwgcHJvcExpc3QpIHtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXG5cdHByb3BMaXN0LmZvckVhY2goKHByb3ApID0+IHtcblx0XHRpZiAoYmFzZVtwcm9wXSAmJiB0YXJnZXRbcHJvcF0pIHtcblx0XHRcdHJlc3VsdFtwcm9wXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0XHRcdFx0YmFzZVtwcm9wXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0dGFyZ2V0W3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0W3Byb3BdID0gYmFzZVtwcm9wXSB8fCB0YXJnZXRbcHJvcF07XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IFByb21pc2UgZnJvbSAnLi9saWIvcHJvbWlzZSc7XG5pbXBvcnQge21lcmdlfSBmcm9tICcuL2NvbXBvbmVudC9zcGVjaWZpY2F0aW9uJztcbmltcG9ydCB7ZGVmZXJ9IGZyb20gJy4vbGliL3V0aWxzJztcblxudmFyIHJlZ2lzdHJ5ID0ge307XG52YXIgbGlzdGVuZXJzID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGluc3RhbmNlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdGlmIChpbnN0YW5jZS5leHRlbmRzKSB7XG5cdFx0XHRyZXR1cm4gd2FpdEZvcihpbnN0YW5jZS5leHRlbmRzKS50aGVuKChpbnN0YW5jZVRvRXh0ZW5kKSA9PiB7XG5cdFx0XHRcdHJlc29sdmUobWVyZ2UoaW5zdGFuY2VUb0V4dGVuZCwgaW5zdGFuY2UpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXNvbHZlKGluc3RhbmNlKTtcblx0fSkudGhlbigocmVzb2x2ZWRJbnN0YW5jZSkgPT4ge1xuXHRcdHJldHVybiBzZXQocmVzb2x2ZWRJbnN0YW5jZSk7XG5cdH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XG5cdHJldHVybiByZWdpc3RyeVtpZF07XG59XG5cbmZ1bmN0aW9uIHNldChpbnN0YW5jZSkge1xuXHR2YXIgaWQgPSBpbnN0YW5jZS5uYW1lO1xuXG5cdGlmIChyZWdpc3RyeVtpZF0gPT0gbnVsbCkge1xuXHRcdHJlZ2lzdHJ5W2lkXSA9IGluc3RhbmNlO1xuXHRcdGxpc3RlbmVyc1tpZF0gJiYgbGlzdGVuZXJzW2lkXS5yZXNvbHZlKGluc3RhbmNlKTtcblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBvZiAke2luc3RhbmNlLm5hbWV9IGFscmVhZHkgZXhpc3RzLmApO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yKGlkKSB7XG5cdHZhciBpc0ZpcnN0TGlzdGVuZXIgPSBmYWxzZTtcblxuXHRpZiAoIWxpc3RlbmVyc1tpZF0pIHtcblx0XHRsaXN0ZW5lcnNbaWRdID0gZGVmZXIoKTtcblx0XHRpc0ZpcnN0TGlzdGVuZXIgPSB0cnVlO1xuXHR9XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdHZhciB0YXJnZXRJbnN0YW5jZSA9IGdldChpZCk7XG5cblx0XHRsaXN0ZW5lcnNbaWRdLmNoYWluKHJlc29sdmUpO1xuXG5cdFx0aWYgKHRhcmdldEluc3RhbmNlICYmIGlzRmlyc3RMaXN0ZW5lcikge1xuXHRcdFx0bGlzdGVuZXJzW2lkXS5yZXNvbHZlKHRhcmdldEluc3RhbmNlKTtcblx0XHR9XG5cdH0pO1xufVxuIiwiaW1wb3J0IFByb21pc2VTaGltIGZyb20gJ2VzNi1wcm9taXNlL2xpYi9lczYtcHJvbWlzZS9wcm9taXNlJztcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mKFByb21pc2UpICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBQcm9taXNlU2hpbTtcbiIsImltcG9ydCBwYXJzZXIgZnJvbSAndXZkb29tL3BhcnNlcic7XG5pbXBvcnQgcmVnaXN0cnkgZnJvbSAnc2thdGVqcy9zcmMvcmVnaXN0cnknO1xuXG5pbXBvcnQge1xuXHRub2Rlc1RvQXJyYXksXG5cdGlzQ29tbW9uRWxlbWVudFxufSBmcm9tICd1dmRvb20vbGliL3V0aWxzJztcblxuaW1wb3J0IHtcblx0aW5hY3RpdmVDb21wb25lbnRQb3N0Zml4LFxuXHRpbmFjdGl2ZUNvbXBvbmVudFJlZkRhdGFBdHRyXG59IGZyb20gJy4uL2NvbXBvbmVudC9zcGVjaWZpY2F0aW9uJztcblxuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9wcm9taXNlJztcblxuZnVuY3Rpb24gVG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciBrZXlzO1xuXHR2YXIgdG8gPSBUb09iamVjdCh0YXJnZXQpO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IGFyZ3VtZW50c1tzXTtcblx0XHRrZXlzID0gT2JqZWN0LmtleXMoT2JqZWN0KGZyb20pKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dG9ba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuXHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoZm9ybWF0LCAuLi5hcmdzKSB7XG5cdHZhciBhcmdJbmRleCA9IDA7XG5cblx0Y29uc29sZS53YXJuKGBXYXJuaW5nOiAke2Zvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKSA9PiBhcmdzW2FyZ0luZGV4KytdKX1gKTtcbn1cblxuLy8g0JHRi9GB0YLRgNCw0Y8g0YDQtdCw0LvQuNC30LDRhtC40Y8g0LPQu9GD0LHQvtC60L7Qs9C+INC60LvQvtC90LjRgNC+0LLQsNC90LjRjyDRgSDQv9C+0LTQtNC10YDQttC60L7QuSDQvNC90L7Qs9C40YUg0YLQuNC/0L7Qsi5cbi8vINCa0L7QtCDQstC30Y/RgiDQuNC3IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNDI2NzYvODk2MjgwXG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkodGFyZ2V0KSB7XG5cdGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0eXBlb2YodGFyZ2V0KSAhPSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHRpZiAodGFyZ2V0LmNvbnN0cnVjdG9yICE9IE9iamVjdCAmJiB0YXJnZXQuY29uc3RydWN0b3IgIT0gQXJyYXkpIHtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0aWYgKH5bXG5cdFx0RGF0ZSxcblx0XHRSZWdFeHAsXG5cdFx0RnVuY3Rpb24sXG5cdFx0U3RyaW5nLFxuXHRcdE51bWJlcixcblx0XHRCb29sZWFuLFxuXHRdLmluZGV4T2YodGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xuXHRcdHJldHVybiBuZXcgdGFyZ2V0LmNvbnN0cnVjdG9yKHRhcmdldCk7XG5cdH1cblxuXHR2YXIgcmVzdWx0ID0gbmV3IHRhcmdldC5jb25zdHJ1Y3RvcigpO1xuXG5cdGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG5cdFx0cmVzdWx0W25hbWVdID0gdHlwZW9mKHJlc3VsdFtuYW1lXSkgPT09ICd1bmRlZmluZWQnID8gZGVlcENvcHkodGFyZ2V0W25hbWVdKSA6IHJlc3VsdFtuYW1lXTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIVE1MdG9Nb2RlbChub2RlKSB7XG5cdHZhciBtb2RlbCA9IHt9O1xuXG5cdG5vZGVzVG9BcnJheShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goKGNoaWxkKSA9PiB7XG5cdFx0aWYgKGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdFx0dmFyIHByb3BlcnR5ID0gcGFyc2VyKGNoaWxkLCB7XG5cdFx0XHRcdG9uVGFnTmFtZVJlc29sdmU6IChub2RlKSA9PiB7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcmVhY3RpZCcpO1xuXHRcdFx0XHRcdHJldHVybiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR2YXIge25hbWV9ID0gKHByb3BlcnR5LmF0dHJzIHx8IHt9KTtcblxuXHRcdFx0aWYgKHByb3BlcnR5LmNvbXBvbmVudCA9PT0gJ2NvbnRlbnQnICYmIG5hbWUpIHtcblx0XHRcdFx0bW9kZWxbbmFtZV0gPSBwcm9wZXJ0eS5jaGlsZHJlbjtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBtb2RlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1vZGVsQXR0clRvSFRNTChtb2RlbCwgYXR0ck5hbWUpIHtcblx0cmV0dXJuIE1vZGVsVG9IVE1MKG1vZGVsKS5xdWVyeVNlbGVjdG9yKGBjb250ZW50W25hbWU9XCIke2F0dHJOYW1lfVwiXWApO1xufVxuXG5mdW5jdGlvbiB1dmRvbU5vZGVUb1JlZihub2RlLCBuYW1lKSB7XG5cdG5vZGUuYXR0cnMgfHwgKG5vZGUuYXR0cnMgPSB7fSk7XG5cdG5vZGUuYXR0cnNbaW5hY3RpdmVDb21wb25lbnRSZWZEYXRhQXR0cl0gPSBuYW1lO1xuXHRyZXR1cm4gbmFtZSArIGluYWN0aXZlQ29tcG9uZW50UG9zdGZpeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1vZGVsVG9IVE1MKG1vZGVsKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRPYmplY3Qua2V5cyhtb2RlbCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdHZhciB1dmRvbU5vZGUgPSB7XG5cdFx0XHRjb21wb25lbnQ6ICdjb250ZW50Jyxcblx0XHRcdGF0dHJzOiB7XG5cdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdH0sXG5cdFx0XHRjaGlsZHJlbjogbW9kZWxbbmFtZV1cblx0XHR9O1xuXG5cdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQocGFyc2VyLnV2ZG9tVG9IVE1MKHV2ZG9tTm9kZSwge1xuXHRcdFx0b25UeXBlTmFtZVJlc29sdmUodXZkb21Ob2RlKSB7XG5cdFx0XHRcdHZhciB7dGFnLCBjb21wb25lbnR9ID0gdXZkb21Ob2RlO1xuXG5cdFx0XHRcdC8vINCe0LHRgNCw0LHQsNGC0YvQstCw0LXQvCDQutCw0YHRgtC+0LzQvdGL0LUg0Y3Qu9C10LzQtdC90YLRiyDQvNC+0LTQtdC70LguINCe0L3QuCDQvdC1INC00L7Qu9C20L3RiyDQuNC90LjRhtC40LDQu9C40LfQuNGA0L7QstCw0YLRjNGB0Y8gXG5cdFx0XHRcdC8vINC4INC00L7Qu9C20L3RiyDQsdGL0YLRjCDQvNCw0LrRgdC40LzQsNC70YzQvdC+INC40L3QtdGA0YLQvdGLLlxuXHRcdFx0XHQvLyBbVE9ET10g0JTQvtCx0LDQstC40YLRjCDQvtCx0YDQsNCx0L7RgtC60YMg0YLQtdCz0L7Qsiwg0LrQvtGC0L7RgNGL0LUg0LfQsNCz0YDRg9C20LDRjtGCINCy0L3QtdGI0L3QuNC1INGA0LXRgdGD0YDRgdGLIChpbWcg0Lgg0YIu0LQuKS4gXG5cdFx0XHRcdC8vINCY0YUg0YLQvtC20LUg0L3QtdC+0LHRhdC+0LTQuNC80L4g0YHQtNC10LvQsNGC0Ywg0LjQvdC10YDRgtC90YvQvNC4INCyINC80L7QtNC10LvQuC5cblx0XHRcdFx0aWYgKGNvbXBvbmVudCAhPSBudWxsICYmIHJlZ2lzdHJ5LmdldChjb21wb25lbnQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV2ZG9tTm9kZVRvUmVmKHV2ZG9tTm9kZSwgY29tcG9uZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0YWcgIT0gbnVsbCAmJiB+WydzdHlsZScsICdzY3JpcHQnXS5pbmRleE9mKHRhZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXZkb21Ob2RlVG9SZWYodXZkb21Ob2RlLCB0YWcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRhZyB8fCBjb21wb25lbnQ7XG5cdFx0XHR9XG5cdFx0fSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUm9vdFByb3BlcnR5Tm9kZShub2RlKSB7XG5cdGlmIChub2RlID09IG51bGwgfHwgbm9kZS5ub2RlVHlwZSA9PSBudWxsKSB7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHR2YXIge3RhZ05hbWV9ID0gbm9kZTtcblxuXHRpZiAodGFnTmFtZSAmJiB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50JyAmJiBub2RlLmhhc0F0dHJpYnV0ZSgnbmFtZScpKSB7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRpZiAobm9kZS5wYXJlbnROb2RlICE9IG51bGwpIHtcblx0XHRyZXR1cm4gZmluZFJvb3RQcm9wZXJ0eU5vZGUobm9kZS5wYXJlbnROb2RlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU1vZGVsUmVmcyhtb2RlbCkge1xuXHR2YXIgbW9kZWxGcmFnbWVudCA9IE1vZGVsVG9IVE1MKG1vZGVsKTtcblx0dmFyIHNlbGVjdE5vZGVzID0gbm9kZXNUb0FycmF5KG1vZGVsRnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnY29udGVudFtzZWxlY3RdJykpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0Tm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZWxlbWVudCA9IHNlbGVjdE5vZGVzW2ldO1xuXHRcdHZhciB0YXJnZXQgPSBtb2RlbEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoYGNvbnRlbnRbbmFtZT1cIiR7ZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NlbGVjdCcpfVwiXWApO1xuXG5cdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0dmFyIHRhcmdldENsb25lID0gdGFyZ2V0LmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdHZhciB0YXJnZXRQbGFjZWhvbGRlcnMgPSB0YXJnZXRDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCdjb250ZW50Om5vdChbc2VsZWN0XSk6bm90KFtyZWZdKTpub3QoW25hbWVdKScpO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gbm9kZXNUb0FycmF5KGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXMpO1xuXG5cdFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoICYmIHRhcmdldFBsYWNlaG9sZGVycy5sZW5ndGgpIHtcblx0XHRcdFx0bm9kZXNUb0FycmF5KHRhcmdldFBsYWNlaG9sZGVycykuZm9yRWFjaCgobm9kZSkgPT4ge1xuXHRcdFx0XHRcdGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG5cdFx0XHRcdFx0XHRub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBub2RlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5uZXJTZWxlY3ROb2RlcyA9IG5vZGVzVG9BcnJheSh0YXJnZXRDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCdjb250ZW50W3NlbGVjdF0nKSk7XG5cblx0XHRcdGlmIChpbm5lclNlbGVjdE5vZGVzKSB7XG5cdFx0XHRcdHNlbGVjdE5vZGVzID0gc2VsZWN0Tm9kZXMuY29uY2F0KGlubmVyU2VsZWN0Tm9kZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRub2Rlc1RvQXJyYXkodGFyZ2V0Q2xvbmUuY2hpbGROb2RlcykuZm9yRWFjaCgoY2hpbGQpID0+IHtcblx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cdH1cblxuXHRub2Rlc1RvQXJyYXkobW9kZWxGcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdjb250ZW50W3NlbGVjdF0nKSkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuXHRcdHZhciB0YXJnZXQgPSBtb2RlbEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoYGNvbnRlbnRbbmFtZT1cIiR7ZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NlbGVjdCcpfVwiXWApO1xuXG5cdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0dmFyIHRhcmdldENsb25lID0gdGFyZ2V0LmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdHZhciB0YXJnZXRQbGFjZWhvbGRlcnMgPSB0YXJnZXRDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCdjb250ZW50Om5vdChbc2VsZWN0XSk6bm90KFtyZWZdKTpub3QoW25hbWVdKScpO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gbm9kZXNUb0FycmF5KGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXMpO1xuXG5cdFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoICYmIHRhcmdldFBsYWNlaG9sZGVycy5sZW5ndGgpIHtcblx0XHRcdFx0bm9kZXNUb0FycmF5KHRhcmdldFBsYWNlaG9sZGVycykuZm9yRWFjaCgobm9kZSkgPT4ge1xuXHRcdFx0XHRcdGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG5cdFx0XHRcdFx0XHRub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBub2RlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRub2Rlc1RvQXJyYXkodGFyZ2V0Q2xvbmUuY2hpbGROb2RlcykuZm9yRWFjaCgoY2hpbGQpID0+IHtcblx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdG5vZGVzVG9BcnJheShtb2RlbEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvbnRlbnRbcmVmXScpKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG5cdFx0dmFyIHRhcmdldCA9IG1vZGVsRnJhZ21lbnQucXVlcnlTZWxlY3RvcihgY29udGVudFtuYW1lPVwiJHtlbGVtZW50LmdldEF0dHJpYnV0ZSgncmVmJyl9XCJdYCk7XG5cblx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRub2Rlc1RvQXJyYXkodGFyZ2V0LmNsb25lTm9kZSh0cnVlKS5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuXHRcdFx0XHRlbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdH0pO1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JlZicpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIEhUTUx0b01vZGVsKG1vZGVsRnJhZ21lbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmZXIoKSB7XG5cdHZhciBkZWZlcnJlZCA9IHt9O1xuXG5cdGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuXHR9KTtcblxuXHRkZWZlcnJlZC5jaGFpbiA9IChoYW5kbGVyKSA9PiB7XG5cdFx0ZGVmZXJyZWQucHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UudGhlbigoZGF0YSkgPT4ge1xuXHRcdFx0aGFuZGxlcihkYXRhKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBkZWZlcnJlZDtcbn1cblxuLy8g0KjQuNC8INC00LvRjyBDdXN0b21FdmVudCAoSUUgPiA5KVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KG5hbWUsIHBhcmFtcykge1xuXHR2YXIgZXZlbnQ7XG5cblx0cGFyYW1zID0gYXNzaWduKHtcblx0XHRidWJibGVzOiBmYWxzZSxcblx0XHRjYW5jZWxhYmxlOiBmYWxzZSxcblx0XHRkZXRhaWw6IHVuZGVmaW5lZFxuXHR9LCBwYXJhbXMpO1xuXG5cdHRyeSB7XG5cdFx0ZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwgcGFyYW1zKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0ZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcblx0XHRldmVudC5pbml0Q3VzdG9tRXZlbnQobmFtZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcblx0fVxuXG5cdHJldHVybiBldmVudDtcbn1cbiIsImltcG9ydCBza2F0ZSBmcm9tICdza2F0ZWpzL3NyYy9za2F0ZSc7XG5pbXBvcnQgTXV0YXRpb25PYnNlcnZlciBmcm9tICdza2F0ZWpzL3NyYy9tdXRhdGlvbi1vYnNlcnZlcic7XG5pbXBvcnQgcGFyc2VyIGZyb20gJ3V2ZG9vbS9wYXJzZXInO1xuXG5pbXBvcnQge1xuXHRIVE1MdG9Nb2RlbCxcblx0TW9kZWxUb0hUTUwsXG5cdGNyZWF0ZUV2ZW50XG59IGZyb20gJy4vbGliL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgKGluc3RhbmNlTmFtZSkgPT4ge1xuXHR2YXIgbW9kZWxOYW1lID0gYCR7aW5zdGFuY2VOYW1lIHx8ICd1bmtub3duJ30tbW9kZWxgO1xuXG5cdHJldHVybiBza2F0ZShtb2RlbE5hbWUsIHtcblx0XHRwcm90b3R5cGU6IHtcblx0XHRcdF9kdW1wOiBudWxsLFxuXG5cdFx0XHRkaXNwYXRjaGVyOiBudWxsLFxuXHRcdFx0b2JzZXJ2ZXI6IG51bGwsXG5cblx0XHRcdGdldChuYW1lID0gJycsIHNlbGVjdG9yKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYGNvbnRlbnRbbmFtZT1cIiR7bmFtZX1cIl1gKTtcblxuXHRcdFx0XHRpZiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSByZXN1bHQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHRcdGdldFZhbHVlKG5hbWUpIHtcblx0XHRcdFx0dmFyIHByb3AgPSB0aGlzLmdldChuYW1lKTtcblxuXHRcdFx0XHRpZiAocHJvcCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9wLnRleHRDb250ZW50O1xuXHRcdFx0fSxcblxuXHRcdFx0ZHVtcCgpIHtcblx0XHRcdFx0dGhpcy5fZHVtcCB8fCAodGhpcy5fZHVtcCA9IEhUTUx0b01vZGVsKHRoaXMpKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1bXA7XG5cdFx0XHR9LFxuXG5cdFx0XHRmbHVzaER1bXAoKSB7XG5cdFx0XHRcdHRoaXMuX2R1bXAgPSBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0ZmlsbChtb2RlbCkge1xuXHRcdFx0XHR0aGlzLmFwcGVuZENoaWxkKE1vZGVsVG9IVE1MKG1vZGVsKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzdXNwZW5kKCkge1xuXHRcdFx0XHR0aGlzLm9ic2VydmVyICE9IG51bGwgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0cmVzdW1lKCkge1xuXHRcdFx0XHR0aGlzLm9ic2VydmVyICE9IG51bGwgJiYgdGhpcy5zdXNwZW5kKCk7XG5cdFx0XHRcdHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmRpc3BhdGNoZXIpO1xuXHRcdFx0XHR0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcywge1xuXHRcdFx0XHRcdGNoaWxkTGlzdDogdHJ1ZSxcblx0XHRcdFx0XHRzdWJ0cmVlOiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0YmF0Y2hVcGRhdGUodXBkYXRlcikge1xuXHRcdFx0XHRpZiAodHlwZW9mKHVwZGF0ZXIpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhpcy5zdXNwZW5kKCk7XG5cdFx0XHRcdFx0dXBkYXRlci5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMucmVzdW1lKCk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGVtcGxhdGUoZWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdH0sXG5cblx0XHRjcmVhdGVkKGVsZW1lbnQpIHtcblx0XHRcdGVsZW1lbnQuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXIuYmluZChlbGVtZW50KTtcblx0XHR9XG5cdH0pO1xufTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hlcihtdXRhdGlvbnMgPSBbXSkge1xuXHR2YXIgcHJldlNuYXBzaG90ID0gdGhpcy5kdW1wKCk7XG5cdHZhciBuZXdTbmFwc2hvdDtcblxuXHR0aGlzLmZsdXNoRHVtcCgpO1xuXHRuZXdTbmFwc2hvdCA9IHRoaXMuZHVtcCgpO1xuXG5cdHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KCdtb2RlbC1jaGFuZ2VkJywge1xuXHRcdGRldGFpbDoge1xuXHRcdFx0cHJldlNuYXBzaG90OiBwcmV2U25hcHNob3QsXG5cdFx0XHRuZXdTbmFwc2hvdDogbmV3U25hcHNob3QsXG5cdFx0XHRtdXRhdGlvbnM6IG11dGF0aW9uc1xuXHRcdH1cblx0fSk7XG5cblx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cbiIsImltcG9ydCBwYXJzZXIgZnJvbSAndXZkb29tL3BhcnNlcic7XG5cbmltcG9ydCBkZWZhdWx0UmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9kZWZhdWx0JztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL2xpYi91dGlscyc7XG5cbnZhciByZW5kZXJlciA9IGRlZmF1bHRSZW5kZXJlcjtcblxudmFyIHJlbmRlciA9ICh0YXJnZXQpID0+IHtcblx0cmV0dXJuICh1dmRvbSwgZG9uZSkgPT4gcmVuZGVyZXIodGFyZ2V0LCB1dmRvbSwgZG9uZSwgcGFyc2VyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduKHJlbmRlciwge1xuXHRkZWZhdWx0OiBkZWZhdWx0UmVuZGVyZXIsXG5cblx0cmVnaXN0ZXIoY3VzdG9tUmVuZGVyZXIpIHtcblx0XHRpZiAodHlwZW9mKGN1c3RvbVJlbmRlcmVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmVuZGVyZXIgPSBjdXN0b21SZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHBhcnNlciBmcm9tICd1dmRvb20vcGFyc2VyJztcblxuZXhwb3J0IGRlZmF1bHQgKHRhcmdldCwgdXZkb20sIGRvbmUpID0+IHtcblx0dGFyZ2V0LmlubmVySFRNTCA9ICcnO1xuXHR0YXJnZXQuYXBwZW5kQ2hpbGQocGFyc2VyLnV2ZG9tVG9IVE1MKHV2ZG9tKSk7XG5cdGRvbmUoKTtcbn1cbiIsImltcG9ydCBUZW1wbGF0ZUNvbnRleHQgZnJvbSAndGVtcGxhdGUtcHJvdG8vbGliL2NvbnRleHQvdGVtcGxhdGUnO1xuaW1wb3J0IERvY3VtZW50IGZyb20gJ3RlbXBsYXRlLXByb3RvL2xpYi9kb20vZG9jdW1lbnQnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAndGVtcGxhdGUtcHJvdG8vbGliL2RvbS9lbGVtZW50JztcbmltcG9ydCBUZXh0IGZyb20gJ3RlbXBsYXRlLXByb3RvL2xpYi9kb20vdGV4dCc7XG5cbmltcG9ydCB7VXZkb21BdHRyVG9IdG1sQXR0cn0gZnJvbSAndXZkb29tL2xpYi91dGlscyc7XG5pbXBvcnQgcGFyc2VyIGZyb20gJ3V2ZG9vbS9wYXJzZXInO1xuXG5pbXBvcnQge2luYWN0aXZlQ29tcG9uZW50UmVmRGF0YUF0dHJ9IGZyb20gJy4vY29tcG9uZW50L3NwZWNpZmljYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCAodGVtcGxhdGVVVkRPTSwgbW9kZWxVVkRPTSkgPT4ge1xuXHR2YXIgdGVtcGxhdGVYbWwgPSBwYXJzZVVWRE9NKHRlbXBsYXRlVVZET00pO1xuXHR2YXIgbW9kZWxYbWwgPSBwYXJzZU1vZGVsKG1vZGVsVVZET00pO1xuXG5cdHZhciB0ZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZUNvbnRleHQodGVtcGxhdGVYbWwpO1xuXHR2YXIgcmVzdWx0ID0gdGVtcGxhdGUudHJhbnNmb3JtKG1vZGVsWG1sKTtcblxuXHRyZXR1cm4gcGFyc2VyKHJlc3VsdC5pbm5lckhUTUwsIHtcblx0XHRvblRhZ05hbWVSZXNvbHZlKG5vZGUpIHtcblx0XHRcdHZhciByZWZlcmVuY2VOYW1lID0gbm9kZS5nZXRBdHRyaWJ1dGUoaW5hY3RpdmVDb21wb25lbnRSZWZEYXRhQXR0cik7XG5cblx0XHRcdGlmIChyZWZlcmVuY2VOYW1lKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKGluYWN0aXZlQ29tcG9uZW50UmVmRGF0YUF0dHIpO1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJlbmNlTmFtZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0KG5vZGUsIGN0eCkge1xuXHRpZiAobm9kZSA9PSBudWxsKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHR5cGVvZihub2RlKSA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgb3V0ID0gbmV3IFRleHQobm9kZSk7XG5cblx0XHRjdHggJiYgY3R4LmFwcGVuZENoaWxkKG91dCk7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdHZhciBvdXQgPSBuZXcgRWxlbWVudChub2RlLnRhZyB8fCBub2RlLmNvbXBvbmVudCk7XG5cblx0aWYgKG5vZGUuYXR0cnMpIHtcblx0XHRPYmplY3Qua2V5cyhub2RlLmF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdG91dC5zZXRBdHRyaWJ1dGUoVXZkb21BdHRyVG9IdG1sQXR0cihuYW1lKSwgbm9kZS5hdHRyc1tuYW1lXSk7XG5cdFx0fSk7XG5cdH1cblxuXHRjdHggJiYgY3R4LmFwcGVuZENoaWxkKG91dCk7XG5cblx0W10uY29uY2F0KG5vZGUuY2hpbGRyZW4gfHwgW10pLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRjb252ZXJ0KGNoaWxkLCBvdXQpO1xuXHR9KTtcblxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVVWRE9NKHV2ZG9tKSB7XG5cdHZhciBkb2N1bWVudCA9IG5ldyBEb2N1bWVudCgpO1xuXG5cdHV2ZG9tICYmIGNvbnZlcnQodXZkb20sIGRvY3VtZW50KTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwobW9kZWwpIHtcblx0dmFyIGRvY3VtZW50ID0gbmV3IERvY3VtZW50KCk7XG5cdHZhciBtb2RlbE5vZGUgPSB7XG5cdFx0Y29tcG9uZW50OiAnbW9kZWwnLFxuXHRcdGNoaWxkcmVuOiBbXVxuXHR9O1xuXG5cdE9iamVjdC5rZXlzKG1vZGVsKS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0bW9kZWxOb2RlLmNoaWxkcmVuLnB1c2goe1xuXHRcdFx0Y29tcG9uZW50OiAnY29udGVudCcsXG5cdFx0XHRhdHRyczoge1xuXHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHR9LFxuXHRcdFx0Y2hpbGRyZW46IG1vZGVsW25hbWVdXG5cdFx0fSk7XG5cdH0pO1xuXG5cdGNvbnZlcnQobW9kZWxOb2RlLCBkb2N1bWVudCk7XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufVxuIiwiaW1wb3J0IGJhYmVsUG9seWZpbGwgZnJvbSAnYmFiZWwvcG9seWZpbGwnO1xuXG5pbXBvcnQgY29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50JztcbmltcG9ydCByZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL2xpYi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcblx0dmFyIHByb3h5ID0gKC4uLmFyZ3MpID0+IGNvbXBvbmVudCguLi5hcmdzKTtcblxuXHRyZXR1cm4gYXNzaWduKHByb3h5LCB7XG5cdFx0cmVuZGVyOiByZW5kZXJlclxuXHR9KTtcbn1cbiJdfQ==
;
	return require('WebComponents')(module.config());
});